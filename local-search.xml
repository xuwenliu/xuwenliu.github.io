<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TS中的类型推论</title>
    <link href="/2020/05/07/ts/type-inference/"/>
    <url>/2020/05/07/ts/type-inference/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是类型推论"><a href="#1-什么是类型推论" class="headerlink" title="1.什么是类型推论"></a>1.什么是类型推论</h3><blockquote><p>TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型</p></blockquote><pre><code class="ts">let x = 3;</code></pre><p>变量<code>x</code>的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p><h3 id="2-最佳通用类型"><a href="#2-最佳通用类型" class="headerlink" title="2.最佳通用类型"></a>2.最佳通用类型</h3><blockquote><p>当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。</p></blockquote><pre><code class="ts">let x = [0, 1, null];</code></pre><p>为了推断<code>x</code>的类型，我们必须考虑所有元素的类型。<br>这里有两种选择： <code>number</code>和<code>null</code>。<br>计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p><p>由于最终的<code>通用类型</code>取自<code>候选类型</code>，有些时候<code>候选类型</code>共享相同的<code>通用类型</code>，但是却没有一个类型能做为所有候选类型的类型。例如：</p><pre><code class="ts">let zoo = [new Rhino(), new Elephant(), new Snake()];</code></pre><p>这里，我们想让zoo被推断为<code>Animal[]</code>类型，但是这个数组里没有对象是<code>Animal</code>类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：</p><pre><code class="ts">let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];</code></pre><p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Rhino | Elephant | Snake)[]</code>。</p><h3 id="3-上下文类型"><a href="#3-上下文类型" class="headerlink" title="3.上下文类型"></a>3.上下文类型</h3><blockquote><p>TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如：</p></blockquote><pre><code class="ts">window.onmousedown = function(mouseEvent) {    console.log(mouseEvent.button);  //&lt;- Error};</code></pre><p>这个例子会得到一个类型错误，TypeScript类型检查器使用<code>Window.onmousedown</code>函数的类型来推断右边函数表达式的类型。 因此，就能推断出 <code>mouseEvent</code>参数的类型了。 如果函数表达式不是在上下文类型的位置， <code>mouseEvent</code>参数的类型需要指定为<code>any</code>，这样也不会报错了。</p><p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。 重写上面的例子：</p><pre><code class="ts">window.onmousedown = function(mouseEvent: any) {    console.log(mouseEvent.button);  //&lt;- Now, no error is given};</code></pre><p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。 这样的话就不报错了，因为这里不会使用到上下文类型。</p><ul><li><p>上下文归类会在很多情况下使用到。 </p></li><li><p>通常包含<code>函数的参数</code>，<code>赋值表达式的右边</code>，<code>类型断言</code>，<code>对象成员</code>和<code>数组字面量</code>和<code>返回值语句</code>。 </p></li><li><p>上下文类型也会做为最佳通用类型的候选类型。比如：</p></li></ul><pre><code class="ts">function createZoo(): Animal[] {    return [new Rhino(), new Elephant(), new Snake()];}</code></pre><p>这个例子里，最佳通用类型有4个候选者：<code>Animal</code>，<code>Rhino</code>，<code>Elephant</code>和<code>Snake</code>。<br>当然， <code>Animal</code>会被做为最佳通用类型。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你一定要知道的护肤品牌</title>
    <link href="/2020/05/07/life/you-konw/"/>
    <url>/2020/05/07/life/you-konw/</url>
    
    <content type="html"><![CDATA[<h4 id="1-洗面奶-芙丽芳丝（freeplus）（￥150）"><a href="#1-洗面奶-芙丽芳丝（freeplus）（￥150）" class="headerlink" title="1.洗面奶 芙丽芳丝（freeplus）（￥150）"></a>1.洗面奶 芙丽芳丝（freeplus）（￥150）</h4><blockquote><p>氨基酸洗面奶，以温和无刺激著称。也刚好适合油痘肌使用。主打就是温和、无添加、低刺激，敏感肌用会很好，温和舒适 很舒服</p></blockquote><p>官网：<a href="https://www.freeplus.cn/freeplus/products/skincare05/" target="_blank" rel="noopener">https://www.freeplus.cn/freeplus/products/skincare05/</a></p><p><img src="/img/life/sk-ll/freeplus.jpg" srcset="/img/loading.gif" alt="freeplus"></p><h3 id="2-爽肤水-护肤精华露-SK-ll神仙水-（￥1540）"><a href="#2-爽肤水-护肤精华露-SK-ll神仙水-（￥1540）" class="headerlink" title="2.爽肤水/护肤精华露 SK-ll神仙水 （￥1540）"></a>2.爽肤水/护肤精华露 SK-ll神仙水 （￥1540）</h3><blockquote><p>SK-II 护肤精华露（神仙水®）改变你的肌肤，令肌肤变得晶莹剔透，嫩滑、紧致、焕发动人光彩。35 年来始终如一。备受瞩目、畅销全球的 SK-II 护肤精华露（神仙水®）蕴含超过90%的天然生物成分PITERA™，集维生素、矿物质和氨基酸等多种微量营养素于一身。</p></blockquote><p>官网：<a href="https://www.skii.com.cn/sc/product-detail.aspx?name=facial-treatment-essence&amp;from=bestsellers" target="_blank" rel="noopener">https://www.skii.com.cn/sc/product-detail.aspx?name=facial-treatment-essence&amp;from=bestsellers</a></p><p><img src="/img/life/sk-ll/sk-ll.jpg" srcset="/img/loading.gif" alt="sk-ll"></p><h3 id="3-眼霜-雅诗兰黛小棕瓶（￥510）"><a href="#3-眼霜-雅诗兰黛小棕瓶（￥510）" class="headerlink" title="3.眼霜 雅诗兰黛小棕瓶（￥510）"></a>3.眼霜 雅诗兰黛小棕瓶（￥510）</h3><blockquote><p>刷屏不怕黑眼圈 水·亮·弹·嫩</p><p>雅诗兰黛发现：电子屏里的蓝光伤害无处不在，打乱肌肤夜间自我修护。现代人过度刷屏，更长时间暴露在蓝光伤害下，让眼周加速老化，多重眼部问题提前出现。全新小棕瓶“熬夜”眼霜，升级浓缩修护科技<em>。唤启并放大眼周自我修护力。<br>•淡黑眼圈</em> · 透亮<br>•有效抗氧* · 匀净<br>•长效保湿* · 水嫩蓝光不再怕，黑眼圈、干纹、细纹一一挥别双眸水亮弹嫩，任性刷屏，刷新年轻！</p></blockquote><p>官网：<a href="https://www.esteelauder.com.cn/product/685/55125/product-catalog/advanced-night-repair" target="_blank" rel="noopener">https://www.esteelauder.com.cn/product/685/55125/product-catalog/advanced-night-repair</a></p><p><img src="/img/life/sk-ll/estee-lauder.png" srcset="/img/loading.gif" alt="Estee Lauder-1"></p><h3 id="4-祛痘-朵呼吸凝胶-（￥79）"><a href="#4-祛痘-朵呼吸凝胶-（￥79）" class="headerlink" title="4.祛痘 朵呼吸凝胶 （￥79）"></a>4.祛痘 朵呼吸凝胶 （￥79）</h3><p>官网：<a href="http://dhxnj.cn/" target="_blank" rel="noopener">http://dhxnj.cn/</a></p><p><img src="/img/life/sk-ll/duohuxi.jpg" srcset="/img/loading.gif" alt="duohuxi"></p><h3 id="5-精华-兰蔻小黑瓶-50ml（￥1080）"><a href="#5-精华-兰蔻小黑瓶-50ml（￥1080）" class="headerlink" title="5.精华 兰蔻小黑瓶 50ml（￥1080）"></a>5.精华 兰蔻小黑瓶 50ml（￥1080）</h3><p>官网：<a href="https://www.lancome.com.cn/item/LAN00352-017" target="_blank" rel="noopener">https://www.lancome.com.cn/item/LAN00352-017</a></p><p><img src="/img/life/sk-ll/lancome.jpg" srcset="/img/loading.gif" alt="lancome"></p><h3 id="6-面霜-海蓝之谜60ml（￥2550）"><a href="#6-面霜-海蓝之谜60ml（￥2550）" class="headerlink" title="6.面霜 海蓝之谜60ml（￥2550）"></a>6.面霜 海蓝之谜60ml（￥2550）</h3><blockquote><p>丰盈质地，经典奢华。柔嫩润泽，修护滋养，由内而外焕现健康光采。品牌灵魂成分，修护秘方－神奇活性精萃 Miracle Broth™, 融入每一次奢华体验, 可为肌肤注入源自海洋的焕新能量。适合各种肤质。</p></blockquote><p>官网：<a href="https://www.lamer.com.cn/product/24367/12343/creme-de-la-mer/creme-de-la-mer#/sku/26766" target="_blank" rel="noopener">https://www.lamer.com.cn/product/24367/12343/creme-de-la-mer/creme-de-la-mer#/sku/26766</a></p><p><img src="/img/life/sk-ll/lamer.png" srcset="/img/loading.gif" alt="lamer"></p><h3 id="7-防嗮-安热沙60ml-（￥238）"><a href="#7-防嗮-安热沙60ml-（￥238）" class="headerlink" title="7.防嗮 安热沙60ml （￥238）"></a>7.防嗮 安热沙60ml （￥238）</h3><p>官网：<a href="http://www.anessa.cn/products/suncare/perfect_uv_ab/" target="_blank" rel="noopener">http://www.anessa.cn/products/suncare/perfect_uv_ab/</a></p><p><img src="/img/life/sk-ll/anessa.png" srcset="/img/loading.gif" alt="anessa"></p><h3 id="8-隔离-兰芝隔离-（￥245）"><a href="#8-隔离-兰芝隔离-（￥245）" class="headerlink" title="8.隔离 兰芝隔离 （￥245）"></a>8.隔离 兰芝隔离 （￥245）</h3><blockquote><ol><li>修正肤色</li></ol><p>雪纱系列特有的雪纱遮瑕配方，快速修正泛黄、泛红肤色，同时提升肤色，让妆容持久透亮。呈现自然裸透肤色</p><ol start="2"><li>搭配粉底液 打造无瑕肌肤</li></ol><p>轻质粉末质地，即使多次涂抹，也不会结块，呈现洁净妆容。</p><ol start="3"><li>如雪纱般轻柔的肌肤</li></ol><p>使用柔软质感的柔软奶油质地（Soft Creamy Texture），呈现如同覆盖了雪纱般的柔软肌理</p></blockquote><p>官网：<a href="http://www.laneige.com.cn/product/skincare/category/cc_base/index.html" target="_blank" rel="noopener">http://www.laneige.com.cn/product/skincare/category/cc_base/index.html</a></p><p><img src="/img/life/sk-ll/laneige.png" srcset="/img/loading.gif" alt="laneige"></p><h3 id="9-散粉-纪梵希四宫格（￥550）"><a href="#9-散粉-纪梵希四宫格（￥550）" class="headerlink" title="9.散粉 纪梵希四宫格（￥550）"></a>9.散粉 纪梵希四宫格（￥550）</h3><blockquote><p>纪梵希明星四色散粉，轻盈如羽，通透如光！<br>超声波震动雾化技术创造出细腻轻盈的粉妆。<br>自然定妆，均匀肤色，同时提升肌肤的自然光泽。<br>4色调合，为不同肤色量身定制色彩搭配，增加肌肤自然光采。<br>包装更奢华制作了仿皮质纹理效果的顶盖配合烫银4G logo，打造纪梵希高定彩妆形象。质地轻盈柔滑的质地，妆效清透</p></blockquote><ul><li>仿若无物，保持肌肤舒适感</li><li>为不同肤色定制，自然提亮</li><li>精致妆效，长效定妆</li></ul><p>官网：<a href="https://www.givenchybeauty.cn/p/纪梵希明星四宫格散粉-F20100045.html?dwvar_F20100045_color=MULTICOLOR-1" target="_blank" rel="noopener">https://www.givenchybeauty.cn/p/%E7%BA%AA%E6%A2%B5%E5%B8%8C%E6%98%8E%E6%98%9F%E5%9B%9B%E5%AE%AB%E6%A0%BC%E6%95%A3%E7%B2%89-F20100045.html?dwvar_F20100045_color=MULTICOLOR-1</a></p><p><img src="/img/life/sk-ll/givenchy.png" srcset="/img/loading.gif" alt="givenchy"></p><h3 id="10-口红-迪奥999-（￥320-）"><a href="#10-口红-迪奥999-（￥320-）" class="headerlink" title="10.口红 迪奥999 （￥320 ）"></a>10.口红 迪奥999 （￥320 ）</h3><blockquote><p>高订色彩，缎光妆效，Dior迪奥烈艳蓝金唇膏持色舒适配方，为女性带来美妙的享受。</p><p>经典红色系、热烈珊瑚红、热情欢乐的粉色系、浪漫迷人的紫红，以及一系列前卫色彩，呈献唇妆惊喜。</p><p>这款唇膏暗藏玄机的迪奥全新金属外壳具有非凡吸引力：为了彰显一抹个性奢华魅力，唇膏盖内皆以Dior迪奥的经典迷人色彩——#传奇红唇（#999）的色彩装点。</p></blockquote><p>官网：</p><p><a href="https://www.dior.cn/zh_cn/products/beauty-Y0038009-全新dior迪奥烈艳蓝金挚红唇膏?objectID=Y0038009&query=口红999&queryID=d24efcd2fe2cac1b651f48eefb1c3776" target="_blank" rel="noopener">https://www.dior.cn/zh_cn/products/beauty-Y0038009-%E5%85%A8%E6%96%B0dior%E8%BF%AA%E5%A5%A5%E7%83%88%E8%89%B3%E8%93%9D%E9%87%91%E6%8C%9A%E7%BA%A2%E5%94%87%E8%86%8F?objectID=Y0038009&amp;query=%E5%8F%A3%E7%BA%A2999&amp;queryID=d24efcd2fe2cac1b651f48eefb1c3776</a></p><p><img src="/img/life/sk-ll/dior999.png" srcset="/img/loading.gif" alt="dior999"></p><h3 id="11-眉笔-爱丽小屋-（￥19）"><a href="#11-眉笔-爱丽小屋-（￥19）" class="headerlink" title="11.眉笔 爱丽小屋 （￥19）"></a>11.眉笔 爱丽小屋 （￥19）</h3><h3 id="12-眼线笔-kissme-（￥89）"><a href="#12-眼线笔-kissme-（￥89）" class="headerlink" title="12.眼线笔 kissme （￥89）"></a>12.眼线笔 kissme （￥89）</h3><h3 id="13-香水-香奈儿N5-50ml-（￥1060）"><a href="#13-香水-香奈儿N5-50ml-（￥1060）" class="headerlink" title="13.香水 香奈儿N5 50ml （￥1060）"></a>13.香水 香奈儿N5 50ml （￥1060）</h3><blockquote><p>N°5五号香水，彰显十足女性魅力。极简线条的经典瓶身，一捧感性优雅的抽象花束，一款经典永恒的香水。<br>嗅觉氛围<br>开瓶的柑橘香调，轻快地引出由五月玫瑰与格拉斯茉莉所组成的芬芳花束，香草的柔软触感，延续香水的感性魅力。<br>创作灵感<br>1921年，嘉柏丽尔·香奈儿与调香师恩尼斯·鲍合作，创造出“一款闻起来像女人的香水”。香奈儿女士从创作的香水配方中选择了第5号香水样本，并保留这个数字作为香水的名称。她为这瓶全新香水挑选了一个简洁的瓶身，饰以白色标签与钻石刻面瓶盖。<br>1986年，贾克·波巨传承恩尼斯·鲍经典创作N°5的嗅觉氛围，重新演绎，推出层次更丰富的五号香水。<br>香氛艺术<br>喷式香水能随心地使用于皮肤或衣服内侧。</p></blockquote><p>官网：<a href="https://www.chanel.cn/zh_CN/fragrance-beauty/fragrance/p/women/n_5/n_5-eau-de-parfum-spray-p125420.html#skuid-0125430" target="_blank" rel="noopener">https://www.chanel.cn/zh_CN/fragrance-beauty/fragrance/p/women/n_5/n_5-eau-de-parfum-spray-p125420.html#skuid-0125430</a></p><p><img src="/img/life/sk-ll/chanel.jpg" srcset="/img/loading.gif" alt="chanel"></p><h3 id="14-卸妆水-贝德玛卸妆水-（￥120）"><a href="#14-卸妆水-贝德玛卸妆水-（￥120）" class="headerlink" title="14.卸妆水 贝德玛卸妆水 （￥120）"></a>14.卸妆水 贝德玛卸妆水 （￥120）</h3><blockquote><p>贝德玛卸妆水由法国崭新科技 MICELLE 配方组成 , 内含水溶及油溶份子可全面洗净肌肤毛孔内外污垢，再加上青瓜植物精华，用後绝不绷紧。成份简单，不含香料，敏感肌肤亦可使用．专利 MICELLE 洁肤配方「 BIODERMA 洁肤水」的 Micelle 溶妆粒子，特有水溶及油溶份子，可溶解面上及毛孔内的的污垢。 Feel 得到的毛孔乾净 天然青瓜植物精华赶走洁面後的绷绷紧。水般的清爽质感 如水般的清爽质感，没有一般洁肤油或 GEL 那种笠黏黏感觉。通过水洁肤程序讲 BYE BYE 只需倒适量在洁肤棉上後，往面部轻轻一抹，污垢立即变走，无须再过水。</p></blockquote><p>官网：<a href="https://www.bioderma.net.cn/series/sensibio/h2o.html" target="_blank" rel="noopener">https://www.bioderma.net.cn/series/sensibio/h2o.html</a></p><p><img src="/img/life/sk-ll/bioderma.png" srcset="/img/loading.gif" alt="bioderma"></p><h3 id="15-使用方式"><a href="#15-使用方式" class="headerlink" title="15.使用方式"></a>15.使用方式</h3><h4 id="1-洗面奶"><a href="#1-洗面奶" class="headerlink" title="1.洗面奶"></a>1.洗面奶</h4><p>1.洗脸前将脸部打湿，将本品加水在掌心打出丰富泡沫，然后把泡沫清洁脸部<br>2.以清水或温水彻底冲净<br>3.耗量：早晚用约40天</p><h4 id="2-清莹露"><a href="#2-清莹露" class="headerlink" title="2.清莹露"></a>2.清莹露</h4><p>用化妆棉浸透化妝水，然后擦拭T区、从中间向外擦拭U区，最后擦拭头部。（眼周肌肤一带而过），每次用量为一元硬币大小。</p><h4 id="3-神仙水"><a href="#3-神仙水" class="headerlink" title="3.神仙水"></a>3.神仙水</h4><p>步骤1：在手掌上滴上3-5滴精华露。然后将两只手压在一起，让双手手掌变湿润；<br>步骤2：轻拍您的脸部。重复步骤1和步骤2两到三遍；<br>步骤3：继续轻拍精华液，直到精华液全部吸收为止。<br>小贴士：记住哦，颈部也要和脸部一样多加关注呢，最重要的就是轻拍的动作，对面部施加轻柔的压力能够更好促进吸收，所以要轻拍、轻拍、再轻拍！坚持早晚使用神仙水才会有更好的效果哦！ </p><h4 id="4-面霜"><a href="#4-面霜" class="headerlink" title="4.面霜"></a>4.面霜</h4><p>取約黄豆粒大小乳霜于掌心，五点式均匀涂抹于面部，轻轻地全面向外涂开</p><h4 id="5-眼霜"><a href="#5-眼霜" class="headerlink" title="5.眼霜"></a>5.眼霜</h4><ul><li>以无名指取适量眼霜，按上出下入的方法，从眼角到眼尾涂抹开；</li><li>手指将眼角纹撑开，并用无名指在在皱纹处轻轻打圈；</li><li>将眼霜放在手掌根部，用掌根对错，焐热。再以掌根部轻轻按压，舒缓眼部并帮助吸收。</li></ul>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>护肤</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的枚举</title>
    <link href="/2020/05/06/ts/enum/"/>
    <url>/2020/05/06/ts/enum/</url>
    
    <content type="html"><![CDATA[<h3 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1.枚举"></a>1.枚举</h3><blockquote><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。</p></blockquote><h3 id="2-数字枚举"><a href="#2-数字枚举" class="headerlink" title="2.数字枚举"></a>2.数字枚举</h3><pre><code class="ts">enum Direction {    Up = 1,    Down,    Left,    Right}</code></pre><p>定义了一个数字枚举， <code>Up</code>使用初始化为 <code>1</code>。 其余的成员会从 <code>1</code>开始自动增长。 换句话说， <code>Direction.Up</code>的值为 <code>1</code>， <code>Down</code>为 <code>2</code>， <code>Left</code>为 <code>3</code>， <code>Right</code>为 <code>4</code>。</p><p>不使用初始化器<code>Up</code>的值为 <code>0</code>， <code>Down</code>的值为<code>1</code></p><h3 id="3-字符串枚举"><a href="#3-字符串枚举" class="headerlink" title="3.字符串枚举"></a>3.字符串枚举</h3><blockquote><p>字符串枚举的概念很简单，但是有细微的 <a href="https://www.tslang.cn/docs/handbook/enums.html#enums-at-runtime" target="_blank" rel="noopener">运行时的差别</a>。 在一个字符串枚举里，每个成员都必须用<code>字符串字面量</code>，或另外一个字符串枚举成员进行初始化。</p></blockquote><pre><code class="ts">enum Direction {    Up = &quot;UP&quot;,    Down = &quot;DOWN&quot;,    Left = &quot;LEFT&quot;,    Right = &quot;RIGHT&quot;,}</code></pre><p>字符串枚举没有自增长的行为</p><h3 id="4-异构枚举"><a href="#4-异构枚举" class="headerlink" title="4.异构枚举"></a>4.异构枚举</h3><pre><code class="ts">enum BooleanLikeHeterogeneousEnum {    No = 0,    Yes = &quot;YES&quot;,}</code></pre><p>从技术的角度来说，枚举可以混合字符串和数字成员，但并不推荐这么做。</p><h3 id="5-计算的和常量成员"><a href="#5-计算的和常量成员" class="headerlink" title="5.计算的和常量成员"></a>5.计算的和常量成员</h3><blockquote><p>每个枚举成员都带有一个值，它可以是 <code>常量</code>或 <code>计算</code>出来的。 当满足如下条件时，枚举成员被当作是常量：</p></blockquote><ul><li><p>它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 <code>0</code></p><pre><code class="ts">// Direction.Up is constant: 0enum Direction { Up }</code></pre></li><li><p>它不带有初始化器且它之前的枚举成员是一个 <em>数字</em>常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加1。</p><pre><code class="ts">enum Direction {    Up = 1,    Down,    Left,    Right}</code></pre></li><li><p>枚举成员使用 <code>常量枚举表达式</code>初始化。 常量枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：</p><ul><li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li><li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li><li>带括号的常量枚举表达式</li><li>一元运算符 <code>+</code>, <code>-</code>, <code>~</code>其中之一应用在了常量枚举表达式</li><li>常量枚举表达式做为二元运算符 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>的操作对象。 若常数枚举表达式求值后为 <code>NaN</code>或 <code>Infinity</code>，则会在编译阶段报错。</li></ul><pre><code class="ts">enum FileAccess {    // constant members    None,    Read    = 1 &lt;&lt; 1,    Write   = 1 &lt;&lt; 2,    ReadWrite  = Read | Write,    // computed member    G = &quot;123&quot;.length}</code></pre></li></ul><h3 id="6-反向映射"><a href="#6-反向映射" class="headerlink" title="6.反向映射"></a>6.反向映射</h3><blockquote><p>除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了 <em>反向映射</em>，从枚举值到枚举名字。 例如，在下面的例子中：</p></blockquote><pre><code class="TS">  enum Enum {      A  }  let a = Enum.A;  let nameOfA = Enum[a]; // &quot;A&quot;</code></pre><p>  要注意的是<em>不会</em>为字符串枚举成员生成反向映射。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的装饰器</title>
    <link href="/2020/05/05/ts/decorator/"/>
    <url>/2020/05/05/ts/decorator/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是装饰器"><a href="#1-什么是装饰器" class="headerlink" title="1.什么是装饰器"></a>1.什么是装饰器</h3><p>装饰器是一种特殊类型的声明，它能够被附加到类，方法，属性或参数上，可以修改类的行为。<br>通俗的讲装饰器就是一个方法，可以注入到类，方法，属性参数上来拓展类，属性，方法，参数的功能。<br>常见的装饰器：</p><ul><li>类装饰器     </li><li>属性装饰器   </li><li>方法装饰器   </li><li>参数装饰器</li></ul><p>装饰器的写法：</p><ul><li>普通装饰器（无法传参）       </li><li>装饰器工厂（可传参）</li></ul><h3 id="2-类装饰器"><a href="#2-类装饰器" class="headerlink" title="2.类装饰器"></a>2.类装饰器</h3><blockquote><p>类装饰器—-普通装饰器(无法传参)</p></blockquote><pre><code class="ts">function logClass(params: any) {    console.log(params) //当前类    //TODO ① 拓展-属性    params.prototype.apiUrl = &#39;https://www.bilibili.com/video/av38379328/?p=19&#39;;    // TODO ② 拓展-方法    params.prototype.get = function(){        console.log(&#39;我是拓展的方法&#39; + this.apiUrl);    }}@logClassclass HttpClient {    constructor() {    }    getData() {    }}let http: any = new HttpClient();//TODO ① 访问拓展的属性console.log(http.apiUrl); //https://www.bilibili.com/video/av38379328/?p=19//TODO ② 访问拓展的方法http.get(); // 我是拓展的方法https://www.bilibili.com/video/av38379328/?p=19</code></pre><blockquote><p>类装饰器—-装饰器工厂(可传参)—返回一个函数</p></blockquote><pre><code class="ts">function logClass(params: string) {    return function (target: any) {        console.log(params) // 传入的参数 https://www.bilibili.com/video/av38379328/?p=19        console.log(target) // 当前类        // 拓展 apiUrl 属性，其值为传入的 params;        target.prototype.apiUrl = params;    }}@logClass(&#39;https://www.bilibili.com/video/av38379328/?p=19&#39;)class HttpClient {    constructor() {    }    getData() {    }}let http: any = new HttpClient();console.log(&#39;使用装饰器工厂拓展的属性&#39;, http.apiUrl); //使用装饰器工厂拓展的属性 https://www.bilibili.com/video/av38379328/?p=19</code></pre><blockquote><p>类装饰器-重载构造函数的例子—返回一个继承于当前类的子类</p></blockquote><pre><code class="ts">// 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。// 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。function logClass(target: any) {    console.log(target) // target 当前类    return class extends target {        // TODO ① 重载apiUrl的值        apiUrl = &#39;我是修改后的数据  https://www.bilibili.com/video/av38379328/?p=19&#39;;        // TODO ② HttpClient类里面的方法被重载了        getData() {            this.apiUrl += &#39;---&#39;;            console.log(this.apiUrl)        }    }}@logClassclass HttpClient {    public apiUrl: string | undefined;    constructor() {        // TODO ① 初始化apiUrl的值        this.apiUrl = &quot;我是constructor里面的apiUrl&quot;;    }    // TODO ② HttpClient类里面的方法    getData() {        console.log(this.apiUrl);    }}let http: any = new HttpClient();http.getData(); // 我是修改后的数据  https://www.bilibili.com/video/av38379328/?p=19---</code></pre><h3 id="3-属性装饰器"><a href="#3-属性装饰器" class="headerlink" title="3.属性装饰器"></a>3.属性装饰器</h3><p>属性装饰器表达式会在运行时当作函数被调用，传入2个参数<br>1.对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。<br>2.成员的名称。</p><pre><code class="ts">// 1.实例成员function logProperty(params: string) {    return function (target: any, attrName: string) {        console.log(params); // http://www.baidu.com        console.log(target); // TODO ① HttpClient 这个类的原型对象（即:HttpClient.prototype）  HttpClient { getData: [Function] }        console.log(attrName) //apiUrl        target[attrName] = params;    }}class HttpClient {    @logProperty(&#39;http://www.baidu.com&#39;)    public apiUrl: string | undefined; //TODO ① 这里声明为实例属性    constructor() {    }    getData() {        console.log(this.apiUrl);    }}let http: any = new HttpClient();http.getData(); // http://www.baidu.com</code></pre><pre><code class="ts">//2.静态成员function logProperty(params: string) {    return function (target: any, attrName: string) {        console.log(params); // http://www.baidu.com/2        console.log(target);// TODO ② HttpClient 这个类  [Function: HttpClient]        console.log(attrName) //apiUrl2        target[attrName] = params; //由于是静态属性 这里就直接把params 挂到类上    }}class HttpClient {    @logProperty(&#39;http://www.baidu.com/2&#39;)    static apiUrl2: string | undefined; //TODO ② 这里声明为静态成员    constructor() {    }    getData() {        console.log(HttpClient.apiUrl2); // 静态属性通过 HttpClient.属性名 来访问    }}let http: any = new HttpClient();http.getData(); // http://www.baidu.com/2</code></pre><h3 id="4-方法装饰器"><a href="#4-方法装饰器" class="headerlink" title="4.方法装饰器"></a>4.方法装饰器</h3><p>它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。<br>方法装饰器表达式会在运行时当作函数被调用，传入3个参数<br>1.对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。<br>2.成员的名称。<br>3.成员的属性描述符。</p><pre><code class="ts">//这里只演示：实例成员function logFunc(params: string) {    return function (target: any, funcName: string, desc: any) {        console.log(params); // http://www.jd.com        console.log(target); // HttpClient.prototype        console.log(funcName); // getData        console.log(desc);        /*            {                 value: [Function],                writable: true,                enumerable: true,                configurable: true             }        */        // 修改装饰的方法（操作desc.value） 把装饰器方法里面传入的参数全部修改为string类型。        // 1.保存当前方法        let oldFunc = desc.value;        // 2.重写 desc.value        desc.value = function (...args: any[]) {            console.log(args); // [123, &#39;456&#39;]            // 3.转换为String            args = args.map(value =&gt; {                return String(value);            })            console.log(args); // [ &#39;123&#39;, &#39;456&#39; ]            // 4.选择替换该方法还是给方法增加功能            oldFunc.apply(this, args); // 加上这个就会执行HttpClient 类里面的getData 方法。            // 不加 就是把【HttpClient 类里面的getData 方法】给替换了。        }    }}class HttpClient {    apiUrl: string | undefined;    constructor() {    }    @logFunc(&#39;http://www.jd.com&#39;)    getData(...args: any[]) {        console.log(args); // 经过装饰器的修改，这里全部被转为了String类型 [ &#39;123&#39;, &#39;456&#39; ]        console.log(&#39;我是getData&#39;);    }}let http: any = new HttpClient();http.getData(123, &#39;456&#39;);</code></pre><h3 id="5-方法参数装饰器（不常用）"><a href="#5-方法参数装饰器（不常用）" class="headerlink" title="5.方法参数装饰器（不常用）"></a>5.方法参数装饰器（不常用）</h3><p>参数装饰器表达式会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元数据，传入3个参数<br>1.对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。<br>2.方法的名称。<br>3.参数在函数参数列表中的索引。</p><pre><code class="ts">function logParams(params: string) {    return function (target: any, funcName: string, paramsIndex: number) {        console.log(params) // name         id        console.log(target) // HttpClient.prototype        console.log(funcName) // getData        console.log(paramsIndex) // 1       0    }}class HttpClient {    url: any | undefined;    constructor() {    }    getData(        @logParams(&#39;id&#39;) id: number, //后执行        @logParams(&#39;name&#39;) name: string // 先执行    ) {    }}</code></pre><h3 id="6-执行顺序"><a href="#6-执行顺序" class="headerlink" title="6.执行顺序"></a>6.执行顺序</h3><blockquote><p>属性装饰器—&gt;方法装饰器—&gt;方法参数装饰器—&gt;类装饰器<br>如果有多个同样的装饰器都是 从后到前执行</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的泛型</title>
    <link href="/2020/05/04/ts/generics/"/>
    <url>/2020/05/04/ts/generics/</url>
    
    <content type="html"><![CDATA[<h3 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h3><p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。<br>组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。<br>通俗理解：泛型就是解决 类，接口，函数的复用性，以及对不特定的数据类型的支持。</p><h3 id="2-泛型函数"><a href="#2-泛型函数" class="headerlink" title="2.泛型函数"></a>2.泛型函数</h3><pre><code class="ts">function getData&lt;T&gt;(str: T): T {    return str;}let str = getData&lt;string&gt;(&#39;aaa&#39;);console.log(str);let str2 = getData&lt;number&gt;(123);console.log(str2);let str3 = getData&lt;number | string&gt;(&quot;123&quot;);console.log(str3);</code></pre><h3 id="3-泛型类"><a href="#3-泛型类" class="headerlink" title="3.泛型类"></a>3.泛型类</h3><pre><code class="ts">class MinClass&lt;T&gt; {    list: Array&lt;T&gt; = [];    add(num: T):void {        this.list.push(num);    }    min(): T {        let minVal = this.list[0];        for (let i = 0; i &lt; this.list.length; i++) {            if (minVal &gt; this.list[i]) {                minVal = this.list[i];            }        }        return minVal;    }}let num = new MinClass&lt;number&gt;();num.add(3);num.add(1);num.add(2);console.log(num.min()) //1let str = new MinClass&lt;string&gt;();str.add(&#39;y&#39;);str.add(&#39;x&#39;);str.add(&#39;w&#39;);console.log(str.min()) //w</code></pre><h3 id="4-泛型接口"><a href="#4-泛型接口" class="headerlink" title="4.泛型接口"></a>4.泛型接口</h3><pre><code class="ts">// 泛型接口 写法1interface IConfigFn {    &lt;T&gt;(value: T): T;}let fs: IConfigFn = function &lt;T&gt;(value: T): T {    return value;}let newFs = fs&lt;number&gt;(123);console.log(newFs); // 123// 泛型接口 写法2interface IConfigFn2&lt;T&gt; {    (value: T): T;}function getData&lt;T&gt;(vlaue: T): T {    return vlaue;}let getMyData: IConfigFn2&lt;boolean&gt; = getData;console.log(getMyData(false)); //false</code></pre><pre><code class="ts">interface IConfigFn {    &lt;T&gt;(value: T): T;}let fs: IConfigFn = function &lt;T&gt;(value: T): T {    return value;}console.log(fs&lt;number&gt;(123));interface IConfigFn2&lt;T&gt; {    (value: T): T;}function getData&lt;T&gt;(value: T): T {    return value;}let fs2: IConfigFn2&lt;number[]&gt; = getData;let fs3: IConfigFn2&lt;Array&lt;string&gt;&gt; = getData;console.log(fs2([1, 2, 3]));console.log(fs3([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]));</code></pre><h3 id="5-把类作为参数类型的泛型类"><a href="#5-把类作为参数类型的泛型类" class="headerlink" title="5.把类作为参数类型的泛型类"></a>5.把类作为参数类型的泛型类</h3><pre><code class="ts">// 把类作为参数来约束数据传入的类型class User {    username: string | undefined;    password: string | undefined;}class ActicleCate {    title: string | undefined;    desc: string | undefined;    constructor(params: {        title: string,        desc: string    }) {        this.title = params.title;        this.desc = params.desc;    }}class MySql&lt;T&gt;{    add(value: T): boolean {        console.log(value);        return true;    }}let db = new MySql&lt;User&gt;();db.add({    username: &#39;aaa&#39;,    password: &#39;123456&#39;});let aDb = new MySql&lt;ActicleCate&gt;();let arcticle = new ActicleCate({    title: &#39;今天好天气&#39;,    desc: &#39;25度，确实可以&#39;});aDb.add(arcticle);</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的模块和命名空间</title>
    <link href="/2020/05/03/ts/namespace/"/>
    <url>/2020/05/03/ts/namespace/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模块的概念"><a href="#1-模块的概念" class="headerlink" title="1.模块的概念"></a>1.模块的概念</h3><p>我们可以把一些公共的功能单独抽离成一个文件作为模块。<br>模块里面的变量，函数，类等默认是私有的，如果我们要在外部访问模块里面的（变量，函数，类），我们需要通过export 暴露出模块里面的（变量，函数，类）。暴露后我们通过 import 引入模块中的（变量，函数，类），这样就可以使用了。</p><pre><code class="ts">// db.tslet dbUrl = &#39;xxxxx&#39;;export function getData:any[]{    console.log(&#39;获取数据&#39;);    return [        {            title:&#39;123&#39;,            name:&#39;哈哈哈哈&#39;,        }    ]}//另一种暴露方式export {    dbUrl,    getData}// export default 默认导出，每个模块都可以有一个default导出，并且每个模块只能有一个default导出。export default getData;//引入的时候 import getData from &#39;./db/; 没有{}了。</code></pre><pre><code class="ts">// index.ts import { getData } from &#39;./db&#39;;getData();// 别名import { getData as get} from &#39;./db&#39;;get();</code></pre><h3 id="2-命名空间和模块的区别"><a href="#2-命名空间和模块的区别" class="headerlink" title="2.命名空间和模块的区别"></a>2.命名空间和模块的区别</h3><ul><li>命名空间：内部模块，主要用于组织代码，避免命名冲突。</li><li>模块：ts的外部模块的简称，侧重代码的复用，一个模块里可以有多个命名空间。</li></ul><pre><code class="ts">// 暴露命名空间Aexport namespace A{    export function getData:any[]{        console.log(&#39;获取数据&#39;);        return [            {                title:&#39;123&#39;,                name:&#39;哈哈哈哈&#39;,            }        ]    }}// 暴露命名空间Bexport namespace B{    export function getData:any[]{        console.log(&#39;获取数据&#39;);        return [            {                title:&#39;123&#39;,                name:&#39;哈哈哈哈&#39;,            }        ]    }}// 内部使用：A.getData();B.getData();// 外部使用 需要给namespace 也暴露出去</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的接口</title>
    <link href="/2020/05/02/ts/interface/"/>
    <url>/2020/05/02/ts/interface/</url>
    
    <content type="html"><![CDATA[<p>接口的作用：定义标准<br>在面向对象的编程中，接口是一种规范的定义，它定义了行为和动作的规范，在程序设计里面，接口起到了一种限制和规范的作用。接口定义了某一批类所需要遵循的规范，接口不关心这些类的内部状态数据，也不关心这些类里方法的实现细节，它只规定这批类里必须提供某些方法，提供这些方法的类就可以满足实际需要。</p><h3 id="1-属性接口"><a href="#1-属性接口" class="headerlink" title="1.属性接口"></a>1.属性接口</h3><blockquote><p>对json的约束</p></blockquote><pre><code class="ts">interface IObj {    name: string;    age?: number;}function getList(obj: IObj): void {    console.log(obj.name);    console.log(obj.age);}let obj = {    name: &#39;tom&#39;,    age: 22,//可选属性，可传，可不传}getList(obj);</code></pre><pre><code class="ts">interface IObj {    name: string;    age: number;}function getList(obj: IObj): void {    console.log(obj.name);    console.log(obj.age);}//定义在外面 只要包含name，age就可以let obj = {    name: &#39;tom&#39;,    age: 20,    firstName: &#39;t&#39;, //额外的属性}getList(obj);//定义在里面 只能有name，agegetList({    name: &#39;tom&#39;,    age: 20,    firstName: &#39;t&#39;, //错误});//正确getList({    name: &#39;tom&#39;,    age: 20,});</code></pre><h3 id="2-函数接口"><a href="#2-函数接口" class="headerlink" title="2.函数接口"></a>2.函数接口</h3><blockquote><p>对函数传入的参数和返回值进行约束</p></blockquote><pre><code class="ts">interface encrypt {    (key: string, value: string): string;}let md5: encrypt = function (key: string, value: string): string {    return key + &#39;--md5-&#39; + value;};let sha1: encrypt = function (key: string, value: string): string {    return key + &#39;--sha1-&#39; + value;};console.log(md5(&#39;name&#39;, &#39;数学&#39;));console.log(sha1(&#39;name&#39;, &#39;历史&#39;));</code></pre><h3 id="3-可索引接口"><a href="#3-可索引接口" class="headerlink" title="3.可索引接口"></a>3.可索引接口</h3><blockquote><p>对数组、对象的约束（不常用）</p></blockquote><pre><code class="ts">//对 数组的约束interface userArray {    [index: number]: string;}let arr: userArray = [&#39;a&#39;, &#39;123&#39;];// 对 对象的约束interface userObj {    [index: string]: string | number;}let obj: userObj = {    name: &#39;张三&#39;,}// 对 数组对象的约束interface userArrayObj {    [index: number]: userObj}let list: userArrayObj = [{    name: &#39;张三&#39;,    age: 20}];</code></pre><h3 id="4-类-类型接口"><a href="#4-类-类型接口" class="headerlink" title="4.类 类型接口"></a>4.类 类型接口</h3><blockquote><p>对类的约束 和抽象类有点相似</p></blockquote><pre><code class="ts">// 类 类型接口  implements 实现接口interface IAnimal {    name: string;    age: number;    eat(str: string): void;    run(value: number): string;}class Dogs implements IAnimal {    name: string;    age: number;    constructor(name: string, age: number) {        this.name = name;        this.age = age;    }    eat(str: string): void {        console.log(str);    }    run(value: number): string {        return &#39;我跑了&#39; + value;    }}</code></pre><h3 id="5-接口扩展（接口可以继承接口）"><a href="#5-接口扩展（接口可以继承接口）" class="headerlink" title="5.接口扩展（接口可以继承接口）"></a>5.接口扩展（接口可以继承接口）</h3><pre><code class="ts">interface IAnimal {    name: string;    age: number;    eat(str: string): void;    run(value: number): string;}interface IPerson extends IAnimal {    cate: string;    print(str: string): void;}class Person implements IPerson {    name: string;    age: number;    cate: string;    constructor(name: string, age: number, cate: string) {        this.name = name;        this.age = age;        this.cate = cate;    }    print(str: string): void {        console.log(str);    }    eat(str: string): void {        console.log(str + &#39;吃饭&#39;)    }    run(value: number): string {        return &#39;我跑了&#39; + value;    }}let s = new Person(&#39;小小&#39;, 20, &#39;人&#39;);console.log(s.run(60));s.eat(&#39;小小&#39;);</code></pre><pre><code class="ts">interface IAnimal {    name: string;    age: number;    eat(str: string): void;    run(value: number): string;}interface IPerson extends IAnimal {    cate: string;    print(str: string): void;}class Person implements IPerson {    name: string;    age: number;    cate: string;    constructor(name: string, age: number, cate: string) {        this.name = name;        this.age = age;        this.cate = cate;    }    print(str: string): void {        console.log(str);    }    eat(str: string): void {        console.log(str + &#39;吃饭&#39;)    }    run(value: number): string {        return &#39;我跑了&#39; + value;    }}// 同时继承类 和 实现接口class Programmer extends Person implements IPerson {    constructor(name: string, age: number, cate: string) {        super(name, age, cate);    }    print(str: string): void {        console.log(str);    }    eat(str: string): void {        console.log(str + &#39;吃饭&#39;)    }    run(value: number): string {        return &#39;我跑了&#39; + value;    }}let s = new Person(&#39;小小&#39;, 20, &#39;人&#39;);console.log(s.run(60));s.eat(&#39;小小&#39;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的类</title>
    <link href="/2020/05/01/ts/class/"/>
    <url>/2020/05/01/ts/class/</url>
    
    <content type="html"><![CDATA[<h3 id="1-class的创建"><a href="#1-class的创建" class="headerlink" title="1.class的创建"></a>1.class的创建</h3><pre><code class="ts">class Person {    name: string;    age: number;    constructor(name: string, age: number) { //构造方法 实例化类的时候触发的方法        this.name = name;        this.age = age;    }    run(): void {        console.log(this.name + &#39;在跑步&#39;);    }    getName(): string {        return this.name;    }    setName(name: string): void {        this.name = name;    }}let p = new Person(&#39;张三&#39;, 30);console.log(p.name); //张三p.run();// 张三在跑步console.log(p.getName());//张三p.setName(&#39;李四&#39;);console.log(p.getName());//李四</code></pre><h3 id="2-TS-类的继承-extends-super"><a href="#2-TS-类的继承-extends-super" class="headerlink" title="2.TS 类的继承 extends + super"></a>2.TS 类的继承 extends + super</h3><pre><code class="ts">class Person {    name: string;    age: number;    constructor(name: string, age: number) {        this.name = name;        this.age = age;    }    run(): void {        console.log(this.name + &#39;在跑步&#39;);    }    getName(): string {        return this.name;    }    setName(name: string): void {        this.name = name;    }}//子类class Student extends Person {    sex: string;    constructor(name: string, age: number, sex: string) {        super(name, age); //初始化父类的构造函数        this.sex = sex;    }    run(): void {        console.log(this.name + &#39;在跑步&#39;);    }    work(): void {        console.log(this.name + &#39;在工作&#39;);    }    print(): string {        return this.name + &#39;-&#39; + this.age + &#39;-&#39; + this.sex;    }}let s = new Student(&#39;李白&#39;, 400, &#39;男&#39;);console.log(s.sex); //男s.run(); //李白在跑步console.log(s.print()); //李白-400-男</code></pre><h3 id="3-类的修饰符-public-默认-private-protected"><a href="#3-类的修饰符-public-默认-private-protected" class="headerlink" title="3.类的修饰符 public(默认)  private   protected"></a>3.类的修饰符 public(默认)  private   protected</h3><table><thead><tr><th>是否可以访问</th><th>描述</th><th>父类</th><th>子类</th><th>类外部</th></tr></thead><tbody><tr><td>public</td><td>公有</td><td>ok</td><td>ok</td><td>ok</td></tr><tr><td>private</td><td>私有</td><td>ok</td><td>no</td><td>no</td></tr><tr><td>protected</td><td>保护类型</td><td>ok</td><td>ok</td><td>no</td></tr></tbody></table><h3 id="4-类的静态属性和静态方法"><a href="#4-类的静态属性和静态方法" class="headerlink" title="4.类的静态属性和静态方法"></a>4.类的静态属性和静态方法</h3><pre><code class="ts">class Person {    name: string;    age: number;    static sex:string = &#39;男&#39;;    constructor(name: string, age: number) {        this.name = name;        this.age = age;    }    run(): void {        console.log(this.name + &#39;在跑步&#39;);    }    static print():void{ //静态方法中无法访问this(即不能访问实例属性和实例方法)        console.log(Person.sex);    }}let p = new Person(&#39;zs&#39;,56);console.log(Person.sex); // 男Person.print(); // 男</code></pre><h3 id="5-多态"><a href="#5-多态" class="headerlink" title="5.多态"></a>5.多态</h3><p>父类定义一个方法不去实现，让继承他的子类去实现，每个子类有不同的表现<br>多态属于继承</p><pre><code class="ts">class Animal {    name: string;    constructor(name: string) {        this.name = name;    }    eat(): void {        console.log(this.name);    }}class Dog extends Animal {    constructor(name: string) {        super(name);    }    eat():void{        console.log(`${this.name} 要吃肉`);    }}class Fish extends Animal {    constructor(name:string){        super(name);    }    eat():void {        console.log(`${this.name} 要吃微生物`);    }}</code></pre><h3 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6.抽象类"></a>6.抽象类</h3><ul><li>是提供其他类继承的基类，不能直接被实例化。</li><li>用abstract关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现，并且必须在派生类中实现。</li><li>抽象方法只能放在抽象类中</li><li>抽象类和抽象方法用来定义标准</li></ul><pre><code class="ts">abstract class Animal {    name:string;    constructor(name:string){        this.name = name;     }    abstract eat(): any; //抽象类中的抽象方法不包含具体实现}/* let a = new Animal(); //错误 不能直接被实例化 */class Dog extends Animal {    constructor(name:string){        super(name);    }    // 抽象类的子类必须实现抽象类的抽象方法    eat(): string {        return this.name + &#39;喜欢吃肉&#39;;    }}let d = new Dog(&#39;小狗&#39;);console.log(d.eat()); //小狗喜欢吃肉</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 使用方法</title>
    <link href="/2020/04/30/git/git/"/>
    <url>/2020/04/30/git/git/</url>
    
    <content type="html"><![CDATA[<h2 id="Git-使用方法"><a href="#Git-使用方法" class="headerlink" title="Git 使用方法"></a>Git 使用方法</h2><h3 id="常用git操作"><a href="#常用git操作" class="headerlink" title="常用git操作"></a>常用git操作</h3><blockquote><pre><code>+ 新建分支并切换到新分支      git checkout -b [branch-name]+ 删除本地分支                git branch -d [branch-name]+ 删除远程分支                git push origin --delete [branch-name]+ 重置暂存区与工作区，与上一次commit保持一致     git reset --hard+ 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset [commit]</code></pre></blockquote><h3 id="1、git工作空间"><a href="#1、git工作空间" class="headerlink" title="1、git工作空间"></a>1、git工作空间</h3><p><img src="/img/git.png" srcset="/img/loading.gif" alt="git"></p><ul><li><p>Workspace: 工作区</p></li><li><p>Index/Stage：暂存区</p></li><li><p>Repository: 仓库区（或本地仓库）</p></li><li><p>Remote：远程仓库</p></li></ul><h3 id="2、新建代码仓库"><a href="#2、新建代码仓库" class="headerlink" title="2、新建代码仓库"></a>2、新建代码仓库</h3><pre><code># 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]</code></pre><h3 id="3、配置git"><a href="#3、配置git" class="headerlink" title="3、配置git"></a>3、配置git</h3><pre><code class="js"># 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h3 id="4、增加-删除文件"><a href="#4、增加-删除文件" class="headerlink" title="4、增加/删除文件"></a>4、增加/删除文件</h3><pre><code class="js"># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .</code></pre><h3 id="5、代码提交"><a href="#5、代码提交" class="headerlink" title="5、代码提交"></a>5、代码提交</h3><pre><code class="js"># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...</code></pre><h3 id="6、分支"><a href="#6、分支" class="headerlink" title="6、分支"></a>6、分支</h3><pre><code class="js"># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h3 id="7、标签"><a href="#7、标签" class="headerlink" title="7、标签"></a>7、标签</h3><pre><code class="js"># 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags</code></pre><h3 id="8、查看信息"><a href="#8、查看信息" class="headerlink" title="8、查看信息"></a>8、查看信息</h3><pre><code class="js"># 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog</code></pre><h3 id="9、远程同步"><a href="#9、远程同步" class="headerlink" title="9、远程同步"></a>9、远程同步</h3><pre><code class="js"># 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all# 更新远程分支列表$ git remote update origin -p</code></pre><h3 id="10、撤销"><a href="#10、撤销" class="headerlink" title="10、撤销"></a>10、撤销</h3><pre><code class="js"># 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop</code></pre><h3 id="11、远程同步Git参考手册"><a href="#11、远程同步Git参考手册" class="headerlink" title="11、远程同步Git参考手册"></a>11、远程同步Git参考手册</h3><p><a href="http://gitref.justjavac.com/index.html" target="_blank" rel="noopener">http://gitref.justjavac.com/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 处理如何优雅的处理复杂判断</title>
    <link href="/2020/04/29/js/if-else/"/>
    <url>/2020/04/29/js/if-else/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本if-else-逻辑判断"><a href="#1-基本if-else-逻辑判断" class="headerlink" title="1.基本if else 逻辑判断"></a>1.基本if else 逻辑判断</h3><pre><code class="js">let sex = 1;let sexText = &#39;&#39;;if(sex === 1){  sexText = &#39;男&#39;;}else if(sex === 2){  sexText = &#39;女&#39;;}else {  sexText = &#39;其他&#39;;}</code></pre><h3 id="2-switch-case"><a href="#2-switch-case" class="headerlink" title="2.switch/case"></a>2.switch/case</h3><pre><code class="js">const getStatusText = (status) =&gt; { let str = &#39;&#39;;  switch (status) {    case 1:      str=&quot;待开通&quot;;      break;    case 2:      str=&quot;开通准备中&quot;;      break;    case 3:      str=&quot;开通准备完成&quot;;      break;    default:      str=&quot;已过期&quot;;      break; }  return str;}</code></pre><h3 id="3-三元表达式"><a href="#3-三元表达式" class="headerlink" title="3.三元表达式"></a>3.三元表达式</h3><pre><code class="js">let sex = 1;let sexText = sex === 1 ? &#39;男&#39; : sex === 2 ? &#39;女&#39;: &#39;其他&#39;;</code></pre><h3 id="4-短路-amp-amp-与"><a href="#4-短路-amp-amp-与" class="headerlink" title="4.短路 &amp;&amp; 与 ||"></a>4.短路 &amp;&amp; 与 ||</h3><p>&amp;&amp; 中第一个表达式为假就不会去处理第二个表达式，|| 则相反</p><pre><code class="js">// if为真if (bool) { value = getValueTrue();}// &amp;&amp;改版bool &amp;&amp; (value = getValueTrue());// if为假if (!bool) { value = getValueFalse();}// || 改版bool || (value = getValueFalse());</code></pre><h3 id="5-对象-或-数组"><a href="#5-对象-或-数组" class="headerlink" title="5.对象 或 数组"></a>5.对象 或 数组</h3><pre><code class="js">const getStatusText = (status) =&gt; {  let statusObj = {     1: &#39;待开通&#39;,     2: &#39;开通准备中&#39;,     3: &#39;开通准备完成&#39; };  return statusObj[status] ? statusObj[status] : &#39;&#39;;}const getStatus = (status) =&gt; {  let statusArr = [&#39;待开通&#39;,&#39;开通准备中&#39;,&#39;开通准备完成&#39;]  return statusArr[status-1] ? statusArr[status-1] : &#39;&#39;;}</code></pre><h3 id="6-includes"><a href="#6-includes" class="headerlink" title="6.includes"></a>6.includes</h3><pre><code class="js">if (operate === &#39;submitAudit&#39; || operate === &#39;cancelUpdate&#39; || operate === &#39;uplineApplet&#39;) {  this.handleOperate(operate, row);  return;}//使用includesconst actionArr = [&#39;submitAudit&#39;,&#39;cancelUpdate&#39;,&#39;uplineApplet&#39;];if(actionArr.includes(operate)){  this.handleOperate(operate, row);  return;}</code></pre><h3 id="7-Map"><a href="#7-Map" class="headerlink" title="7.Map"></a>7.Map</h3><p>假如：</p><p>‘待开通’ 具有 设置版本setVersion 的操作</p><p>‘开通准备中’ 无操作</p><p>‘开通准备完成’ 具有发布releaseApplet和取消本次开通cancelDredge的操作</p><pre><code class="js">const getStatus = (status) =&gt; {  const maps = new Map([   [1,[&#39;待开通&#39;,[&#39;setVersion&#39;]]],     [2,[&#39;开通准备中&#39;,]],     [3,[&#39;开通准备完成&#39;,[&#39;releaseApplet&#39;,&#39;cancelDredge&#39;]]], ])  const action = maps.get(status);  let obj = {    statusText:&#39;&#39;,    statusFn:[], }  obj.statusText = action[0];//  [&quot;待开通&quot;]  obj.statusFn = action[1] || [];// [&#39;setVersion&#39;]  return obj;}getStatus(2) // { statusText: &quot;开通准备中&quot;,statusFn: [] }</code></pre><h3 id="其他复杂的Map用法可以参看这边文章"><a href="#其他复杂的Map用法可以参看这边文章" class="headerlink" title="其他复杂的Map用法可以参看这边文章"></a>其他复杂的Map用法可以参看这边文章</h3><p><a href="https://segmentfault.com/a/1190000017105791" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017105791</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Taro 采坑指南</title>
    <link href="/2020/03/12/taro/taro/"/>
    <url>/2020/03/12/taro/taro/</url>
    
    <content type="html"><![CDATA[<h3 id="在Taro中如何正确给自定义组件传递样式类"><a href="#在Taro中如何正确给自定义组件传递样式类" class="headerlink" title="在Taro中如何正确给自定义组件传递样式类"></a>在Taro中如何正确给自定义组件传递样式类</h3><p>需要利用 externalClasses 定义段定义若干个外部样式类。这个特性从小程序基础库版本 1.9.90 开始支持。</p><pre><code class="js">/* CustomComp.js */export default class CustomComp extends Component {  static externalClasses = [&#39;my-class&#39;]  render () {    return &lt;View className=&quot;my-class&quot;&gt;这段文本的颜色由组件外的 class 决定&lt;/View&gt;  }}</code></pre><pre><code class="js">/* MyPage.js */export default class MyPage extends Component {  render () {    return &lt;CustomComp my-class=&quot;red-text&quot; /&gt;  }}</code></pre><pre><code class="scss">/* MyPage.scss */.red-text {  color: red;}</code></pre><p>注意：externalClasses 需要使用 短横线命名法 (kebab-case)，而不是 React 惯用的 驼峰命名法 (camelCase)。否则无效。</p><h3 id="父组件的样式类完全影响子组件"><a href="#父组件的样式类完全影响子组件" class="headerlink" title="父组件的样式类完全影响子组件"></a>父组件的样式类完全影响子组件</h3><p>使用外部样式类可以让组件使用指定的组件外样式类，如果希望组件外样式类能够完全影响组件内部，可以将组件构造器中的 options.addGlobalClass 字段置为 true。这个特性从小程序基础库版本 2.2.3 开始支持。</p><pre><code class="js">/* CustomComp.js */export default class CustomComp extends Component {  static options = {    addGlobalClass: true  }  render () {    return &lt;View className=&quot;red-text&quot;&gt;这段文本的颜色由组件外的 class 决定&lt;/View&gt;  }}</code></pre><pre><code class="css">/* 组件外的样式定义 */.red-text {  color: red;}</code></pre><h3 id="在Taro中给子组件传递属性时，不能使用-…-拓展操作符"><a href="#在Taro中给子组件传递属性时，不能使用-…-拓展操作符" class="headerlink" title="在Taro中给子组件传递属性时，不能使用 … 拓展操作符"></a>在Taro中给子组件传递属性时，不能使用 … 拓展操作符</h3><pre><code class="js">const props = {firstName: &#39;Plus&#39;, lastName: &#39;Second&#39;}return &lt;Greeting {...props} /&gt; //错误return &lt;Greeting firstName=&quot;Plus&quot; lastName=&quot;Second&quot; /&gt; //正确</code></pre><h3 id="在Taro中如何阻止事件冒泡"><a href="#在Taro中如何阻止事件冒泡" class="headerlink" title="在Taro中如何阻止事件冒泡"></a>在Taro中如何阻止事件冒泡</h3><p>在 Taro 中你不能使用 <code>catchEvent</code> 的方式阻止事件冒泡。你必须明确的使用 <code>e.stopPropagation</code>。例如，阻止事件冒泡你可以这样写：</p><pre><code class="js">class Toggle extends Component {  constructor (props) {    super(props)    this.state = {isToggleOn: true}  }  onClick = (e) =&gt; {    e.stopPropagation()    this.setState(prevState =&gt; ({      isToggleOn: !prevState.isToggleOn    }))  }  render () {    return (      &lt;button onClick={this.onClick}&gt;        {this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;}      &lt;/button&gt;    )  }}</code></pre><h3 id="Taro中事件处理的传参方式"><a href="#Taro中事件处理的传参方式" class="headerlink" title="Taro中事件处理的传参方式"></a>Taro中事件处理的传参方式</h3><p>1.使用 <code>bind</code> 方式向监听函数传参，在类组件中定义的监听函数，事件对象 <code>e</code> 要排在所传递参数的后面。</p><pre><code class="js">class Popper extends Component {  constructor () {    super(...arguments)    this.state = { name:&#39;Hello world!&#39; }  }  // 你可以通过 bind 传入多个参数  preventPop (name, test, e) {    //事件对象 e 要放在最后    e.stopPropagation()  }  render () {    return &lt;Button onClick={this.preventPop.bind(this, this.state.name, &#39;test&#39;)}&gt;&lt;/Button&gt;  }}</code></pre><p>2.使用<code>匿名函数</code><br>直接写匿名函数不会打乱原有监听函数的参数顺序。<br>注意：在各小程序端，使用匿名函数，尤其是在 <code>循环中</code> 使用匿名函数，比使用 <code>bind</code> 进行事件传参占用更大的内存，速度也会更慢。</p><pre><code class="js">class Popper extends Component {  constructor () {    super(...arguments)    this.state = { name: &#39;Hello world!&#39; }  }  render () {    const name = &#39;test&#39;    return (      &lt;Button onClick={(e) =&gt; {        e.stopPropagation()        this.setState({          name        })      }}&gt;        {this.state.name}      &lt;/Button&gt;    )  }}</code></pre><p>3.<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">柯里化</a></p><pre><code class="js">class Title extends Component{  handleClick = (index) =&gt; (e) =&gt; {    e.stopPropagation()    this.setState({      currentIndex: index    })  }  render() {    const { currentIndex } = this.props;    return (      {/* 调用 `this.handleClick(currentIndex)` 会返回一个函数，这个函数可以访问到 `currentIndex` 同时也能满足 `onClick` 的签名 */}      &lt;View onClick={this.handleClick(currentIndex)}&gt;      &lt;/View&gt;    )  } }</code></pre><p>4.函数式组件传递方式<br>在函数式组件中，事件传参可以传入<code>事件的引用</code>也可以传入<code>匿名函数</code>，以下是函数式组件配合 <code>useCallback</code> 的一个例子：</p><pre><code class="js">const App = () =&gt; {  const [c1, setC1] = useState(0);  const [c2, setC2] = useState(0);  const [c3, setC3] = useState(0);  const increment = c =&gt; c + 1  // 只有 useCallback 对应的 c1 或 c2 的值改变时，才会返回新的函数  const increment1 = useCallback(() =&gt; setC1(increment), [c1]);  const increment2 = useCallback(() =&gt; setC2(increment), [c2]);  return (&lt;View&gt;    &lt;Text&gt; Counter 1 is {c1} &lt;/Text&gt;    &lt;Text&gt; Counter 2 is {c2} &lt;/Text&gt;    &lt;Text&gt; Counter 3 is {c3} &lt;/Text&gt;    &lt;View&gt;      &lt;Button onClick={increment1}&gt;Increment Counter 1&lt;/Button&gt;      &lt;Button onClick={increment2}&gt;Increment Counter 2&lt;/Button&gt;      &lt;Button onClick={() =&gt; setC3(increment)}&gt;Increment Counter 3&lt;/Button&gt;    &lt;/View&gt;  &lt;/View&gt;)}</code></pre><p>5.任何组件的事件传递都要以 <code>on</code> 开头<br>在 v1.3.0-beta.0 之后，自定义组件间的事件传递可以不用 <code>on</code> 开头，但内置组件的事件依然是以 <code>on</code> 开头的，为了一致性我们仍然推荐你以 <code>on</code> 开头命名你的事件。</p><pre><code class="js">const element = &lt;View onClick={this.onTag} /&gt;const element2 = &lt;Input onFocus={this.onFocus} /&gt;const element3 = &lt;CustomElement onAnimationEnd={this.props.onAnimationEnd} /&gt;</code></pre><h3 id="Taro中巧用逻辑运算符-amp-amp-和-三元运算符-以及-枚举-来实现条件渲染"><a href="#Taro中巧用逻辑运算符-amp-amp-和-三元运算符-以及-枚举-来实现条件渲染" class="headerlink" title="Taro中巧用逻辑运算符 &amp;&amp; 和 三元运算符 以及 枚举 来实现条件渲染"></a>Taro中巧用逻辑运算符 &amp;&amp; 和 三元运算符 以及 枚举 来实现条件渲染</h3><pre><code class="js">class LoginStatus extends Component {  render () {    const isLoggedIn = this.props.isLoggedIn    return (      &lt;View&gt;        {isLoggedIn &amp;&amp; &lt;Text&gt;已登录&lt;/Text&gt;}        {!isLoggedIn &amp;&amp; &lt;Text&gt;未登录&lt;/Text&gt;}        {isLoggedIn            ? &lt;Text&gt;已登录&lt;/Text&gt;            : &lt;Text&gt;未登录&lt;/Text&gt;        }      &lt;/View&gt;    )  }}</code></pre><pre><code class="js">function Loading (props) {  const { loadingText, LOADING_STATUS, loadingStatus, onRetry } = props  return (    &lt;View className=&#39;loading-status&#39;&gt;      {        {          &#39;loading&#39;: loadingText,          &#39;fail&#39;: &lt;View onClick={onRetry}&gt; 加载失败, 点击重试 &lt;/View&gt;,          &#39;no-more&#39;: &#39;没有更多了&#39;        }[loadingStatus] /** loadingStatus 是 `loading`、`fail`、`no-more`  其中一种状态 **/      }    &lt;/View&gt;  )}</code></pre><h3 id="Taro中循环渲染-原生小程序组件-需要指定taroKeys"><a href="#Taro中循环渲染-原生小程序组件-需要指定taroKeys" class="headerlink" title="Taro中循环渲染 原生小程序组件 需要指定taroKeys"></a>Taro中循环渲染 原生小程序组件 需要指定taroKeys</h3><p><code>taroKey</code> 适用于循环渲染原生小程序组件，赋予每个元素唯一确定标识，转换为小程序的 <code>wx:key</code>。</p><pre><code class="js">const numbers = [...Array(100).keys()] // [0, 1, 2, ..., 98, 99]const listItems = numbers.map((number) =&gt; {  return (    // native component    &lt;g-list      taroKey={String(number)}      className=&#39;g-list&#39;    &gt;    我是第 {number + 1} 个数字    &lt;/g-list&gt;  )})</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Taro</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6/ES7 常用集锦</title>
    <link href="/2020/03/11/js/es6/"/>
    <url>/2020/03/11/js/es6/</url>
    
    <content type="html"><![CDATA[<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>A.使用Set处理数组去重和删除元素，Set是es6新增的一种数据结构，它和数组非常相似，但是成员的值都是唯一的，没有重复的值。提供4个语义化的API：<br>1.<code>add(value)</code>;添加某个值，返回Set结构本身。<br>2.<code>delete(value)</code>;删除某个值，返回一个布尔值，表示删除是否成功。<br>3.<code>has(value)</code>;返回一个布尔值，表示改值是否为Set的成员。<br>4.<code>clear()</code>;清除所有成员，没有返回值。</p><pre><code class="javascript">let arr= [1,2,3,4,4,5,5,5];let set = new Set(arr);console.log(...set); //1 2 3 4 5</code></pre><p>注意：这个方法对元素为对象的数组不奏效。Set判断元素是否重复的方法类似于<code>===</code>。</p><p>B.删除数组中指定的元素：</p><pre><code class="javascript">const arr = [1,2,3];//例如删除数组中值为2的元素const index = arr.indexOf(2);if(index != -1){    arr.splice(index,1);}console.log(arr); //[1,3]//使用setconst arr = [1,2,3];const set = new Set(arr);set.delete(2);arr = [...set];console.log(arr); //[1,3]</code></pre><p>C.使用<code>map()</code>方法和对象解构语法提取字段</p><pre><code class="javascript">let studentInfo = [    { name: &#39;Alice&#39;, age: 18, no: 2 },    { name: &#39;Bob&#39;, age: 16, no: 5 },    { name: &#39;Candy&#39;, age: 17, no: 3 },    { name: &#39;Den&#39;, age: 18, no: 4 },    { name: &#39;Eve&#39;, age: 16, no: 1 },]const nameList = studentInfo.map(({name}) =&gt; name);console.log(nameList); //[&quot;Alice&quot;, &quot;Bob&quot;, &quot;Candy&quot;, &quot;Den&quot;, &quot;Eve&quot;]</code></pre><p>D.使用<code>filter()</code>方法和对象解构语法过滤字段</p><pre><code class="javascript">let studentInfo = [    { name: &#39;Alice&#39;, age: 18, no: 2 },    { name: &#39;Bob&#39;, age: 16, no: 5 },    { name: &#39;Candy&#39;, age: 17, no: 3 },    { name: &#39;Den&#39;, age: 18, no: 4 },    { name: &#39;Eve&#39;, age: 16, no: 1 },]const newStudentInfo = studentInfo.filter(({age}) =&gt; age&gt;17);console.log(newStudentInfo); //[ { name: &#39;Alice&#39;, age: 18, no: 2 }, { name: &#39;Den&#39;, age: 18, no: 4 }]</code></pre><p>E.数组遍历使用<code>for in</code>,<code>forEach</code>,<code>for of</code></p><pre><code class="javascript">let studentInfo = [    { name: &#39;Alice&#39;, age: 18, no: 2 },    { name: &#39;Bob&#39;, age: 16, no: 5 },    { name: &#39;Candy&#39;, age: 17, no: 3 },    { name: &#39;Den&#39;, age: 18, no: 4 },    { name: &#39;Eve&#39;, age: 16, no: 1 },]for(let i in studentInfo) {    console.log(i);//下标    console.log(studentInfo[i]);}studentInfo.forEach((value,index,arr) =&gt; {    console.log(value);    console.log(index);    console.log(arr);})for(let i of studentInfo) {    console.log(i);//每一项的值 { name: &#39;Alice&#39;, age: 18, no: 2 }}</code></pre><p>F.最短的代码创建一个长度为6，每个值为8的数组</p><pre><code class="javascript">Array(6).fill(8); //[8, 8, 8, 8, 8, 8]</code></pre><p>更多详细参考：<a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">阮一峰大神</a></p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><pre><code class="javascript">//数组解构let [a, b, c] = [4, 5, 6]; //a=4,b=5,c=6//解构不成功其值为undefinedlet [a] = []; //a = undefinedlet [a, b] = [1];//b = undefined//对象解构let { a, b, c} = { b: &quot;aaa&quot;, a: &quot;bbb&quot; };//a = &quot;bbb&quot;//b = &quot;aaa&quot;//c = undefinedlet { a : b } = { a: &quot;aaa&quot;, c: &quot;bbb&quot; };//b = &quot;aaa&quot;//a  error: foo is not defined//a是匹配的模式，b才是变量。真正被赋值的是变量baz，而不是模式foo。//字符串解构const [a, b, c, d, e] = &#39;hello&#39;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot;//函数参数解构function add([a, b]){    return a + b;}add([1, 2]); // 3常见的用途// 1.交换变量的值let x = 1;let y = 2;[x, y] = [y, x];// 2.函数返回值// 返回一个数组function num() {return [1, 2, 3];}let [a, b, c] = num();// 返回一个对象function example() {    return {        a: 1,        b: 2    };}let { a, b } = example();// 3.解析json数据let json = {    id: 1,    status: 404,    data: [123, 456]};let { id, status, data: number } = json;console.log(id, status, number);// 1, 404, [123, 456]</code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>1.模板字符串<br>2.JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。<br>    1.<code>includes(target,[index])</code>：返回布尔值，表示是否找到了参数字符串。<br>    2.<code>startsWith(target,[index])</code>：返回布尔值，表示参数字符串是否在原字符串的头部。<br>    3.<code>endsWith(target,[index])</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。<br>    <code>target</code> 目标字符串，<code>index</code>可选参数 开始搜索的位置</p><pre><code class="javascript">let s = &#39;Hello world!&#39;;s.startsWith(&#39;Hello&#39;) // trues.endsWith(&#39;!&#39;) // trues.includes(&#39;o&#39;) // trues.startsWith(&#39;world&#39;, 6) // trues.endsWith(&#39;Hello&#39;, 5) // trues.includes(&#39;Hello&#39;, 6) // false</code></pre><p>3.<code>str.repeat(n)</code>方法 返回一个新字符串，表示将原字符串重复n次。 n可以是大于-1的数</p><pre><code class="javascript">let s = &quot;abc&quot;;s.repeat(3); //abcabcabc 参数为NaN 等同于 0s.repeat(-1) //RangeError 参数是负数或者Infinity，会报错。s.repeat(1.9) //abcabc 参数如果是小数，会被取整。s.repeat(-0.5) // &quot;&quot; 参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</code></pre><h3 id="ES5的类"><a href="#ES5的类" class="headerlink" title="ES5的类"></a>ES5的类</h3><p>1.构造函数 实例属性和方法</p><pre><code class="javascript">function Person() {    this.name = &quot;tom&quot;;    this.age = 20;    this.speak = function(){        console.log(this.name + &#39;:&#39; + this.age);    }}let p = new Person();console.log(p.name); //tomp.speak(); // tom:20</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>ES7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 常用集锦</title>
    <link href="/2020/03/11/js/js/"/>
    <url>/2020/03/11/js/js/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串基本操作"><a href="#字符串基本操作" class="headerlink" title="字符串基本操作"></a>字符串基本操作</h3><p>参考链接：<a href="https://www.jb51.net/article/97915.htm" target="_blank" rel="noopener">字符串操作</a></p><h3 id="数组基本操作"><a href="#数组基本操作" class="headerlink" title="数组基本操作"></a>数组基本操作</h3><p>参考链接：<a href="http://www.cnblogs.com/blogs-8888/p/6518683.html" target="_blank" rel="noopener">数组操作</a></p><h3 id="字符串去空格"><a href="#字符串去空格" class="headerlink" title="字符串去空格"></a>字符串去空格</h3><pre><code class="javascript">let trimSpace = function(str,is_global){    let result;    result = str.replace(/(^\s+)|(\s+$)/g,&quot;&quot;);    if(is_global &amp;&amp; is_global.toLowerCase()==&quot;g&quot;){        result = result.replace(/\s/g,&quot;&quot;);    }    return result;}</code></pre><h3 id="获取url参数值"><a href="#获取url参数值" class="headerlink" title="获取url参数值"></a>获取url参数值</h3><pre><code class="javascript">function getQueryVal(url){    let url = url || &#39;&#39;;    let arr = (url.split(&quot;?&quot;)[1] || url || &#39;&#39;).split(&quot;&amp;&quot;);    let o={};    if(arr[0]==&#39;&#39;){return o}    arr.forEach(function(x){        let ar=x.split(&quot;=&quot;);        o[ar[0]]=ar[1]    });    return o}eg: console.log(getQueryVal(&quot;http://192.168.28.50.9090/#/twitterInfo?isNeed=0&amp;userType=c&quot;));//{isNeed: &quot;0&quot;, userType: &quot;c&quot;}</code></pre><h3 id="vue里面使用hash模式获取url参数值"><a href="#vue里面使用hash模式获取url参数值" class="headerlink" title="vue里面使用hash模式获取url参数值"></a>vue里面使用hash模式获取url参数值</h3><pre><code class="javascript">/** *  name [参数名称] */let getHashString = function(name) {    let url = window.location.hash.substr(1);    let theRequest = {};    if(url.indexOf(&quot;?&quot;)&gt;-1){        let  strs = url.split(&quot;?&quot;)[1].split(&quot;&amp;&quot;);        for(let i = 0; i &lt; strs.length; i ++) {            theRequest[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]);        }        for(let j in theRequest){            if(name==j){                return theRequest[j];            }        }      }else {        return null;    }};eg:  console.log(getHashString(&quot;userType&quot;));// c</code></pre><h3 id="history模式获取url参数值"><a href="#history模式获取url参数值" class="headerlink" title="history模式获取url参数值"></a>history模式获取url参数值</h3><pre><code class="javascript">/** * name [参数名称] */let getQueryString = function(name) {    let reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);    let r = window.location.search.substr(1).match(reg);    if(r!=null)return  unescape(r[2]); return null;};eg: 当前的url是http://localhost:4000/home/index.html?caseid=123&amp;idx=1console.log(getQueryString(&quot;caseid&quot;));// 123</code></pre><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><pre><code class="javascript">function debounce(func,delay){    let timer = null;    return function(...args){        if(timer){            clearTimeout(timer);        }        timer = setTimeout(()=&gt;{            func.apply(this,args);        },delay)            }}// 测试function show(){    console.log(&#39;hello...&#39;);}let func = debounce(show,3000);// 调用func(); func(); func(); func(); func(); // 连续调用时，没有超过三秒是不会有任何输出的//hello...</code></pre><h3 id="Async-Await是Generator和Promise的组合，完全解决了基于回调的异步"><a href="#Async-Await是Generator和Promise的组合，完全解决了基于回调的异步" class="headerlink" title="Async/Await是Generator和Promise的组合，完全解决了基于回调的异步"></a>Async/Await是Generator和Promise的组合，完全解决了基于回调的异步</h3><pre><code class="javascript">let getKeyPromise = function () {    return new Promsie(function (resolve, reject) {        $.ajax({            type: &#39;get&#39;,            url: &#39;http://localhost:3000/apiKey&#39;,            success: function (data) {            let key = data;            resolve(key);                     },            error: function (err) {                reject(err);            }        });    });};let getTokenPromise = function (key) {    return new Promsie(function (resolve, reject) {        $.ajax({            type: &#39;get&#39;,            url: &#39;http://localhost:3000/getToken&#39;,            data: {                key: key            },            success: function (data) {                resolve(data);                     },            error: function (err) {                reject(err);            }        });    });};let getDataPromise = function (data) {    let token = data.token;    let userId = data.userId;    return new Promsie(function (resolve, reject) {        $.ajax({            type: &#39;get&#39;,            url: &#39;http://localhost:3000/getData&#39;,            data: {                token: token,                userId: userId            },            success: function (data) {                resolve(data);                     },            error: function (err) {                reject(err);            }        });    });};async function main () {    let key = await getKeyPromise();    let loginData = await getTokenPromise(key);    let busiData = await getDataPromise(loginData);    console.log(&#39;数据：&#39;, busiData);}main();console.log(&#39;123&#39;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 常用集锦</title>
    <link href="/2020/03/11/vue/vue/"/>
    <url>/2020/03/11/vue/vue/</url>
    
    <content type="html"><![CDATA[<h3 id="v-text-v-html-中如何使用过滤器"><a href="#v-text-v-html-中如何使用过滤器" class="headerlink" title="v-text/v-html 中如何使用过滤器"></a>v-text/v-html 中如何使用过滤器</h3><p>Vue2.x 不再支持在 <code>v-html</code> 中使用过滤器Vue2.x 的过滤器现在只能应用在“Mustache”语法 (双大括号) 的文本插值 和 <code>v-bind</code> 中。<br>如果要使用采用如下方式：</p><p><code>v-html=&quot;$options.filters.过滤器名称(需要过滤的内容,[过滤器需要的参数])&quot;</code></p><h3 id="在Vue组件中动态生成的DOM类名样式不作用-deep"><a href="#在Vue组件中动态生成的DOM类名样式不作用-deep" class="headerlink" title="在Vue组件中动态生成的DOM类名样式不作用-/deep/"></a>在Vue组件中动态生成的DOM类名样式不作用-/deep/</h3><pre><code class="html">&lt;template&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;div v-text=&quot;text&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name:&quot;app&quot;,        data(){            return {                text:&lt;span class=&quot;red&quot;&gt;红色&lt;/span&gt;            }         }    }&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;    /deep/ .red{        color:red;    }&lt;/style&gt;</code></pre><p>注意：/deep/ 只是在最外层使用，不要嵌套使用。<br>参考文档：<a href="https://vue-loader.vuejs.org/guide/scoped-css.html" target="_blank" rel="noopener">deep</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 常用集锦</title>
    <link href="/2020/03/11/css/css/"/>
    <url>/2020/03/11/css/css/</url>
    
    <content type="html"><![CDATA[<h3 id="多行文本垂直居中"><a href="#多行文本垂直居中" class="headerlink" title="多行文本垂直居中"></a>多行文本垂直居中</h3><p>父元素 设置：display:table,height:500px;<br>子元素 设置：dispaly:table-cell;vertical-align:middle;</p><pre><code class="html">&lt;div class=&quot;parent&quot;&gt;&lt;span class=&quot;child&quot;&gt;    &lt;img src=&quot;&quot;/&gt;    &lt;span&gt;垂直居中&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;</code></pre><pre><code class="css">.parent {    display:table,height:500px}.child {    dispaly:table-cell;vertical-align:middle}</code></pre><h3 id="webkit表单输入框placeholder的颜色值改变"><a href="#webkit表单输入框placeholder的颜色值改变" class="headerlink" title="webkit表单输入框placeholder的颜色值改变"></a>webkit表单输入框placeholder的颜色值改变</h3><pre><code class="css">如果想要默认的颜色显示红色，代码如下：input::-webkit-input-placeholder{color:red;}如果想要用户点击变为蓝色，代码如下：input:focus::-webkit-input-placeholder{color:blue;}</code></pre><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>word-break:break-all;只对英文起作用，以字母作为换行依据<br>word-wrap:break-word;只对英文起作用，以单词作为换行依据<br>white-space:pre-wrap;只对中文起作用，强制换行<br>white-space:nowrap;都起作用，强制不换行</p><p>white-space:nowrap;<br>overflow:hidden;<br>text-overflow:ellipsis;<br>width:500px;<br>不换行超出部分显示…</p><p>常用自定义类名：</p><pre><code class="css">/*自动换行*/.cut-text {    word-break:break-all;    word-wrap:break-word;}/*强制不换行*/.no-cut-text {    white-space:nowrap;}/*英文换行*/.en-cut-text  {    word-break:break-all;}/*超出显示...*/.text-dots {    width:500px;    text-overflow:ellipsis;    overflow:hidden;    white-space:nowrap;}/*超出两行文本显示...*/ /*必须指定width*/.text2LineRestrist {    overflow: hidden;    text-overflow:ellipsis;    display:-webkit-box;    -webkit-box-orient:vertical;    -webkit-line-clamp:2;}/*超出三行文本显示...*/ /*必须指定width*/.text3LineRestrist {    overflow: hidden;    text-overflow:ellipsis;    display:-webkit-box;    -webkit-box-orient:vertical;    -webkit-line-clamp:3;}</code></pre><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><pre><code class="css">.clearfix {zoom:1;}.clearfix::after,.clearfix::before{    content:&quot;&quot;;    display:block;    clear: both;    visibility: hidden;    height:0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
