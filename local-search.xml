<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TS中的装饰器</title>
    <link href="/2020/05/05/ts/decorator/"/>
    <url>/2020/05/05/ts/decorator/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是装饰器"><a href="#1-什么是装饰器" class="headerlink" title="1.什么是装饰器"></a>1.什么是装饰器</h3><p>装饰器是一种特殊类型的声明，它能够被附加到类，方法，属性或参数上，可以修改类的行为。<br>通俗的讲装饰器就是一个方法，可以注入到类，方法，属性参数上来拓展类，属性，方法，参数的功能。<br>常见的装饰器：</p><ul><li>类装饰器     </li><li>属性装饰器   </li><li>方法装饰器   </li><li>参数装饰器</li></ul><p>装饰器的写法：</p><ul><li>普通装饰器（无法传参）       </li><li>装饰器工厂（可传参）</li></ul><h3 id="2-类装饰器"><a href="#2-类装饰器" class="headerlink" title="2.类装饰器"></a>2.类装饰器</h3><blockquote><p>类装饰器—-普通装饰器(无法传参)</p></blockquote><pre><code class="ts">function logClass(params: any) {    console.log(params) //当前类    //TODO ① 拓展-属性    params.prototype.apiUrl = &#39;https://www.bilibili.com/video/av38379328/?p=19&#39;;    // TODO ② 拓展-方法    params.prototype.get = function(){        console.log(&#39;我是拓展的方法&#39; + this.apiUrl);    }}@logClassclass HttpClient {    constructor() {    }    getData() {    }}let http: any = new HttpClient();//TODO ① 访问拓展的属性console.log(http.apiUrl); //https://www.bilibili.com/video/av38379328/?p=19//TODO ② 访问拓展的方法http.get(); // 我是拓展的方法https://www.bilibili.com/video/av38379328/?p=19</code></pre><blockquote><p>类装饰器—-装饰器工厂(可传参)—返回一个函数</p></blockquote><pre><code class="ts">function logClass(params: string) {    return function (target: any) {        console.log(params) // 传入的参数 https://www.bilibili.com/video/av38379328/?p=19        console.log(target) // 当前类        // 拓展 apiUrl 属性，其值为传入的 params;        target.prototype.apiUrl = params;    }}@logClass(&#39;https://www.bilibili.com/video/av38379328/?p=19&#39;)class HttpClient {    constructor() {    }    getData() {    }}let http: any = new HttpClient();console.log(&#39;使用装饰器工厂拓展的属性&#39;, http.apiUrl); //使用装饰器工厂拓展的属性 https://www.bilibili.com/video/av38379328/?p=19</code></pre><blockquote><p>类装饰器-重载构造函数的例子—返回一个继承于当前类的子类</p></blockquote><pre><code class="ts">// 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。// 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。function logClass(target: any) {    console.log(target) // target 当前类    return class extends target {        // TODO ① 重载apiUrl的值        apiUrl = &#39;我是修改后的数据  https://www.bilibili.com/video/av38379328/?p=19&#39;;        // TODO ② HttpClient类里面的方法被重载了        getData() {            this.apiUrl += &#39;---&#39;;            console.log(this.apiUrl)        }    }}@logClassclass HttpClient {    public apiUrl: string | undefined;    constructor() {        // TODO ① 初始化apiUrl的值        this.apiUrl = &quot;我是constructor里面的apiUrl&quot;;    }    // TODO ② HttpClient类里面的方法    getData() {        console.log(this.apiUrl);    }}let http: any = new HttpClient();http.getData(); // 我是修改后的数据  https://www.bilibili.com/video/av38379328/?p=19---</code></pre><h3 id="3-属性装饰器"><a href="#3-属性装饰器" class="headerlink" title="3.属性装饰器"></a>3.属性装饰器</h3><p>属性装饰器表达式会在运行时当作函数被调用，传入2个参数<br>1.对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。<br>2.成员的名称。</p><pre><code class="ts">// 1.实例成员function logProperty(params: string) {    return function (target: any, attrName: string) {        console.log(params); // http://www.baidu.com        console.log(target); // TODO ① HttpClient 这个类的原型对象（即:HttpClient.prototype）  HttpClient { getData: [Function] }        console.log(attrName) //apiUrl        target[attrName] = params;    }}class HttpClient {    @logProperty(&#39;http://www.baidu.com&#39;)    public apiUrl: string | undefined; //TODO ① 这里声明为实例属性    constructor() {    }    getData() {        console.log(this.apiUrl);    }}let http: any = new HttpClient();http.getData(); // http://www.baidu.com</code></pre><pre><code class="ts">//2.静态成员function logProperty(params: string) {    return function (target: any, attrName: string) {        console.log(params); // http://www.baidu.com/2        console.log(target);// TODO ② HttpClient 这个类  [Function: HttpClient]        console.log(attrName) //apiUrl2        target[attrName] = params; //由于是静态属性 这里就直接把params 挂到类上    }}class HttpClient {    @logProperty(&#39;http://www.baidu.com/2&#39;)    static apiUrl2: string | undefined; //TODO ② 这里声明为静态成员    constructor() {    }    getData() {        console.log(HttpClient.apiUrl2); // 静态属性通过 HttpClient.属性名 来访问    }}let http: any = new HttpClient();http.getData(); // http://www.baidu.com/2</code></pre><h3 id="4-方法装饰器"><a href="#4-方法装饰器" class="headerlink" title="4.方法装饰器"></a>4.方法装饰器</h3><p>它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。<br>方法装饰器表达式会在运行时当作函数被调用，传入3个参数<br>1.对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。<br>2.成员的名称。<br>3.成员的属性描述符。</p><pre><code class="ts">//这里只演示：实例成员function logFunc(params: string) {    return function (target: any, funcName: string, desc: any) {        console.log(params); // http://www.jd.com        console.log(target); // HttpClient.prototype        console.log(funcName); // getData        console.log(desc);        /*            {                 value: [Function],                writable: true,                enumerable: true,                configurable: true             }        */        // 修改装饰的方法（操作desc.value） 把装饰器方法里面传入的参数全部修改为string类型。        // 1.保存当前方法        let oldFunc = desc.value;        // 2.重写 desc.value        desc.value = function (...args: any[]) {            console.log(args); // [123, &#39;456&#39;]            // 3.转换为String            args = args.map(value =&gt; {                return String(value);            })            console.log(args); // [ &#39;123&#39;, &#39;456&#39; ]            // 4.选择替换该方法还是给方法增加功能            oldFunc.apply(this, args); // 加上这个就会执行HttpClient 类里面的getData 方法。            // 不加 就是把【HttpClient 类里面的getData 方法】给替换了。        }    }}class HttpClient {    apiUrl: string | undefined;    constructor() {    }    @logFunc(&#39;http://www.jd.com&#39;)    getData(...args: any[]) {        console.log(args); // 经过装饰器的修改，这里全部被转为了String类型 [ &#39;123&#39;, &#39;456&#39; ]        console.log(&#39;我是getData&#39;);    }}let http: any = new HttpClient();http.getData(123, &#39;456&#39;);</code></pre><h3 id="5-方法参数装饰器（不常用）"><a href="#5-方法参数装饰器（不常用）" class="headerlink" title="5.方法参数装饰器（不常用）"></a>5.方法参数装饰器（不常用）</h3><p>参数装饰器表达式会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元数据，传入3个参数<br>1.对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。<br>2.方法的名称。<br>3.参数在函数参数列表中的索引。</p><pre><code class="ts">function logParams(params: string) {    return function (target: any, funcName: string, paramsIndex: number) {        console.log(params) // name         id        console.log(target) // HttpClient.prototype        console.log(funcName) // getData        console.log(paramsIndex) // 1       0    }}class HttpClient {    url: any | undefined;    constructor() {    }    getData(        @logParams(&#39;id&#39;) id: number, //后执行        @logParams(&#39;name&#39;) name: string // 先执行    ) {    }}</code></pre><h3 id="6-执行顺序"><a href="#6-执行顺序" class="headerlink" title="6.执行顺序"></a>6.执行顺序</h3><blockquote><p>属性装饰器—&gt;方法装饰器—&gt;方法参数装饰器—&gt;类装饰器<br>如果有多个同样的装饰器都是 从后到前执行</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的泛型</title>
    <link href="/2020/05/04/ts/generics/"/>
    <url>/2020/05/04/ts/generics/</url>
    
    <content type="html"><![CDATA[<h3 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h3><p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。<br>组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。<br>通俗理解：泛型就是解决 类，接口，函数的复用性，以及对不特定的数据类型的支持。</p><h3 id="2-泛型函数"><a href="#2-泛型函数" class="headerlink" title="2.泛型函数"></a>2.泛型函数</h3><pre><code class="ts">function getData&lt;T&gt;(str: T): T {    return str;}let str = getData&lt;string&gt;(&#39;aaa&#39;);console.log(str);let str2 = getData&lt;number&gt;(123);console.log(str2);let str3 = getData&lt;number | string&gt;(&quot;123&quot;);console.log(str3);</code></pre><h3 id="3-泛型类"><a href="#3-泛型类" class="headerlink" title="3.泛型类"></a>3.泛型类</h3><pre><code class="ts">class MinClass&lt;T&gt; {    list: Array&lt;T&gt; = [];    add(num: T):void {        this.list.push(num);    }    min(): T {        let minVal = this.list[0];        for (let i = 0; i &lt; this.list.length; i++) {            if (minVal &gt; this.list[i]) {                minVal = this.list[i];            }        }        return minVal;    }}let num = new MinClass&lt;number&gt;();num.add(3);num.add(1);num.add(2);console.log(num.min()) //1let str = new MinClass&lt;string&gt;();str.add(&#39;y&#39;);str.add(&#39;x&#39;);str.add(&#39;w&#39;);console.log(str.min()) //w</code></pre><h3 id="4-泛型接口"><a href="#4-泛型接口" class="headerlink" title="4.泛型接口"></a>4.泛型接口</h3><pre><code class="ts">// 泛型接口 写法1interface IConfigFn {    &lt;T&gt;(value: T): T;}let fs: IConfigFn = function &lt;T&gt;(value: T): T {    return value;}let newFs = fs&lt;number&gt;(123);console.log(newFs); // 123// 泛型接口 写法2interface IConfigFn2&lt;T&gt; {    (value: T): T;}function getData&lt;T&gt;(vlaue: T): T {    return vlaue;}let getMyData: IConfigFn2&lt;boolean&gt; = getData;console.log(getMyData(false)); //false</code></pre><pre><code class="ts">interface IConfigFn {    &lt;T&gt;(value: T): T;}let fs: IConfigFn = function &lt;T&gt;(value: T): T {    return value;}console.log(fs&lt;number&gt;(123));interface IConfigFn2&lt;T&gt; {    (value: T): T;}function getData&lt;T&gt;(value: T): T {    return value;}let fs2: IConfigFn2&lt;number[]&gt; = getData;let fs3: IConfigFn2&lt;Array&lt;string&gt;&gt; = getData;console.log(fs2([1, 2, 3]));console.log(fs3([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]));</code></pre><h3 id="5-把类作为参数类型的泛型类"><a href="#5-把类作为参数类型的泛型类" class="headerlink" title="5.把类作为参数类型的泛型类"></a>5.把类作为参数类型的泛型类</h3><pre><code class="ts">// 把类作为参数来约束数据传入的类型class User {    username: string | undefined;    password: string | undefined;}class ActicleCate {    title: string | undefined;    desc: string | undefined;    constructor(params: {        title: string,        desc: string    }) {        this.title = params.title;        this.desc = params.desc;    }}class MySql&lt;T&gt;{    add(value: T): boolean {        console.log(value);        return true;    }}let db = new MySql&lt;User&gt;();db.add({    username: &#39;aaa&#39;,    password: &#39;123456&#39;});let aDb = new MySql&lt;ActicleCate&gt;();let arcticle = new ActicleCate({    title: &#39;今天好天气&#39;,    desc: &#39;25度，确实可以&#39;});aDb.add(arcticle);</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的模块和命名空间</title>
    <link href="/2020/05/03/ts/namespace/"/>
    <url>/2020/05/03/ts/namespace/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模块的概念"><a href="#1-模块的概念" class="headerlink" title="1.模块的概念"></a>1.模块的概念</h3><p>我们可以把一些公共的功能单独抽离成一个文件作为模块。<br>模块里面的变量，函数，类等默认是私有的，如果我们要在外部访问模块里面的（变量，函数，类），我们需要通过export 暴露出模块里面的（变量，函数，类）。暴露后我们通过 import 引入模块中的（变量，函数，类），这样就可以使用了。</p><pre><code class="ts">// db.tslet dbUrl = &#39;xxxxx&#39;;export function getData:any[]{    console.log(&#39;获取数据&#39;);    return [        {            title:&#39;123&#39;,            name:&#39;哈哈哈哈&#39;,        }    ]}//另一种暴露方式export {    dbUrl,    getData}// export default 默认导出，每个模块都可以有一个default导出，并且每个模块只能有一个default导出。export default getData;//引入的时候 import getData from &#39;./db/; 没有{}了。</code></pre><pre><code class="ts">// index.ts import { getData } from &#39;./db&#39;;getData();// 别名import { getData as get} from &#39;./db&#39;;get();</code></pre><h3 id="2-命名空间和模块的区别"><a href="#2-命名空间和模块的区别" class="headerlink" title="2.命名空间和模块的区别"></a>2.命名空间和模块的区别</h3><ul><li>命名空间：内部模块，主要用于组织代码，避免命名冲突。</li><li>模块：ts的外部模块的简称，侧重代码的复用，一个模块里可以有多个命名空间。</li></ul><pre><code class="ts">// 暴露命名空间Aexport namespace A{    export function getData:any[]{        console.log(&#39;获取数据&#39;);        return [            {                title:&#39;123&#39;,                name:&#39;哈哈哈哈&#39;,            }        ]    }}// 暴露命名空间Bexport namespace B{    export function getData:any[]{        console.log(&#39;获取数据&#39;);        return [            {                title:&#39;123&#39;,                name:&#39;哈哈哈哈&#39;,            }        ]    }}// 内部使用：A.getData();B.getData();// 外部使用 需要给namespace 也暴露出去</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的接口</title>
    <link href="/2020/05/02/ts/interface/"/>
    <url>/2020/05/02/ts/interface/</url>
    
    <content type="html"><![CDATA[<p>接口的作用：定义标准<br>在面向对象的编程中，接口是一种规范的定义，它定义了行为和动作的规范，在程序设计里面，接口起到了一种限制和规范的作用。接口定义了某一批类所需要遵循的规范，接口不关心这些类的内部状态数据，也不关心这些类里方法的实现细节，它只规定这批类里必须提供某些方法，提供这些方法的类就可以满足实际需要。</p><h3 id="1-属性接口"><a href="#1-属性接口" class="headerlink" title="1.属性接口"></a>1.属性接口</h3><blockquote><p>对json的约束</p></blockquote><pre><code class="ts">interface IObj {    name: string;    age?: number;}function getList(obj: IObj): void {    console.log(obj.name);    console.log(obj.age);}let obj = {    name: &#39;tom&#39;,    age: 22,//可选属性，可传，可不传}getList(obj);</code></pre><pre><code class="ts">interface IObj {    name: string;    age: number;}function getList(obj: IObj): void {    console.log(obj.name);    console.log(obj.age);}//定义在外面 只要包含name，age就可以let obj = {    name: &#39;tom&#39;,    age: 20,    firstName: &#39;t&#39;, //额外的属性}getList(obj);//定义在里面 只能有name，agegetList({    name: &#39;tom&#39;,    age: 20,    firstName: &#39;t&#39;, //错误});//正确getList({    name: &#39;tom&#39;,    age: 20,});</code></pre><h3 id="2-函数接口"><a href="#2-函数接口" class="headerlink" title="2.函数接口"></a>2.函数接口</h3><blockquote><p>对函数传入的参数和返回值进行约束</p></blockquote><pre><code class="ts">interface encrypt {    (key: string, value: string): string;}let md5: encrypt = function (key: string, value: string): string {    return key + &#39;--md5-&#39; + value;};let sha1: encrypt = function (key: string, value: string): string {    return key + &#39;--sha1-&#39; + value;};console.log(md5(&#39;name&#39;, &#39;数学&#39;));console.log(sha1(&#39;name&#39;, &#39;历史&#39;));</code></pre><h3 id="3-可索引接口"><a href="#3-可索引接口" class="headerlink" title="3.可索引接口"></a>3.可索引接口</h3><blockquote><p>对数组、对象的约束（不常用）</p></blockquote><pre><code class="ts">//对 数组的约束interface userArray {    [index: number]: string;}let arr: userArray = [&#39;a&#39;, &#39;123&#39;];// 对 对象的约束interface userObj {    [index: string]: string | number;}let obj: userObj = {    name: &#39;张三&#39;,}// 对 数组对象的约束interface userArrayObj {    [index: number]: userObj}let list: userArrayObj = [{    name: &#39;张三&#39;,    age: 20}];</code></pre><h3 id="4-类-类型接口"><a href="#4-类-类型接口" class="headerlink" title="4.类 类型接口"></a>4.类 类型接口</h3><blockquote><p>对类的约束 和抽象类有点相似</p></blockquote><pre><code class="ts">// 类 类型接口  implements 实现接口interface IAnimal {    name: string;    age: number;    eat(str: string): void;    run(value: number): string;}class Dogs implements IAnimal {    name: string;    age: number;    constructor(name: string, age: number) {        this.name = name;        this.age = age;    }    eat(str: string): void {        console.log(str);    }    run(value: number): string {        return &#39;我跑了&#39; + value;    }}</code></pre><h3 id="5-接口扩展（接口可以继承接口）"><a href="#5-接口扩展（接口可以继承接口）" class="headerlink" title="5.接口扩展（接口可以继承接口）"></a>5.接口扩展（接口可以继承接口）</h3><pre><code class="ts">interface IAnimal {    name: string;    age: number;    eat(str: string): void;    run(value: number): string;}interface IPerson extends IAnimal {    cate: string;    print(str: string): void;}class Person implements IPerson {    name: string;    age: number;    cate: string;    constructor(name: string, age: number, cate: string) {        this.name = name;        this.age = age;        this.cate = cate;    }    print(str: string): void {        console.log(str);    }    eat(str: string): void {        console.log(str + &#39;吃饭&#39;)    }    run(value: number): string {        return &#39;我跑了&#39; + value;    }}let s = new Person(&#39;小小&#39;, 20, &#39;人&#39;);console.log(s.run(60));s.eat(&#39;小小&#39;);</code></pre><pre><code class="ts">interface IAnimal {    name: string;    age: number;    eat(str: string): void;    run(value: number): string;}interface IPerson extends IAnimal {    cate: string;    print(str: string): void;}class Person implements IPerson {    name: string;    age: number;    cate: string;    constructor(name: string, age: number, cate: string) {        this.name = name;        this.age = age;        this.cate = cate;    }    print(str: string): void {        console.log(str);    }    eat(str: string): void {        console.log(str + &#39;吃饭&#39;)    }    run(value: number): string {        return &#39;我跑了&#39; + value;    }}// 同时继承类 和 实现接口class Programmer extends Person implements IPerson {    constructor(name: string, age: number, cate: string) {        super(name, age, cate);    }    print(str: string): void {        console.log(str);    }    eat(str: string): void {        console.log(str + &#39;吃饭&#39;)    }    run(value: number): string {        return &#39;我跑了&#39; + value;    }}let s = new Person(&#39;小小&#39;, 20, &#39;人&#39;);console.log(s.run(60));s.eat(&#39;小小&#39;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的类</title>
    <link href="/2020/05/01/ts/class/"/>
    <url>/2020/05/01/ts/class/</url>
    
    <content type="html"><![CDATA[<h3 id="1-class的创建"><a href="#1-class的创建" class="headerlink" title="1.class的创建"></a>1.class的创建</h3><pre><code class="ts">class Person {    name: string;    age: number;    constructor(name: string, age: number) { //构造方法 实例化类的时候触发的方法        this.name = name;        this.age = age;    }    run(): void {        console.log(this.name + &#39;在跑步&#39;);    }    getName(): string {        return this.name;    }    setName(name: string): void {        this.name = name;    }}let p = new Person(&#39;张三&#39;, 30);console.log(p.name); //张三p.run();// 张三在跑步console.log(p.getName());//张三p.setName(&#39;李四&#39;);console.log(p.getName());//李四</code></pre><h3 id="2-TS-类的继承-extends-super"><a href="#2-TS-类的继承-extends-super" class="headerlink" title="2.TS 类的继承 extends + super"></a>2.TS 类的继承 extends + super</h3><pre><code class="ts">class Person {    name: string;    age: number;    constructor(name: string, age: number) {        this.name = name;        this.age = age;    }    run(): void {        console.log(this.name + &#39;在跑步&#39;);    }    getName(): string {        return this.name;    }    setName(name: string): void {        this.name = name;    }}//子类class Student extends Person {    sex: string;    constructor(name: string, age: number, sex: string) {        super(name, age); //初始化父类的构造函数        this.sex = sex;    }    run(): void {        console.log(this.name + &#39;在跑步&#39;);    }    work(): void {        console.log(this.name + &#39;在工作&#39;);    }    print(): string {        return this.name + &#39;-&#39; + this.age + &#39;-&#39; + this.sex;    }}let s = new Student(&#39;李白&#39;, 400, &#39;男&#39;);console.log(s.sex); //男s.run(); //李白在跑步console.log(s.print()); //李白-400-男</code></pre><h3 id="3-类的修饰符-public-默认-private-protected"><a href="#3-类的修饰符-public-默认-private-protected" class="headerlink" title="3.类的修饰符 public(默认)  private   protected"></a>3.类的修饰符 public(默认)  private   protected</h3><table><thead><tr><th>是否可以访问</th><th>描述</th><th>父类</th><th>子类</th><th>类外部</th></tr></thead><tbody><tr><td>public</td><td>公有</td><td>ok</td><td>ok</td><td>ok</td></tr><tr><td>private</td><td>私有</td><td>ok</td><td>no</td><td>no</td></tr><tr><td>protected</td><td>保护类型</td><td>ok</td><td>ok</td><td>no</td></tr></tbody></table><h3 id="4-类的静态属性和静态方法"><a href="#4-类的静态属性和静态方法" class="headerlink" title="4.类的静态属性和静态方法"></a>4.类的静态属性和静态方法</h3><pre><code class="ts">class Person {    name: string;    age: number;    static sex:string = &#39;男&#39;;    constructor(name: string, age: number) {        this.name = name;        this.age = age;    }    run(): void {        console.log(this.name + &#39;在跑步&#39;);    }    static print():void{ //静态方法中无法访问this(即不能访问实例属性和实例方法)        console.log(Person.sex);    }}let p = new Person(&#39;zs&#39;,56);console.log(Person.sex); // 男Person.print(); // 男</code></pre><h3 id="5-多态"><a href="#5-多态" class="headerlink" title="5.多态"></a>5.多态</h3><p>父类定义一个方法不去实现，让继承他的子类去实现，每个子类有不同的表现<br>多态属于继承</p><pre><code class="ts">class Animal {    name: string;    constructor(name: string) {        this.name = name;    }    eat(): void {        console.log(this.name);    }}class Dog extends Animal {    constructor(name: string) {        super(name);    }    eat():void{        console.log(`${this.name} 要吃肉`);    }}class Fish extends Animal {    constructor(name:string){        super(name);    }    eat():void {        console.log(`${this.name} 要吃微生物`);    }}</code></pre><h3 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6.抽象类"></a>6.抽象类</h3><ul><li>是提供其他类继承的基类，不能直接被实例化。</li><li>用abstract关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现，并且必须在派生类中实现。</li><li>抽象方法只能放在抽象类中</li><li>抽象类和抽象方法用来定义标准</li></ul><pre><code class="ts">abstract class Animal {    name:string;    constructor(name:string){        this.name = name;     }    abstract eat(): any; //抽象类中的抽象方法不包含具体实现}/* let a = new Animal(); //错误 不能直接被实例化 */class Dog extends Animal {    constructor(name:string){        super(name);    }    // 抽象类的子类必须实现抽象类的抽象方法    eat(): string {        return this.name + &#39;喜欢吃肉&#39;;    }}let d = new Dog(&#39;小狗&#39;);console.log(d.eat()); //小狗喜欢吃肉</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 使用方法</title>
    <link href="/2020/04/30/git/git/"/>
    <url>/2020/04/30/git/git/</url>
    
    <content type="html"><![CDATA[<h2 id="Git-使用方法"><a href="#Git-使用方法" class="headerlink" title="Git 使用方法"></a>Git 使用方法</h2><h3 id="常用git操作"><a href="#常用git操作" class="headerlink" title="常用git操作"></a>常用git操作</h3><blockquote><pre><code>+ 新建分支并切换到新分支      git checkout -b [branch-name]+ 删除本地分支                git branch -d [branch-name]+ 删除远程分支                git push origin --delete [branch-name]+ 重置暂存区与工作区，与上一次commit保持一致     git reset --hard+ 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset [commit]</code></pre></blockquote><h3 id="1、git工作空间"><a href="#1、git工作空间" class="headerlink" title="1、git工作空间"></a>1、git工作空间</h3><p><img src="/img/git.png" srcset="/img/loading.gif" alt="git"></p><ul><li><p>Workspace: 工作区</p></li><li><p>Index/Stage：暂存区</p></li><li><p>Repository: 仓库区（或本地仓库）</p></li><li><p>Remote：远程仓库</p></li></ul><h3 id="2、新建代码仓库"><a href="#2、新建代码仓库" class="headerlink" title="2、新建代码仓库"></a>2、新建代码仓库</h3><pre><code># 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]</code></pre><h3 id="3、配置git"><a href="#3、配置git" class="headerlink" title="3、配置git"></a>3、配置git</h3><pre><code class="js"># 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h3 id="4、增加-删除文件"><a href="#4、增加-删除文件" class="headerlink" title="4、增加/删除文件"></a>4、增加/删除文件</h3><pre><code class="js"># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .</code></pre><h3 id="5、代码提交"><a href="#5、代码提交" class="headerlink" title="5、代码提交"></a>5、代码提交</h3><pre><code class="js"># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...</code></pre><h3 id="6、分支"><a href="#6、分支" class="headerlink" title="6、分支"></a>6、分支</h3><pre><code class="js"># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h3 id="7、标签"><a href="#7、标签" class="headerlink" title="7、标签"></a>7、标签</h3><pre><code class="js"># 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags</code></pre><h3 id="8、查看信息"><a href="#8、查看信息" class="headerlink" title="8、查看信息"></a>8、查看信息</h3><pre><code class="js"># 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog</code></pre><h3 id="9、远程同步"><a href="#9、远程同步" class="headerlink" title="9、远程同步"></a>9、远程同步</h3><pre><code class="js"># 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all# 更新远程分支列表$ git remote update origin -p</code></pre><h3 id="10、撤销"><a href="#10、撤销" class="headerlink" title="10、撤销"></a>10、撤销</h3><pre><code class="js"># 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop</code></pre><h3 id="11、远程同步Git参考手册"><a href="#11、远程同步Git参考手册" class="headerlink" title="11、远程同步Git参考手册"></a>11、远程同步Git参考手册</h3><p><a href="http://gitref.justjavac.com/index.html" target="_blank" rel="noopener">http://gitref.justjavac.com/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 处理如何优雅的处理复杂判断</title>
    <link href="/2020/04/29/js/if-else/"/>
    <url>/2020/04/29/js/if-else/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本if-else-逻辑判断"><a href="#1-基本if-else-逻辑判断" class="headerlink" title="1.基本if else 逻辑判断"></a>1.基本if else 逻辑判断</h3><pre><code class="js">let sex = 1;let sexText = &#39;&#39;;if(sex === 1){  sexText = &#39;男&#39;;}else if(sex === 2){  sexText = &#39;女&#39;;}else {  sexText = &#39;其他&#39;;}</code></pre><h3 id="2-switch-case"><a href="#2-switch-case" class="headerlink" title="2.switch/case"></a>2.switch/case</h3><pre><code class="js">const getStatusText = (status) =&gt; { let str = &#39;&#39;;  switch (status) {    case 1:      str=&quot;待开通&quot;;      break;    case 2:      str=&quot;开通准备中&quot;;      break;    case 3:      str=&quot;开通准备完成&quot;;      break;    default:      str=&quot;已过期&quot;;      break; }  return str;}</code></pre><h3 id="3-三元表达式"><a href="#3-三元表达式" class="headerlink" title="3.三元表达式"></a>3.三元表达式</h3><pre><code class="js">let sex = 1;let sexText = sex === 1 ? &#39;男&#39; : sex === 2 ? &#39;女&#39;: &#39;其他&#39;;</code></pre><h3 id="4-短路-amp-amp-与"><a href="#4-短路-amp-amp-与" class="headerlink" title="4.短路 &amp;&amp; 与 ||"></a>4.短路 &amp;&amp; 与 ||</h3><p>&amp;&amp; 中第一个表达式为假就不会去处理第二个表达式，|| 则相反</p><pre><code class="js">// if为真if (bool) { value = getValueTrue();}// &amp;&amp;改版bool &amp;&amp; (value = getValueTrue());// if为假if (!bool) { value = getValueFalse();}// || 改版bool || (value = getValueFalse());</code></pre><h3 id="5-对象-或-数组"><a href="#5-对象-或-数组" class="headerlink" title="5.对象 或 数组"></a>5.对象 或 数组</h3><pre><code class="js">const getStatusText = (status) =&gt; {  let statusObj = {     1: &#39;待开通&#39;,     2: &#39;开通准备中&#39;,     3: &#39;开通准备完成&#39; };  return statusObj[status] ? statusObj[status] : &#39;&#39;;}const getStatus = (status) =&gt; {  let statusArr = [&#39;待开通&#39;,&#39;开通准备中&#39;,&#39;开通准备完成&#39;]  return statusArr[status-1] ? statusArr[status-1] : &#39;&#39;;}</code></pre><h3 id="6-includes"><a href="#6-includes" class="headerlink" title="6.includes"></a>6.includes</h3><pre><code class="js">if (operate === &#39;submitAudit&#39; || operate === &#39;cancelUpdate&#39; || operate === &#39;uplineApplet&#39;) {  this.handleOperate(operate, row);  return;}//使用includesconst actionArr = [&#39;submitAudit&#39;,&#39;cancelUpdate&#39;,&#39;uplineApplet&#39;];if(actionArr.includes(operate)){  this.handleOperate(operate, row);  return;}</code></pre><h3 id="7-Map"><a href="#7-Map" class="headerlink" title="7.Map"></a>7.Map</h3><p>假如：</p><p>‘待开通’ 具有 设置版本setVersion 的操作</p><p>‘开通准备中’ 无操作</p><p>‘开通准备完成’ 具有发布releaseApplet和取消本次开通cancelDredge的操作</p><pre><code class="js">const getStatus = (status) =&gt; {  const maps = new Map([   [1,[&#39;待开通&#39;,[&#39;setVersion&#39;]]],     [2,[&#39;开通准备中&#39;,]],     [3,[&#39;开通准备完成&#39;,[&#39;releaseApplet&#39;,&#39;cancelDredge&#39;]]], ])  const action = maps.get(status);  let obj = {    statusText:&#39;&#39;,    statusFn:[], }  obj.statusText = action[0];//  [&quot;待开通&quot;]  obj.statusFn = action[1] || [];// [&#39;setVersion&#39;]  return obj;}getStatus(2) // { statusText: &quot;开通准备中&quot;,statusFn: [] }</code></pre><h3 id="其他复杂的Map用法可以参看这边文章"><a href="#其他复杂的Map用法可以参看这边文章" class="headerlink" title="其他复杂的Map用法可以参看这边文章"></a>其他复杂的Map用法可以参看这边文章</h3><p><a href="https://segmentfault.com/a/1190000017105791" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017105791</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Taro 采坑指南</title>
    <link href="/2020/03/12/taro/taro/"/>
    <url>/2020/03/12/taro/taro/</url>
    
    <content type="html"><![CDATA[<h3 id="在Taro中如何正确给自定义组件传递样式类"><a href="#在Taro中如何正确给自定义组件传递样式类" class="headerlink" title="在Taro中如何正确给自定义组件传递样式类"></a>在Taro中如何正确给自定义组件传递样式类</h3><p>需要利用 externalClasses 定义段定义若干个外部样式类。这个特性从小程序基础库版本 1.9.90 开始支持。</p><pre><code class="js">/* CustomComp.js */export default class CustomComp extends Component {  static externalClasses = [&#39;my-class&#39;]  render () {    return &lt;View className=&quot;my-class&quot;&gt;这段文本的颜色由组件外的 class 决定&lt;/View&gt;  }}</code></pre><pre><code class="js">/* MyPage.js */export default class MyPage extends Component {  render () {    return &lt;CustomComp my-class=&quot;red-text&quot; /&gt;  }}</code></pre><pre><code class="scss">/* MyPage.scss */.red-text {  color: red;}</code></pre><p>注意：externalClasses 需要使用 短横线命名法 (kebab-case)，而不是 React 惯用的 驼峰命名法 (camelCase)。否则无效。</p><h3 id="父组件的样式类完全影响子组件"><a href="#父组件的样式类完全影响子组件" class="headerlink" title="父组件的样式类完全影响子组件"></a>父组件的样式类完全影响子组件</h3><p>使用外部样式类可以让组件使用指定的组件外样式类，如果希望组件外样式类能够完全影响组件内部，可以将组件构造器中的 options.addGlobalClass 字段置为 true。这个特性从小程序基础库版本 2.2.3 开始支持。</p><pre><code class="js">/* CustomComp.js */export default class CustomComp extends Component {  static options = {    addGlobalClass: true  }  render () {    return &lt;View className=&quot;red-text&quot;&gt;这段文本的颜色由组件外的 class 决定&lt;/View&gt;  }}</code></pre><pre><code class="css">/* 组件外的样式定义 */.red-text {  color: red;}</code></pre><h3 id="在Taro中给子组件传递属性时，不能使用-…-拓展操作符"><a href="#在Taro中给子组件传递属性时，不能使用-…-拓展操作符" class="headerlink" title="在Taro中给子组件传递属性时，不能使用 … 拓展操作符"></a>在Taro中给子组件传递属性时，不能使用 … 拓展操作符</h3><pre><code class="js">const props = {firstName: &#39;Plus&#39;, lastName: &#39;Second&#39;}return &lt;Greeting {...props} /&gt; //错误return &lt;Greeting firstName=&quot;Plus&quot; lastName=&quot;Second&quot; /&gt; //正确</code></pre><h3 id="在Taro中如何阻止事件冒泡"><a href="#在Taro中如何阻止事件冒泡" class="headerlink" title="在Taro中如何阻止事件冒泡"></a>在Taro中如何阻止事件冒泡</h3><p>在 Taro 中你不能使用 <code>catchEvent</code> 的方式阻止事件冒泡。你必须明确的使用 <code>e.stopPropagation</code>。例如，阻止事件冒泡你可以这样写：</p><pre><code class="js">class Toggle extends Component {  constructor (props) {    super(props)    this.state = {isToggleOn: true}  }  onClick = (e) =&gt; {    e.stopPropagation()    this.setState(prevState =&gt; ({      isToggleOn: !prevState.isToggleOn    }))  }  render () {    return (      &lt;button onClick={this.onClick}&gt;        {this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;}      &lt;/button&gt;    )  }}</code></pre><h3 id="Taro中事件处理的传参方式"><a href="#Taro中事件处理的传参方式" class="headerlink" title="Taro中事件处理的传参方式"></a>Taro中事件处理的传参方式</h3><p>1.使用 <code>bind</code> 方式向监听函数传参，在类组件中定义的监听函数，事件对象 <code>e</code> 要排在所传递参数的后面。</p><pre><code class="js">class Popper extends Component {  constructor () {    super(...arguments)    this.state = { name:&#39;Hello world!&#39; }  }  // 你可以通过 bind 传入多个参数  preventPop (name, test, e) {    //事件对象 e 要放在最后    e.stopPropagation()  }  render () {    return &lt;Button onClick={this.preventPop.bind(this, this.state.name, &#39;test&#39;)}&gt;&lt;/Button&gt;  }}</code></pre><p>2.使用<code>匿名函数</code><br>直接写匿名函数不会打乱原有监听函数的参数顺序。<br>注意：在各小程序端，使用匿名函数，尤其是在 <code>循环中</code> 使用匿名函数，比使用 <code>bind</code> 进行事件传参占用更大的内存，速度也会更慢。</p><pre><code class="js">class Popper extends Component {  constructor () {    super(...arguments)    this.state = { name: &#39;Hello world!&#39; }  }  render () {    const name = &#39;test&#39;    return (      &lt;Button onClick={(e) =&gt; {        e.stopPropagation()        this.setState({          name        })      }}&gt;        {this.state.name}      &lt;/Button&gt;    )  }}</code></pre><p>3.<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">柯里化</a></p><pre><code class="js">class Title extends Component{  handleClick = (index) =&gt; (e) =&gt; {    e.stopPropagation()    this.setState({      currentIndex: index    })  }  render() {    const { currentIndex } = this.props;    return (      {/* 调用 `this.handleClick(currentIndex)` 会返回一个函数，这个函数可以访问到 `currentIndex` 同时也能满足 `onClick` 的签名 */}      &lt;View onClick={this.handleClick(currentIndex)}&gt;      &lt;/View&gt;    )  } }</code></pre><p>4.函数式组件传递方式<br>在函数式组件中，事件传参可以传入<code>事件的引用</code>也可以传入<code>匿名函数</code>，以下是函数式组件配合 <code>useCallback</code> 的一个例子：</p><pre><code class="js">const App = () =&gt; {  const [c1, setC1] = useState(0);  const [c2, setC2] = useState(0);  const [c3, setC3] = useState(0);  const increment = c =&gt; c + 1  // 只有 useCallback 对应的 c1 或 c2 的值改变时，才会返回新的函数  const increment1 = useCallback(() =&gt; setC1(increment), [c1]);  const increment2 = useCallback(() =&gt; setC2(increment), [c2]);  return (&lt;View&gt;    &lt;Text&gt; Counter 1 is {c1} &lt;/Text&gt;    &lt;Text&gt; Counter 2 is {c2} &lt;/Text&gt;    &lt;Text&gt; Counter 3 is {c3} &lt;/Text&gt;    &lt;View&gt;      &lt;Button onClick={increment1}&gt;Increment Counter 1&lt;/Button&gt;      &lt;Button onClick={increment2}&gt;Increment Counter 2&lt;/Button&gt;      &lt;Button onClick={() =&gt; setC3(increment)}&gt;Increment Counter 3&lt;/Button&gt;    &lt;/View&gt;  &lt;/View&gt;)}</code></pre><p>5.任何组件的事件传递都要以 <code>on</code> 开头<br>在 v1.3.0-beta.0 之后，自定义组件间的事件传递可以不用 <code>on</code> 开头，但内置组件的事件依然是以 <code>on</code> 开头的，为了一致性我们仍然推荐你以 <code>on</code> 开头命名你的事件。</p><pre><code class="js">const element = &lt;View onClick={this.onTag} /&gt;const element2 = &lt;Input onFocus={this.onFocus} /&gt;const element3 = &lt;CustomElement onAnimationEnd={this.props.onAnimationEnd} /&gt;</code></pre><h3 id="Taro中巧用逻辑运算符-amp-amp-和-三元运算符-以及-枚举-来实现条件渲染"><a href="#Taro中巧用逻辑运算符-amp-amp-和-三元运算符-以及-枚举-来实现条件渲染" class="headerlink" title="Taro中巧用逻辑运算符 &amp;&amp; 和 三元运算符 以及 枚举 来实现条件渲染"></a>Taro中巧用逻辑运算符 &amp;&amp; 和 三元运算符 以及 枚举 来实现条件渲染</h3><pre><code class="js">class LoginStatus extends Component {  render () {    const isLoggedIn = this.props.isLoggedIn    return (      &lt;View&gt;        {isLoggedIn &amp;&amp; &lt;Text&gt;已登录&lt;/Text&gt;}        {!isLoggedIn &amp;&amp; &lt;Text&gt;未登录&lt;/Text&gt;}        {isLoggedIn            ? &lt;Text&gt;已登录&lt;/Text&gt;            : &lt;Text&gt;未登录&lt;/Text&gt;        }      &lt;/View&gt;    )  }}</code></pre><pre><code class="js">function Loading (props) {  const { loadingText, LOADING_STATUS, loadingStatus, onRetry } = props  return (    &lt;View className=&#39;loading-status&#39;&gt;      {        {          &#39;loading&#39;: loadingText,          &#39;fail&#39;: &lt;View onClick={onRetry}&gt; 加载失败, 点击重试 &lt;/View&gt;,          &#39;no-more&#39;: &#39;没有更多了&#39;        }[loadingStatus] /** loadingStatus 是 `loading`、`fail`、`no-more`  其中一种状态 **/      }    &lt;/View&gt;  )}</code></pre><h3 id="Taro中循环渲染-原生小程序组件-需要指定taroKeys"><a href="#Taro中循环渲染-原生小程序组件-需要指定taroKeys" class="headerlink" title="Taro中循环渲染 原生小程序组件 需要指定taroKeys"></a>Taro中循环渲染 原生小程序组件 需要指定taroKeys</h3><p><code>taroKey</code> 适用于循环渲染原生小程序组件，赋予每个元素唯一确定标识，转换为小程序的 <code>wx:key</code>。</p><pre><code class="js">const numbers = [...Array(100).keys()] // [0, 1, 2, ..., 98, 99]const listItems = numbers.map((number) =&gt; {  return (    // native component    &lt;g-list      taroKey={String(number)}      className=&#39;g-list&#39;    &gt;    我是第 {number + 1} 个数字    &lt;/g-list&gt;  )})</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Taro</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6/ES7 常用集锦</title>
    <link href="/2020/03/11/css/es6/"/>
    <url>/2020/03/11/css/es6/</url>
    
    <content type="html"><![CDATA[<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>A.使用Set处理数组去重和删除元素，Set是es6新增的一种数据结构，它和数组非常相似，但是成员的值都是唯一的，没有重复的值。提供4个语义化的API：<br>1.<code>add(value)</code>;添加某个值，返回Set结构本身。<br>2.<code>delete(value)</code>;删除某个值，返回一个布尔值，表示删除是否成功。<br>3.<code>has(value)</code>;返回一个布尔值，表示改值是否为Set的成员。<br>4.<code>clear()</code>;清除所有成员，没有返回值。</p><pre><code class="javascript">let arr= [1,2,3,4,4,5,5,5];let set = new Set(arr);console.log(...set); //1 2 3 4 5</code></pre><p>注意：这个方法对元素为对象的数组不奏效。Set判断元素是否重复的方法类似于<code>===</code>。</p><p>B.删除数组中指定的元素：</p><pre><code class="javascript">const arr = [1,2,3];//例如删除数组中值为2的元素const index = arr.indexOf(2);if(index != -1){    arr.splice(index,1);}console.log(arr); //[1,3]//使用setconst arr = [1,2,3];const set = new Set(arr);set.delete(2);arr = [...set];console.log(arr); //[1,3]</code></pre><p>C.使用<code>map()</code>方法和对象解构语法提取字段</p><pre><code class="javascript">let studentInfo = [    { name: &#39;Alice&#39;, age: 18, no: 2 },    { name: &#39;Bob&#39;, age: 16, no: 5 },    { name: &#39;Candy&#39;, age: 17, no: 3 },    { name: &#39;Den&#39;, age: 18, no: 4 },    { name: &#39;Eve&#39;, age: 16, no: 1 },]const nameList = studentInfo.map(({name}) =&gt; name);console.log(nameList); //[&quot;Alice&quot;, &quot;Bob&quot;, &quot;Candy&quot;, &quot;Den&quot;, &quot;Eve&quot;]</code></pre><p>D.使用<code>filter()</code>方法和对象解构语法过滤字段</p><pre><code class="javascript">let studentInfo = [    { name: &#39;Alice&#39;, age: 18, no: 2 },    { name: &#39;Bob&#39;, age: 16, no: 5 },    { name: &#39;Candy&#39;, age: 17, no: 3 },    { name: &#39;Den&#39;, age: 18, no: 4 },    { name: &#39;Eve&#39;, age: 16, no: 1 },]const newStudentInfo = studentInfo.filter(({age}) =&gt; age&gt;17);console.log(newStudentInfo); //[ { name: &#39;Alice&#39;, age: 18, no: 2 }, { name: &#39;Den&#39;, age: 18, no: 4 }]</code></pre><p>E.数组遍历使用<code>for in</code>,<code>forEach</code>,<code>for of</code></p><pre><code class="javascript">let studentInfo = [    { name: &#39;Alice&#39;, age: 18, no: 2 },    { name: &#39;Bob&#39;, age: 16, no: 5 },    { name: &#39;Candy&#39;, age: 17, no: 3 },    { name: &#39;Den&#39;, age: 18, no: 4 },    { name: &#39;Eve&#39;, age: 16, no: 1 },]for(let i in studentInfo) {    console.log(i);//下标    console.log(studentInfo[i]);}studentInfo.forEach((value,index,arr) =&gt; {    console.log(value);    console.log(index);    console.log(arr);})for(let i of studentInfo) {    console.log(i);//每一项的值 { name: &#39;Alice&#39;, age: 18, no: 2 }}</code></pre><p>F.最短的代码创建一个长度为6，每个值为8的数组</p><pre><code class="javascript">Array(6).fill(8); //[8, 8, 8, 8, 8, 8]</code></pre><p>更多详细参考：<a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">阮一峰大神</a></p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><pre><code class="javascript">//数组解构let [a, b, c] = [4, 5, 6]; //a=4,b=5,c=6//解构不成功其值为undefinedlet [a] = []; //a = undefinedlet [a, b] = [1];//b = undefined//对象解构let { a, b, c} = { b: &quot;aaa&quot;, a: &quot;bbb&quot; };//a = &quot;bbb&quot;//b = &quot;aaa&quot;//c = undefinedlet { a : b } = { a: &quot;aaa&quot;, c: &quot;bbb&quot; };//b = &quot;aaa&quot;//a  error: foo is not defined//a是匹配的模式，b才是变量。真正被赋值的是变量baz，而不是模式foo。//字符串解构const [a, b, c, d, e] = &#39;hello&#39;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot;//函数参数解构function add([a, b]){    return a + b;}add([1, 2]); // 3常见的用途// 1.交换变量的值let x = 1;let y = 2;[x, y] = [y, x];// 2.函数返回值// 返回一个数组function num() {return [1, 2, 3];}let [a, b, c] = num();// 返回一个对象function example() {    return {        a: 1,        b: 2    };}let { a, b } = example();// 3.解析json数据let json = {    id: 1,    status: 404,    data: [123, 456]};let { id, status, data: number } = json;console.log(id, status, number);// 1, 404, [123, 456]</code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>1.模板字符串<br>2.JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。<br>    1.<code>includes(target,[index])</code>：返回布尔值，表示是否找到了参数字符串。<br>    2.<code>startsWith(target,[index])</code>：返回布尔值，表示参数字符串是否在原字符串的头部。<br>    3.<code>endsWith(target,[index])</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。<br>    <code>target</code> 目标字符串，<code>index</code>可选参数 开始搜索的位置</p><pre><code class="javascript">let s = &#39;Hello world!&#39;;s.startsWith(&#39;Hello&#39;) // trues.endsWith(&#39;!&#39;) // trues.includes(&#39;o&#39;) // trues.startsWith(&#39;world&#39;, 6) // trues.endsWith(&#39;Hello&#39;, 5) // trues.includes(&#39;Hello&#39;, 6) // false</code></pre><p>3.<code>str.repeat(n)</code>方法 返回一个新字符串，表示将原字符串重复n次。 n可以是大于-1的数</p><pre><code class="javascript">let s = &quot;abc&quot;;s.repeat(3); //abcabcabc 参数为NaN 等同于 0s.repeat(-1) //RangeError 参数是负数或者Infinity，会报错。s.repeat(1.9) //abcabc 参数如果是小数，会被取整。s.repeat(-0.5) // &quot;&quot; 参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</code></pre><h3 id="ES5的类"><a href="#ES5的类" class="headerlink" title="ES5的类"></a>ES5的类</h3><p>1.构造函数 实例属性和方法</p><pre><code class="javascript">function Person() {    this.name = &quot;tom&quot;;    this.age = 20;    this.speak = function(){        console.log(this.name + &#39;:&#39; + this.age);    }}let p = new Person();console.log(p.name); //tomp.speak(); // tom:20</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>ES7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 常用集锦</title>
    <link href="/2020/03/11/js/js/"/>
    <url>/2020/03/11/js/js/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串基本操作"><a href="#字符串基本操作" class="headerlink" title="字符串基本操作"></a>字符串基本操作</h3><p>参考链接：<a href="https://www.jb51.net/article/97915.htm" target="_blank" rel="noopener">字符串操作</a></p><h3 id="数组基本操作"><a href="#数组基本操作" class="headerlink" title="数组基本操作"></a>数组基本操作</h3><p>参考链接：<a href="http://www.cnblogs.com/blogs-8888/p/6518683.html" target="_blank" rel="noopener">数组操作</a></p><h3 id="字符串去空格"><a href="#字符串去空格" class="headerlink" title="字符串去空格"></a>字符串去空格</h3><pre><code class="javascript">let trimSpace = function(str,is_global){    let result;    result = str.replace(/(^\s+)|(\s+$)/g,&quot;&quot;);    if(is_global &amp;&amp; is_global.toLowerCase()==&quot;g&quot;){        result = result.replace(/\s/g,&quot;&quot;);    }    return result;}</code></pre><h3 id="获取url参数值"><a href="#获取url参数值" class="headerlink" title="获取url参数值"></a>获取url参数值</h3><pre><code class="javascript">function getQueryVal(url){    let url = url || &#39;&#39;;    let arr = (url.split(&quot;?&quot;)[1] || url || &#39;&#39;).split(&quot;&amp;&quot;);    let o={};    if(arr[0]==&#39;&#39;){return o}    arr.forEach(function(x){        let ar=x.split(&quot;=&quot;);        o[ar[0]]=ar[1]    });    return o}eg: console.log(getQueryVal(&quot;http://192.168.28.50.9090/#/twitterInfo?isNeed=0&amp;userType=c&quot;));//{isNeed: &quot;0&quot;, userType: &quot;c&quot;}</code></pre><h3 id="vue里面使用hash模式获取url参数值"><a href="#vue里面使用hash模式获取url参数值" class="headerlink" title="vue里面使用hash模式获取url参数值"></a>vue里面使用hash模式获取url参数值</h3><pre><code class="javascript">/** *  name [参数名称] */let getHashString = function(name) {    let url = window.location.hash.substr(1);    let theRequest = {};    if(url.indexOf(&quot;?&quot;)&gt;-1){        let  strs = url.split(&quot;?&quot;)[1].split(&quot;&amp;&quot;);        for(let i = 0; i &lt; strs.length; i ++) {            theRequest[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]);        }        for(let j in theRequest){            if(name==j){                return theRequest[j];            }        }      }else {        return null;    }};eg:  console.log(getHashString(&quot;userType&quot;));// c</code></pre><h3 id="history模式获取url参数值"><a href="#history模式获取url参数值" class="headerlink" title="history模式获取url参数值"></a>history模式获取url参数值</h3><pre><code class="javascript">/** * name [参数名称] */let getQueryString = function(name) {    let reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);    let r = window.location.search.substr(1).match(reg);    if(r!=null)return  unescape(r[2]); return null;};eg: 当前的url是http://localhost:4000/home/index.html?caseid=123&amp;idx=1console.log(getQueryString(&quot;caseid&quot;));// 123</code></pre><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><pre><code class="javascript">function debounce(func,delay){    let timer = null;    return function(...args){        if(timer){            clearTimeout(timer);        }        timer = setTimeout(()=&gt;{            func.apply(this,args);        },delay)            }}// 测试function show(){    console.log(&#39;hello...&#39;);}let func = debounce(show,3000);// 调用func(); func(); func(); func(); func(); // 连续调用时，没有超过三秒是不会有任何输出的//hello...</code></pre><h3 id="Async-Await是Generator和Promise的组合，完全解决了基于回调的异步"><a href="#Async-Await是Generator和Promise的组合，完全解决了基于回调的异步" class="headerlink" title="Async/Await是Generator和Promise的组合，完全解决了基于回调的异步"></a>Async/Await是Generator和Promise的组合，完全解决了基于回调的异步</h3><pre><code class="javascript">let getKeyPromise = function () {    return new Promsie(function (resolve, reject) {        $.ajax({            type: &#39;get&#39;,            url: &#39;http://localhost:3000/apiKey&#39;,            success: function (data) {            let key = data;            resolve(key);                     },            error: function (err) {                reject(err);            }        });    });};let getTokenPromise = function (key) {    return new Promsie(function (resolve, reject) {        $.ajax({            type: &#39;get&#39;,            url: &#39;http://localhost:3000/getToken&#39;,            data: {                key: key            },            success: function (data) {                resolve(data);                     },            error: function (err) {                reject(err);            }        });    });};let getDataPromise = function (data) {    let token = data.token;    let userId = data.userId;    return new Promsie(function (resolve, reject) {        $.ajax({            type: &#39;get&#39;,            url: &#39;http://localhost:3000/getData&#39;,            data: {                token: token,                userId: userId            },            success: function (data) {                resolve(data);                     },            error: function (err) {                reject(err);            }        });    });};async function main () {    let key = await getKeyPromise();    let loginData = await getTokenPromise(key);    let busiData = await getDataPromise(loginData);    console.log(&#39;数据：&#39;, busiData);}main();console.log(&#39;123&#39;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 常用集锦</title>
    <link href="/2020/03/11/vue/vue/"/>
    <url>/2020/03/11/vue/vue/</url>
    
    <content type="html"><![CDATA[<h3 id="v-text-v-html-中如何使用过滤器"><a href="#v-text-v-html-中如何使用过滤器" class="headerlink" title="v-text/v-html 中如何使用过滤器"></a>v-text/v-html 中如何使用过滤器</h3><p>Vue2.x 不再支持在 <code>v-html</code> 中使用过滤器Vue2.x 的过滤器现在只能应用在“Mustache”语法 (双大括号) 的文本插值 和 <code>v-bind</code> 中。<br>如果要使用采用如下方式：</p><p><code>v-html=&quot;$options.filters.过滤器名称(需要过滤的内容,[过滤器需要的参数])&quot;</code></p><h3 id="在Vue组件中动态生成的DOM类名样式不作用-deep"><a href="#在Vue组件中动态生成的DOM类名样式不作用-deep" class="headerlink" title="在Vue组件中动态生成的DOM类名样式不作用-/deep/"></a>在Vue组件中动态生成的DOM类名样式不作用-/deep/</h3><pre><code class="html">&lt;template&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;div v-text=&quot;text&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name:&quot;app&quot;,        data(){            return {                text:&lt;span class=&quot;red&quot;&gt;红色&lt;/span&gt;            }         }    }&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;    /deep/ .red{        color:red;    }&lt;/style&gt;</code></pre><p>注意：/deep/ 只是在最外层使用，不要嵌套使用。<br>参考文档：<a href="https://vue-loader.vuejs.org/guide/scoped-css.html" target="_blank" rel="noopener">deep</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 常用集锦</title>
    <link href="/2020/03/11/css/css/"/>
    <url>/2020/03/11/css/css/</url>
    
    <content type="html"><![CDATA[<h3 id="多行文本垂直居中"><a href="#多行文本垂直居中" class="headerlink" title="多行文本垂直居中"></a>多行文本垂直居中</h3><p>父元素 设置：display:table,height:500px;<br>子元素 设置：dispaly:table-cell;vertical-align:middle;</p><pre><code class="html">&lt;div class=&quot;parent&quot;&gt;&lt;span class=&quot;child&quot;&gt;    &lt;img src=&quot;&quot;/&gt;    &lt;span&gt;垂直居中&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;</code></pre><pre><code class="css">.parent {    display:table,height:500px}.child {    dispaly:table-cell;vertical-align:middle}</code></pre><h3 id="webkit表单输入框placeholder的颜色值改变"><a href="#webkit表单输入框placeholder的颜色值改变" class="headerlink" title="webkit表单输入框placeholder的颜色值改变"></a>webkit表单输入框placeholder的颜色值改变</h3><pre><code class="css">如果想要默认的颜色显示红色，代码如下：input::-webkit-input-placeholder{color:red;}如果想要用户点击变为蓝色，代码如下：input:focus::-webkit-input-placeholder{color:blue;}</code></pre><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>word-break:break-all;只对英文起作用，以字母作为换行依据<br>word-wrap:break-word;只对英文起作用，以单词作为换行依据<br>white-space:pre-wrap;只对中文起作用，强制换行<br>white-space:nowrap;都起作用，强制不换行</p><p>white-space:nowrap;<br>overflow:hidden;<br>text-overflow:ellipsis;<br>width:500px;<br>不换行超出部分显示…</p><p>常用自定义类名：</p><pre><code class="css">/*自动换行*/.cut-text {    word-break:break-all;    word-wrap:break-word;}/*强制不换行*/.no-cut-text {    white-space:nowrap;}/*英文换行*/.en-cut-text  {    word-break:break-all;}/*超出显示...*/.text-dots {    width:500px;    text-overflow:ellipsis;    overflow:hidden;    white-space:nowrap;}/*超出两行文本显示...*/ /*必须指定width*/.text2LineRestrist {    overflow: hidden;    text-overflow:ellipsis;    display:-webkit-box;    -webkit-box-orient:vertical;    -webkit-line-clamp:2;}/*超出三行文本显示...*/ /*必须指定width*/.text3LineRestrist {    overflow: hidden;    text-overflow:ellipsis;    display:-webkit-box;    -webkit-box-orient:vertical;    -webkit-line-clamp:3;}</code></pre><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><pre><code class="css">.clearfix {zoom:1;}.clearfix::after,.clearfix::before{    content:&quot;&quot;;    display:block;    clear: both;    visibility: hidden;    height:0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
