<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ES6/ES7 常用集锦</title>
    <link href="/2020/03/11/es6/"/>
    <url>/2020/03/11/es6/</url>
    
    <content type="html"><![CDATA[<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>A.使用Set处理数组去重和删除元素，Set是es6新增的一种数据结构，它和数组非常相似，但是成员的值都是唯一的，没有重复的值。提供4个语义化的API：<br>1.<code>add(value)</code>;添加某个值，返回Set结构本身。<br>2.<code>delete(value)</code>;删除某个值，返回一个布尔值，表示删除是否成功。<br>3.<code>has(value)</code>;返回一个布尔值，表示改值是否为Set的成员。<br>4.<code>clear()</code>;清除所有成员，没有返回值。</p><pre><code class="javascript">let arr= [1,2,3,4,4,5,5,5];let set = new Set(arr);console.log(...set); //1 2 3 4 5</code></pre><p>注意：这个方法对元素为对象的数组不奏效。Set判断元素是否重复的方法类似于<code>===</code>。</p><p>B.删除数组中指定的元素：</p><pre><code class="javascript">const arr = [1,2,3];//例如删除数组中值为2的元素const index = arr.indexOf(2);if(index != -1){    arr.splice(index,1);}console.log(arr); //[1,3]//使用setconst arr = [1,2,3];const set = new Set(arr);set.delete(2);arr = [...set];console.log(arr); //[1,3]</code></pre><p>C.使用<code>map()</code>方法和对象解构语法提取字段</p><pre><code class="javascript">let studentInfo = [    { name: &#39;Alice&#39;, age: 18, no: 2 },    { name: &#39;Bob&#39;, age: 16, no: 5 },    { name: &#39;Candy&#39;, age: 17, no: 3 },    { name: &#39;Den&#39;, age: 18, no: 4 },    { name: &#39;Eve&#39;, age: 16, no: 1 },]const nameList = studentInfo.map(({name}) =&gt; name);console.log(nameList); //[&quot;Alice&quot;, &quot;Bob&quot;, &quot;Candy&quot;, &quot;Den&quot;, &quot;Eve&quot;]</code></pre><p>D.使用<code>filter()</code>方法和对象解构语法过滤字段</p><pre><code class="javascript">let studentInfo = [    { name: &#39;Alice&#39;, age: 18, no: 2 },    { name: &#39;Bob&#39;, age: 16, no: 5 },    { name: &#39;Candy&#39;, age: 17, no: 3 },    { name: &#39;Den&#39;, age: 18, no: 4 },    { name: &#39;Eve&#39;, age: 16, no: 1 },]const newStudentInfo = studentInfo.filter(({age}) =&gt; age&gt;17);console.log(newStudentInfo); //[ { name: &#39;Alice&#39;, age: 18, no: 2 }, { name: &#39;Den&#39;, age: 18, no: 4 }]</code></pre><p>E.数组遍历使用<code>for in</code>,<code>forEach</code>,<code>for of</code></p><pre><code class="javascript">let studentInfo = [    { name: &#39;Alice&#39;, age: 18, no: 2 },    { name: &#39;Bob&#39;, age: 16, no: 5 },    { name: &#39;Candy&#39;, age: 17, no: 3 },    { name: &#39;Den&#39;, age: 18, no: 4 },    { name: &#39;Eve&#39;, age: 16, no: 1 },]for(let i in studentInfo) {    console.log(i);//下标    console.log(studentInfo[i]);}studentInfo.forEach((value,index,arr) =&gt; {    console.log(value);    console.log(index);    console.log(arr);})for(let i of studentInfo) {    console.log(i);//每一项的值 { name: &#39;Alice&#39;, age: 18, no: 2 }}</code></pre><p>F.最短的代码创建一个长度为6，每个值为8的数组</p><pre><code class="javascript">Array(6).fill(8); //[8, 8, 8, 8, 8, 8]</code></pre><p>更多详细参考：<a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">阮一峰大神</a></p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><pre><code class="javascript">//数组解构let [a, b, c] = [4, 5, 6]; //a=4,b=5,c=6//解构不成功其值为undefinedlet [a] = []; //a = undefinedlet [a, b] = [1];//b = undefined//对象解构let { a, b, c} = { b: &quot;aaa&quot;, a: &quot;bbb&quot; };//a = &quot;bbb&quot;//b = &quot;aaa&quot;//c = undefinedlet { a : b } = { a: &quot;aaa&quot;, c: &quot;bbb&quot; };//b = &quot;aaa&quot;//a  error: foo is not defined//a是匹配的模式，b才是变量。真正被赋值的是变量baz，而不是模式foo。//字符串解构const [a, b, c, d, e] = &#39;hello&#39;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot;//函数参数解构function add([a, b]){    return a + b;}add([1, 2]); // 3常见的用途// 1.交换变量的值let x = 1;let y = 2;[x, y] = [y, x];// 2.函数返回值// 返回一个数组function num() {return [1, 2, 3];}let [a, b, c] = num();// 返回一个对象function example() {    return {        a: 1,        b: 2    };}let { a, b } = example();// 3.解析json数据let json = {    id: 1,    status: 404,    data: [123, 456]};let { id, status, data: number } = json;console.log(id, status, number);// 1, 404, [123, 456]</code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>1.模板字符串<br>2.JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。<br>    1.<code>includes(target,[index])</code>：返回布尔值，表示是否找到了参数字符串。<br>    2.<code>startsWith(target,[index])</code>：返回布尔值，表示参数字符串是否在原字符串的头部。<br>    3.<code>endsWith(target,[index])</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。<br>    <code>target</code> 目标字符串，<code>index</code>可选参数 开始搜索的位置</p><pre><code class="javascript">let s = &#39;Hello world!&#39;;s.startsWith(&#39;Hello&#39;) // trues.endsWith(&#39;!&#39;) // trues.includes(&#39;o&#39;) // trues.startsWith(&#39;world&#39;, 6) // trues.endsWith(&#39;Hello&#39;, 5) // trues.includes(&#39;Hello&#39;, 6) // false</code></pre><p>3.<code>str.repeat(n)</code>方法 返回一个新字符串，表示将原字符串重复n次。 n可以是大于-1的数</p><pre><code class="javascript">let s = &quot;abc&quot;;s.repeat(3); //abcabcabc 参数为NaN 等同于 0s.repeat(-1) //RangeError 参数是负数或者Infinity，会报错。s.repeat(1.9) //abcabc 参数如果是小数，会被取整。s.repeat(-0.5) // &quot;&quot; 参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</code></pre><h3 id="ES5的类"><a href="#ES5的类" class="headerlink" title="ES5的类"></a>ES5的类</h3><p>1.构造函数 实例属性和方法</p><pre><code class="javascript">function Person() {    this.name = &quot;tom&quot;;    this.age = 20;    this.speak = function(){        console.log(this.name + &#39;:&#39; + this.age);    }}let p = new Person();console.log(p.name); //tomp.speak(); // tom:20</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>ES7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavasSript 常用集锦</title>
    <link href="/2020/03/11/js/"/>
    <url>/2020/03/11/js/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串基本操作"><a href="#字符串基本操作" class="headerlink" title="字符串基本操作"></a>字符串基本操作</h3><p>参考链接：<a href="https://www.jb51.net/article/97915.htm" target="_blank" rel="noopener">字符串操作</a></p><h3 id="数组基本操作"><a href="#数组基本操作" class="headerlink" title="数组基本操作"></a>数组基本操作</h3><p>参考链接：<a href="http://www.cnblogs.com/blogs-8888/p/6518683.html" target="_blank" rel="noopener">数组操作</a></p><h3 id="字符串去空格"><a href="#字符串去空格" class="headerlink" title="字符串去空格"></a>字符串去空格</h3><pre><code class="javascript">let trimSpace = function(str,is_global){    let result;    result = str.replace(/(^\s+)|(\s+$)/g,&quot;&quot;);    if(is_global &amp;&amp; is_global.toLowerCase()==&quot;g&quot;){        result = result.replace(/\s/g,&quot;&quot;);    }    return result;}</code></pre><h3 id="获取url参数值"><a href="#获取url参数值" class="headerlink" title="获取url参数值"></a>获取url参数值</h3><pre><code class="javascript">function getQueryVal(url){    let url = url || &#39;&#39;;    let arr = (url.split(&quot;?&quot;)[1] || url || &#39;&#39;).split(&quot;&amp;&quot;);    let o={};    if(arr[0]==&#39;&#39;){return o}    arr.forEach(function(x){        let ar=x.split(&quot;=&quot;);        o[ar[0]]=ar[1]    });    return o}eg: console.log(getQueryVal(&quot;http://192.168.28.50.9090/#/twitterInfo?isNeed=0&amp;userType=c&quot;));//{isNeed: &quot;0&quot;, userType: &quot;c&quot;}</code></pre><h3 id="vue里面使用hash模式获取url参数值"><a href="#vue里面使用hash模式获取url参数值" class="headerlink" title="vue里面使用hash模式获取url参数值"></a>vue里面使用hash模式获取url参数值</h3><pre><code class="javascript">/** *  name [参数名称] */let getHashString = function(name) {    let url = window.location.hash.substr(1);    let theRequest = {};    if(url.indexOf(&quot;?&quot;)&gt;-1){        let  strs = url.split(&quot;?&quot;)[1].split(&quot;&amp;&quot;);        for(let i = 0; i &lt; strs.length; i ++) {            theRequest[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]);        }        for(let j in theRequest){            if(name==j){                return theRequest[j];            }        }      }else {        return null;    }};eg:  console.log(getHashString(&quot;userType&quot;));// c</code></pre><h3 id="history模式获取url参数值"><a href="#history模式获取url参数值" class="headerlink" title="history模式获取url参数值"></a>history模式获取url参数值</h3><pre><code class="javascript">/** * name [参数名称] */let getQueryString = function(name) {    let reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);    let r = window.location.search.substr(1).match(reg);    if(r!=null)return  unescape(r[2]); return null;};eg: 当前的url是http://localhost:4000/home/index.html?caseid=123&amp;idx=1console.log(getQueryString(&quot;caseid&quot;));// 123</code></pre><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><pre><code class="javascript">function debounce(func,delay){    let timer = null;    return function(...args){        if(timer){            clearTimeout(timer);        }        timer = setTimeout(()=&gt;{            func.apply(this,args);        },delay)            }}// 测试function show(){    console.log(&#39;hello...&#39;);}let func = debounce(show,3000);// 调用func(); func(); func(); func(); func(); // 连续调用时，没有超过三秒是不会有任何输出的//hello...</code></pre><h3 id="Async-Await是Generator和Promise的组合，完全解决了基于回调的异步"><a href="#Async-Await是Generator和Promise的组合，完全解决了基于回调的异步" class="headerlink" title="Async/Await是Generator和Promise的组合，完全解决了基于回调的异步"></a>Async/Await是Generator和Promise的组合，完全解决了基于回调的异步</h3><pre><code class="javascript">let getKeyPromise = function () {    return new Promsie(function (resolve, reject) {        $.ajax({            type: &#39;get&#39;,            url: &#39;http://localhost:3000/apiKey&#39;,            success: function (data) {            let key = data;            resolve(key);                     },            error: function (err) {                reject(err);            }        });    });};let getTokenPromise = function (key) {    return new Promsie(function (resolve, reject) {        $.ajax({            type: &#39;get&#39;,            url: &#39;http://localhost:3000/getToken&#39;,            data: {                key: key            },            success: function (data) {                resolve(data);                     },            error: function (err) {                reject(err);            }        });    });};let getDataPromise = function (data) {    let token = data.token;    let userId = data.userId;    return new Promsie(function (resolve, reject) {        $.ajax({            type: &#39;get&#39;,            url: &#39;http://localhost:3000/getData&#39;,            data: {                token: token,                userId: userId            },            success: function (data) {                resolve(data);                     },            error: function (err) {                reject(err);            }        });    });};async function main () {    let key = await getKeyPromise();    let loginData = await getTokenPromise(key);    let busiData = await getDataPromise(loginData);    console.log(&#39;数据：&#39;, busiData);}main();console.log(&#39;123&#39;);</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 常用集锦</title>
    <link href="/2020/03/11/vue/"/>
    <url>/2020/03/11/vue/</url>
    
    <content type="html"><![CDATA[<h3 id="v-text-v-html-中如何使用过滤器"><a href="#v-text-v-html-中如何使用过滤器" class="headerlink" title="v-text/v-html 中如何使用过滤器"></a>v-text/v-html 中如何使用过滤器</h3><p>Vue2.x 不再支持在 <code>v-html</code> 中使用过滤器Vue2.x 的过滤器现在只能应用在“Mustache”语法 (双大括号) 的文本插值 和 <code>v-bind</code> 中。<br>如果要使用采用如下方式：</p><p><code>v-html=&quot;$options.filters.过滤器名称(需要过滤的内容,[过滤器需要的参数])&quot;</code></p><h3 id="在Vue组件中动态生成的DOM类名样式不作用-deep"><a href="#在Vue组件中动态生成的DOM类名样式不作用-deep" class="headerlink" title="在Vue组件中动态生成的DOM类名样式不作用-/deep/"></a>在Vue组件中动态生成的DOM类名样式不作用-/deep/</h3><pre><code class="html">&lt;template&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;div v-text=&quot;text&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name:&quot;app&quot;,        data(){            return {                text:&lt;span class=&quot;red&quot;&gt;红色&lt;/span&gt;            }         }    }&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;    /deep/ .red{        color:red;    }&lt;/style&gt;</code></pre><p>注意：/deep/ 只是在最外层使用，不要嵌套使用。<br>参考文档：<a href="https://vue-loader.vuejs.org/guide/scoped-css.html" target="_blank" rel="noopener">deep</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 常用集锦</title>
    <link href="/2020/03/11/css/"/>
    <url>/2020/03/11/css/</url>
    
    <content type="html"><![CDATA[<h3 id="多行文本垂直居中"><a href="#多行文本垂直居中" class="headerlink" title="多行文本垂直居中"></a>多行文本垂直居中</h3><p>父元素 设置：display:table,height:500px;<br>子元素 设置：dispaly:table-cell;vertical-align:middle;</p><pre><code class="html">&lt;div class=&quot;parent&quot;&gt;&lt;span class=&quot;child&quot;&gt;    &lt;img src=&quot;&quot;/&gt;    &lt;span&gt;垂直居中&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;</code></pre><pre><code class="css">.parent {    display:table,height:500px}.child {    dispaly:table-cell;vertical-align:middle}</code></pre><h3 id="webkit表单输入框placeholder的颜色值改变"><a href="#webkit表单输入框placeholder的颜色值改变" class="headerlink" title="webkit表单输入框placeholder的颜色值改变"></a>webkit表单输入框placeholder的颜色值改变</h3><pre><code class="css">如果想要默认的颜色显示红色，代码如下：input::-webkit-input-placeholder{color:red;}如果想要用户点击变为蓝色，代码如下：input:focus::-webkit-input-placeholder{color:blue;}</code></pre><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>word-break:break-all;只对英文起作用，以字母作为换行依据<br>word-wrap:break-word;只对英文起作用，以单词作为换行依据<br>white-space:pre-wrap;只对中文起作用，强制换行<br>white-space:nowrap;都起作用，强制不换行</p><p>white-space:nowrap;<br>overflow:hidden;<br>text-overflow:ellipsis;<br>width:500px;<br>不换行超出部分显示…</p><p>常用自定义类名：</p><pre><code class="css">/*自动换行*/.cut-text {    word-break:break-all;    word-wrap:break-word;}/*强制不换行*/.no-cut-text {    white-space:nowrap;}/*英文换行*/.en-cut-text  {    word-break:break-all;}/*超出显示...*/.text-dots {    width:500px;    text-overflow:ellipsis;    overflow:hidden;    white-space:nowrap;}/*超出两行文本显示...*/ /*必须指定width*/.text2LineRestrist {    overflow: hidden;    text-overflow:ellipsis;    display:-webkit-box;    -webkit-box-orient:vertical;    -webkit-line-clamp:2;}/*超出三行文本显示...*/ /*必须指定width*/.text3LineRestrist {    overflow: hidden;    text-overflow:ellipsis;    display:-webkit-box;    -webkit-box-orient:vertical;    -webkit-line-clamp:3;}</code></pre><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><pre><code class="css">.clearfix {zoom:1;}.clearfix::after,.clearfix::before{    content:&quot;&quot;;    display:block;    clear: both;    visibility: hidden;    height:0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
