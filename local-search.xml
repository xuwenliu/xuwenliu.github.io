<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Markdown语法</title>
    <link href="/2020/05/15/markdown/"/>
    <url>/2020/05/15/markdown/</url>
    
    <content type="html"><![CDATA[<h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><ul><li>使用 # 号标记 </li></ul><pre><code class="js"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><ul><li>使用 = 和 - 标记一级和二级标</li></ul><pre><code class="js">我展示的是一级标题=================我展示的是二级标题-----------------</code></pre><p>效果如下：</p><h1 id="我展示的是一级标题"><a href="#我展示的是一级标题" class="headerlink" title="我展示的是一级标题"></a>我展示的是一级标题</h1><h2 id="我展示的是二级标题"><a href="#我展示的是二级标题" class="headerlink" title="我展示的是二级标题"></a>我展示的是二级标题</h2><h3 id="2-格式"><a href="#2-格式" class="headerlink" title="2.格式"></a>2.格式</h3><ul><li><p>字体</p><pre><code class="js">  *斜体文本*  _斜体文本_  **粗体文本**  __粗体文本__  ***粗斜体文本***  ___粗斜体文本___</code></pre></li></ul><pre><code>效果如下：*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><ul><li><p>分割线</p><p>  你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre><code class="js">  ***  * * *  *****  - - -  ----------</code></pre></li></ul><pre><code>效果如下：**** * ******- - -----------</code></pre><ul><li><p>删除线</p><p>  如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <strong>~~</strong> 即可</p><pre><code>  ~~删除线~~</code></pre></li></ul><pre><code>效果如下：~~删除线~~</code></pre><ul><li><p>下划线</p><p>  下划线可以通过 HTML 的 <code>&lt;u&gt;</code> 标签来实现：</p><pre><code>  &lt;u&gt;带下划线文本&lt;/u&gt;</code></pre></li></ul><pre><code>效果如下：&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><ul><li><p>脚注</p><p>  脚注是对文本的补充说明。</p><pre><code class="js">  [^要注明的文本]</code></pre></li></ul><pre><code>```创建脚注格式类似这样 [^百度]。[^百度]: 百度一下```效果如下：创建脚注格式类似这样 [^百度]。</code></pre><h3 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h3><ul><li><p>无序列表使用星号<code>*</code>、加号<code>+</code>或是减号<code>-</code>作为列表标记：</p><pre><code class="js">  * 第一项  * 第二项  * 第三项  + 第一项  + 第二项  + 第三项</code></pre></li></ul><pre><code>- 第一项- 第二项- 第三项```效果如下：* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><ul><li><p>有序列表使用数字并加上<code>.</code>号来表示，如：</p><pre><code class="js">  1. 第一项  2. 第二项  3. 第三项</code></pre></li></ul><pre><code>效果如下：1. 第一项2. 第二项3. 第三项</code></pre><ul><li><p>列表嵌套</p><p>  列表嵌套只需在子列表中的选项添加四个空格即可：</p><pre><code class="js">  1. 第一项：      - 第一项嵌套的第一个元素      - 第一项嵌套的第二个元素  2. 第二项：      - 第二项嵌套的第一个元素      - 第二项嵌套的第二个元素</code></pre></li></ul><pre><code>效果如下：1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><h3 id="4-区块"><a href="#4-区块" class="headerlink" title="4.区块"></a>4.区块</h3><p>Markdown 区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p><pre><code class="js">&gt; javascript&gt; python&gt; vue</code></pre><p>效果如下：</p><blockquote><p>javascript<br>python<br>vue</p></blockquote><p>另外区块是可以嵌套的，一个 <strong>&gt;</strong> 符号是最外层，两个 <strong>&gt;</strong> 符号是第一层嵌套，以此类推：</p><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><p>效果如下：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><p>列表和区块是可以相互组合使用的</p><h3 id="5-代码"><a href="#5-代码" class="headerlink" title="5.代码"></a>5.代码</h3><ul><li>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（<strong>`</strong>），例如：</li></ul><pre><code>`printf()` 函数</code></pre><p>效果如下：</p><p><code>printf()</code> 函数</p><ul><li>用``` 包裹一段代码，并指定一种语言（也可以不指定）：</li></ul><pre><code class="js">```js$(document).ready(function () {    alert(&#39;1&#39;);});```</code></pre><p>效果如下：</p><pre><code class="js">$(document).ready(function () {    alert(&#39;1&#39;);});</code></pre><h3 id="6-链接"><a href="#6-链接" class="headerlink" title="6.链接"></a>6.链接</h3><ul><li>链接使用方法如下：</li></ul><pre><code>[链接名称](链接地址)或者&lt;链接地址&gt;</code></pre><p>例如：</p><pre><code>这是一个链接 [百度一下](https://www.baidu.com)</code></pre><p>效果如下：</p><p>这是一个链接 <a href="https://www.baidu.com" target="_blank" rel="noopener">百度一下</a></p><ul><li><p>直接使用链接地址：</p><pre><code>  &lt;https://www.baidu.com&gt;</code></pre></li></ul><pre><code>效果如下：&lt;https://www.baidu.com&gt;</code></pre><ul><li><p>高级链接</p><p>  我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><pre><code class="js">  这个链接用 1 作为网址变量 [百度][1]  这个链接用 runoob 作为网址变量 [京东][jingdong]</code></pre></li></ul><pre><code>效果如下：这个链接用 1 作为网址变量 [百度][1]这个链接用 runoob 作为网址变量 [京东][jingdong]</code></pre><h3 id="7-图片"><a href="#7-图片" class="headerlink" title="7.图片"></a>7.图片</h3><pre><code>![alt 属性文本](图片地址 &quot;可选标题&quot;)</code></pre><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li></ul><pre><code>![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;开开心心&quot;)</code></pre><p>效果如下：</p><p><img src="http://static.runoob.com/images/runoob-logo.png" srcset="/img/loading.gif" alt="RUNOOB 图标"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" srcset="/img/loading.gif" alt="RUNOOB 图标" title="开开心心"></p><h4 id="指定高度与宽度"><a href="#指定高度与宽度" class="headerlink" title="指定高度与宽度"></a>指定高度与宽度</h4><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code>标签。</p><pre><code>&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50px&quot;&gt;</code></pre><p>效果如下：</p><img src="http://static.runoob.com/images/runoob-logo.png" srcset="/img/loading.gif" width="50px"><h3 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h3><ul><li>Markdown 制作表格使用 <code>|</code>来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。</li></ul><pre><code>|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>效果如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><ul><li><p>对齐方式</p><ul><li><p><strong>-:</strong> 设置内容和标题栏居右对齐。</p></li><li><p><strong>:-</strong> 设置内容和标题栏居左对齐。</p></li><li><p><strong>:-:</strong> 设置内容和标题栏居中对齐。</p><pre><code>  | 左对齐 | 右对齐 | 居中对齐 |  | :-----| ----: | :----: |  | 单元格 | 单元格 | 单元格 |  | 单元格 | 单元格 | 单元格 |</code></pre></li></ul></li></ul><pre><code>    效果如下：    | 左对齐 | 右对齐 | 居中对齐 |    | :----- | -----: | :------: |    | 单元格 | 单元格 |  单元格  |    | 单元格 | 单元格 |  单元格  |</code></pre><h3 id="9-视频-音频"><a href="#9-视频-音频" class="headerlink" title="9.视频/音频"></a>9.视频/音频</h3><p>直接使用html标签 <code>video</code>和<code>audio</code></p><pre><code class="html">&lt;video id=&quot;video&quot;        controls=&quot;&quot;        preload=&quot;none&quot;        poster=&quot;http://img.blog.fandong.me/2017-08-26-Markdown-Advance-Video.jpg&quot;&gt;      &lt;source id=&quot;mp4&quot;               src=&quot;http://img.blog.fandong.me/2017-08-26-Markdown-Advance-Video.mp4&quot;               type=&quot;video/mp4&quot;&gt;&lt;/video&gt;</code></pre><video id="video" controls="" preload="none" poster="http://img.blog.fandong.me/2017-08-26-Markdown-Advance-Video.jpg">      <source id="mp4" src="http://img.blog.fandong.me/2017-08-26-Markdown-Advance-Video.mp4" type="video/mp4">      </video><pre><code class="html">&lt;audio id=&quot;audio&quot; controls=&quot;&quot; preload=&quot;none&quot;&gt;      &lt;source id=&quot;mp3&quot; src=&quot;http://qiniu.cloud.fandong.me/Music_iP%E8%B5%B5%E9%9C%B2%20-%20%E7%A6%BB%E6%AD%8C%20%28Live%29.mp3&quot;&gt;      &lt;/audio&gt;</code></pre><p><audio id="audio" controls="" preload="none">       <source id="mp3" src="http://qiniu.cloud.fandong.me/Music_iP%E8%B5%B5%E9%9C%B2%20-%20%E7%A6%BB%E6%AD%8C%20%28Live%29.mp3">       </audio></p><h3 id="10-支持的-HTML-元素"><a href="#10-支持的-HTML-元素" class="headerlink" title="10.支持的 HTML 元素"></a>10.支持的 HTML 元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有<code>&lt;kbd&gt;</code> <code>&lt;b&gt;</code> <code>&lt;i&gt;</code> <code>&lt;em&gt;</code> <code>&lt;sup&gt;</code> <code>&lt;sub&gt;</code> <code>&lt;br&gt;</code>等 ，如：</p><pre><code class="html">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h3 id="11-转义"><a href="#11-转义" class="headerlink" title="11.转义"></a>11.转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><pre><code class="js">**文本加粗** \*\* 正常显示星号 \*\*</code></pre><p>效果如下：</p><p><strong>文本加粗</strong><br>** 正常显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   下划线{}  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><h3 id="12-公式和流程图、时序图-顺序图-、甘特图、逻辑图-这里不做介绍，平时用的少。要用就百度吧。"><a href="#12-公式和流程图、时序图-顺序图-、甘特图、逻辑图-这里不做介绍，平时用的少。要用就百度吧。" class="headerlink" title="12.公式和流程图、时序图(顺序图)、甘特图、逻辑图 这里不做介绍，平时用的少。要用就百度吧。"></a>12.公式和流程图、时序图(顺序图)、甘特图、逻辑图 这里不做介绍，平时用的少。要用就百度吧。</h3><h3 id="13-想在别的地方让别人给你的仓库Star的美好方式"><a href="#13-想在别的地方让别人给你的仓库Star的美好方式" class="headerlink" title="13.想在别的地方让别人给你的仓库Star的美好方式"></a>13.想在别的地方让别人给你的仓库Star的美好方式</h3><p>src 属性中的 <code>https://ghbtns.com/github-btn.html</code> 是固定的</p><table><thead><tr><th align="left">参数</th><th align="left">必传</th><th align="left">类型</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">user</td><td align="left">true</td><td align="left">String</td><td align="left">用户名</td></tr><tr><td align="left">repo</td><td align="left">true</td><td align="left">String</td><td align="left">仓库名字</td></tr><tr><td align="left">type</td><td align="left">true</td><td align="left">String</td><td align="left">star</td></tr><tr><td align="left">count</td><td align="left">true</td><td align="left">String</td><td align="left">数量</td></tr></tbody></table><pre><code class="html">&lt;iframe        style=&quot;margin-left: 2px; margin-bottom:-5px;&quot;        frameborder=&quot;0&quot; scrolling=&quot;0&quot; width=&quot;100px&quot; height=&quot;20px&quot;        src=&quot;https://ghbtns.com/github-btn.html?user=xuwenliu&amp;repo=music-cloud&amp;type=star&amp;count=true&quot; &gt;&lt;/iframe&gt;</code></pre><iframe        style="margin-left: 2px; margin-bottom:-5px;"        frameborder="0" scrolling="0" width="100px" height="20px"        src="https://ghbtns.com/github-btn.html?user=xuwenliu&repo=music-cloud&type=star&count=true" ></iframe>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序UI库-colorUI</title>
    <link href="/2020/05/14/miniprogram/colorui/"/>
    <url>/2020/05/14/miniprogram/colorui/</url>
    
    <content type="html"><![CDATA[<h2 id="ColorUI是一个css库"><a href="#ColorUI是一个css库" class="headerlink" title="ColorUI是一个css库"></a>ColorUI是一个css库</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://www.color-ui.com/" target="_blank" rel="noopener">https://www.color-ui.com/</a></p><h3 id="使用UniApp开发"><a href="#使用UniApp开发" class="headerlink" title="使用UniApp开发"></a>使用UniApp开发</h3><p>下载源码解压获得/Colorui-UniApp文件夹，复制目录下的 /colorui 文件夹到你的项目根目录<br>App.vue 引入关键Css main.css icon.css</p><pre><code class="css">&lt;style&gt;@import &quot;colorui/main.css&quot;;@import &quot;colorui/icon.css&quot;;@import &quot;app.css&quot;; /* 你的项目css */....&lt;/style&gt;</code></pre><h3 id="使用自定义导航栏"><a href="#使用自定义导航栏" class="headerlink" title="使用自定义导航栏"></a>使用自定义导航栏</h3><p>导航栏作为常用组件有做简单封装，当然你也可以直接复制代码结构自己修改，达到个性化目的。<br>App.vue 获得系统信息</p><pre><code class="js">onLaunch: function() {    uni.getSystemInfo({        success: function(e) {            // #ifndef MP            Vue.prototype.StatusBar = e.statusBarHeight;            if (e.platform == &#39;android&#39;) {                Vue.prototype.CustomBar = e.statusBarHeight + 50;            } else {                Vue.prototype.CustomBar = e.statusBarHeight + 45;            };            // #endif            // #ifdef MP-WEIXIN            Vue.prototype.StatusBar = e.statusBarHeight;            let custom = wx.getMenuButtonBoundingClientRect();            Vue.prototype.Custom = custom;            Vue.prototype.CustomBar = custom.bottom + custom.top - e.statusBarHeight;            // #endif                    // #ifdef MP-ALIPAY            Vue.prototype.StatusBar = e.statusBarHeight;            Vue.prototype.CustomBar = e.statusBarHeight + e.titleBarHeight;            // #endif        }    })},</code></pre><p>pages.json 配置取消系统导航栏</p><pre><code class="json">&quot;globalStyle&quot;: {    &quot;navigationStyle&quot;: &quot;custom&quot;},</code></pre><p>复制代码结构可以直接使用，注意全局变量的获取。</p><p>使用封装,在main.js 引入 cu-custom 组件。</p><pre><code class="js">import cuCustom from &#39;./colorui/components/cu-custom.vue&#39;Vue.component(&#39;cu-custom&#39;,cuCustom)</code></pre><p>page.vue 页面可以直接调用了</p><pre><code class="html">&lt;cu-custom bgColor=&quot;bg-gradual-blue&quot; :isBack=&quot;true&quot;&gt;    &lt;block slot=&quot;backText&quot;&gt;返回&lt;/block&gt;    &lt;block slot=&quot;content&quot;&gt;导航栏&lt;/block&gt;&lt;/cu-custom&gt;</code></pre><table><thead><tr><th>参数</th><th align="right">作用</th><th align="right">类型</th><th align="center">默认值</th></tr></thead><tbody><tr><td>bgColor</td><td align="right">背景颜色类名</td><td align="right">String</td><td align="center">‘’</td></tr><tr><td>isBack</td><td align="right">是否开启返回</td><td align="right">Boolean</td><td align="center">false</td></tr><tr><td>bgImage</td><td align="right">背景图片路径</td><td align="right">String</td><td align="center">‘’</td></tr></tbody></table><table><thead><tr><th>slot块</th><th align="right">作用</th></tr></thead><tbody><tr><td>backText</td><td align="right">返回时的文字</td></tr><tr><td>content</td><td align="right">中间区域</td></tr><tr><td>right</td><td align="right">右侧区域(小程序端可使用范围很窄！)</td></tr></tbody></table><h3 id="使用原生小程序开发"><a href="#使用原生小程序开发" class="headerlink" title="使用原生小程序开发"></a>使用原生小程序开发</h3><ul><li>从现有项目开始<br>下载源码解压获得/demo，复制目录下的 /colorui 文件夹到你的项目根目录</li></ul><p>App.wxss 引入关键Css main.wxss icon.wxss</p><pre><code class="css">@import &quot;colorui/main.wxss&quot;;@import &quot;colorui/icon.wxss&quot;;@import &quot;app.css&quot;; /* 你的项目css */....</code></pre><ul><li>从新项目开始<br>下载源码解压获得/template，复制/template并重命名为你的项目，导入到小程序开发工具既可以开始你的新项目了</li></ul><h4 id="使用自定义导航栏-1"><a href="#使用自定义导航栏-1" class="headerlink" title="使用自定义导航栏"></a>使用自定义导航栏</h4><p>导航栏作为常用组件有做简单封装，当然你也可以直接复制代码结构自己修改，达到个性化目的。<br>App.js 获得系统信息</p><pre><code class="js"> onLaunch: function() {    wx.getSystemInfo({      success: e =&gt; {        this.globalData.StatusBar = e.statusBarHeight;        let custom = wx.getMenuButtonBoundingClientRect();        this.globalData.Custom = custom;          this.globalData.CustomBar = custom.bottom + custom.top - e.statusBarHeight;      }    })},</code></pre><p>App.json 配置取消系统导航栏,并全局引入组件</p><pre><code class="json">&quot;window&quot;: {    &quot;navigationStyle&quot;: &quot;custom&quot;},&quot;usingComponents&quot;: {    &quot;cu-custom&quot;:&quot;/colorui/components/cu-custom&quot;}</code></pre><p>page.wxml 页面可以直接调用了</p><pre><code class="html">&lt;cu-custom bgColor=&quot;bg-gradual-pink&quot; isBack=&quot;{{true}}&quot;&gt;    &lt;view slot=&quot;backText&quot;&gt;返回&lt;/view&gt;    &lt;view slot=&quot;content&quot;&gt;导航栏&lt;/view&gt;&lt;/cu-custom&gt;</code></pre><table><thead><tr><th>参数</th><th align="right">作用</th><th align="right">类型</th><th align="center">默认值</th></tr></thead><tbody><tr><td>bgColor</td><td align="right">背景颜色类名</td><td align="right">String</td><td align="center">‘’</td></tr><tr><td>isBack</td><td align="right">是否开启返回</td><td align="right">Boolean</td><td align="center">false</td></tr><tr><td>isCustom</td><td align="right">是否开启左侧胶囊</td><td align="right">Boolean</td><td align="center">false</td></tr><tr><td>bgImage</td><td align="right">背景图片路径</td><td align="right">String</td><td align="center">‘’</td></tr></tbody></table><table><thead><tr><th>slot块</th><th align="right">作用</th></tr></thead><tbody><tr><td>backText</td><td align="right">返回时的文字</td></tr><tr><td>content</td><td align="right">中间区域</td></tr><tr><td>right</td><td align="right">右侧区域(小程序端可使用范围很窄！)</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 浏览器新开窗口的正确方式</title>
    <link href="/2020/05/13/js/opener/"/>
    <url>/2020/05/13/js/opener/</url>
    
    <content type="html"><![CDATA[<p>前端项目开发过程中，网页里的a标签默认在当前窗口跳转链接地址，如果需要在新窗口打开，需要给 a 标签添加一个<code>target=&quot;_blank&quot;</code>属性。 例：</p><pre><code class="js">&lt;a target=&quot;_blank&quot; href=&quot;https://weibo.com/&quot;&gt;打开微博页面&lt;/a&gt;</code></pre><h3 id="1-此操作有安全问题"><a href="#1-此操作有安全问题" class="headerlink" title="1.此操作有安全问题"></a>1.此操作有安全问题</h3><p>如果只是加上 <code>target=“_blank&#39;</code>，在打开新窗口之后，新页面可以通过 <code>window.opener</code> 来获取到来源页面的 <code>window</code> 对象，即使是跨域状态也一样。</p><p><img src="/img/life/opener.png" srcset="/img/loading.gif" alt="opener"></p><p>某些属性的访问被拦截，是因为跨域安全策略的限制。但是，如果我修改 <code>window.opener.location</code> 的值，指向另外一个地址。即可以造成刚刚还在某个网站浏览，随后点击链接新开的窗口，但是这个新开的窗口在神不知鬼不觉的情况下，把原来的网页地址改了，再通过页面伪装，例如伪装成登录页等，来让用户输入账号密码登录，从而达到黑客不可告人的目的。</p><h3 id="2-此操作有性能问题"><a href="#2-此操作有性能问题" class="headerlink" title="2.此操作有性能问题"></a>2.此操作有性能问题</h3><p>通过 <code>target=&quot;_blank&quot;</code> 打开的新窗口，跟原来的页面窗口共用一个进程。如果这个新页面执行了一大堆性能不好的 JavaScript 代码，占用了大量系统资源，那你原来的页面的性能也会收到影响。</p><h3 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3.解决办法"></a>3.解决办法</h3><p>1.尽量不使用  <code>target=&quot;_blank&quot;</code><br>2.如果一定要用，需要加上 <code>rel=”noopener“</code> 或者 <code>rel=“noreferrer”</code> ,这样新开窗口的  <code>window.openne</code>r 就为<code>null</code>，而且会让新窗口运行在独立的进程里，不会拖累原来页面的进程。(不过，有些浏览器对性能做了优化，即使不加这个属性，新窗口也会在独立进程打开。不过为了安全考虑，还是加上吧。)</p><p>下图是vscode的安全提示:<br><img src="/img/life/vscode-tip.png" srcset="/img/loading.gif" alt="tip"></p><p>3.通过 <code>window.open</code> 的方式打开新页面</p><pre><code class="js">let newWindow = window.open();newWindow.opener = null;newWindow.location = &quot;https://baidu.com/&quot;;newWindow.target = &quot;_blank&quot;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>养生之喝点什么</title>
    <link href="/2020/05/13/life/health/"/>
    <url>/2020/05/13/life/health/</url>
    
    <content type="html"><![CDATA[<h3 id="养生之枸杞篇"><a href="#养生之枸杞篇" class="headerlink" title="养生之枸杞篇"></a>养生之枸杞篇</h3><p>枸杞+</p><ul><li>桂圆-安神入睡</li><li>红枣-健脾、护胃、养肝</li><li>黄芪[qi]-补肾、益精</li><li>菊花-养肝、排毒</li><li>山药-降血压、降血糖</li><li>斗龙芝-补肾、提高身体活力</li></ul>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>养生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React面试题集锦</title>
    <link href="/2020/05/12/react/interview-question/"/>
    <url>/2020/05/12/react/interview-question/</url>
    
    <content type="html"><![CDATA[<p>持续更新~~</p><h3 id="1-redux中间件的原理是什么？"><a href="#1-redux中间件的原理是什么？" class="headerlink" title="1.redux中间件的原理是什么？"></a>1.redux中间件的原理是什么？</h3><blockquote><p>中间件是指action和store之间，用来改装dispatch<br>原来的action是一个对象，那么通过redux-thunk这个中间件就可以将action改装成一个函数然后返回一个对象。</p></blockquote><p><img src="/img/react/redux.jpg" srcset="/img/loading.gif" alt="redux"></p><h3 id="2-你会把数据统一放到redux中管理，还是共享数据放在redux中管理？"><a href="#2-你会把数据统一放到redux中管理，还是共享数据放在redux中管理？" class="headerlink" title="2.你会把数据统一放到redux中管理，还是共享数据放在redux中管理？"></a>2.你会把数据统一放到redux中管理，还是共享数据放在redux中管理？</h3><p>应当是所有的数据都放到redux中管理。<br>在react中存储数据有state，props，redux这三种方式。如果部分放在redux，部分放在state或者props里面，那么对于数据的维护和出现问题的排查是不利的。</p><h3 id="3-componentWillReceiveProps的调用时机？-已废弃"><a href="#3-componentWillReceiveProps的调用时机？-已废弃" class="headerlink" title="3.componentWillReceiveProps的调用时机？ 已废弃"></a>3.componentWillReceiveProps的调用时机？ <code>已废弃</code></h3><p>当props发生变化时执行，初始化render时不执行</p><h3 id="4-react性能优化的最佳实践？"><a href="#4-react性能优化的最佳实践？" class="headerlink" title="4.react性能优化的最佳实践？"></a>4.react性能优化的最佳实践？</h3><ul><li>减少重新render的次数  —shouldComponentUpdate/PureComponent</li><li>减少计算量，主要是减少重复计算。对于函数式组件来说，每次render都会重新从头开始执行函数调用 —React.memo</li></ul><h3 id="5-虚拟dom是什么？为什么虚拟dom会提升性能？"><a href="#5-虚拟dom是什么？为什么虚拟dom会提升性能？" class="headerlink" title="5.虚拟dom是什么？为什么虚拟dom会提升性能？"></a>5.虚拟dom是什么？为什么虚拟dom会提升性能？</h3><blockquote><p>虚拟dom就是一个js对象。<br>react通过数据改变来比对前后虚拟dom之间的差异，然后用实际更改的内容更新真实dom。</p></blockquote><h3 id="6-webpack中，-是借助loader完成的JSX代码的转化，还是babel"><a href="#6-webpack中，-是借助loader完成的JSX代码的转化，还是babel" class="headerlink" title="6.webpack中， 是借助loader完成的JSX代码的转化，还是babel?"></a>6.webpack中， 是借助loader完成的JSX代码的转化，还是babel?</h3><p>babel — preset-react</p><h3 id="7-调用setState后，发生了什么？setState一般怎么用，传一个对象还是函数？"><a href="#7-调用setState后，发生了什么？setState一般怎么用，传一个对象还是函数？" class="headerlink" title="7.调用setState后，发生了什么？setState一般怎么用，传一个对象还是函数？"></a>7.调用setState后，发生了什么？setState一般怎么用，传一个对象还是函数？</h3><p>在代码中调用了setState之后，React会将传入的参数对象与组件当前的状态合并，然后触发调和过程，经过调和过程，react会以相对高效的方式根据新的状态构建react元素树并开始重新渲染UI界面。在得到元素树之后，会自动计算新的树与老的树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算中，react能够相对精确的知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。<br>官方推荐：</p><pre><code class="js">this.setState((preState) =&gt; ({    name:&#39;newValue&#39;}))</code></pre><h3 id="8-setState是异步的，这个点你在什么时候遇到过坑？"><a href="#8-setState是异步的，这个点你在什么时候遇到过坑？" class="headerlink" title="8.setState是异步的，这个点你在什么时候遇到过坑？"></a>8.setState是异步的，这个点你在什么时候遇到过坑？</h3><p>一般是在调用this.setState()之后访问修改的值，取到的还是之前的结果，并不是更新后的。<br>若要访问更新后的需要在第二个回调函数里面访问出来</p><pre><code class="js">this.setState((preState)=&gt;({    name:&#39;xxx&#39;}),()=&gt;{    console.log(this.state.name);}）</code></pre><h3 id="9-refs的作用是什么，你在什么业务场景下使用过refs"><a href="#9-refs的作用是什么，你在什么业务场景下使用过refs" class="headerlink" title="9.refs的作用是什么，你在什么业务场景下使用过refs?"></a>9.refs的作用是什么，你在什么业务场景下使用过refs?</h3><ul><li>操作dom，比如渲染图片后，需要获取图片的宽高。需要管理焦点，文本选择或者媒体播放，触发强制动画，集成第三方DOM库</li><li>操作组件，向组件添加属性或方法</li></ul><h3 id="10-ref是一个函数，有什么好处？"><a href="#10-ref是一个函数，有什么好处？" class="headerlink" title="10.ref是一个函数，有什么好处？"></a>10.ref是一个函数，有什么好处？</h3><ul><li>react可以更优雅的完成对组件/元素销毁时的变量回收，你只要这么用，react在销毁组件时，很方便的就可以被清理变为null。</li><li>可以做更多的操作，例如：让父组件直接获取子组件的Dom，而如果你让ref是一个字符串，实现这个功能是不可能的<pre><code class="js">function CustomTextInput(props) {return (  &lt;div&gt;    &lt;input ref={props.inputRef} /&gt;  &lt;/div&gt;);}class Parent extends React.Component {render() {  return (    &lt;CustomTextInput      inputRef={el =&gt; this.inputElement = el}    /&gt;  );}}</code></pre></li></ul><h3 id="11-高阶组件HOC你是怎么理解的，它的本质是一个什么东西？"><a href="#11-高阶组件HOC你是怎么理解的，它的本质是一个什么东西？" class="headerlink" title="11.高阶组件HOC你是怎么理解的，它的本质是一个什么东西？"></a>11.高阶组件HOC你是怎么理解的，它的本质是一个什么东西？</h3><blockquote><p>高阶组件是一个以组件为参数并返回一个新组件的函数。<br>最常见的可能是 Redux 的 connect 函数</p></blockquote><ul><li>代码重用，逻辑和引导抽象</li><li>渲染劫持</li><li>状态抽象和控制</li><li>Props 控制</li></ul><h3 id="12-受控组件和非受控组件的区别？"><a href="#12-受控组件和非受控组件的区别？" class="headerlink" title="12.受控组件和非受控组件的区别？"></a>12.受控组件和非受控组件的区别？</h3><p>受控组件：这个组件的改变受控于数据的变化，数据变了，页面跟着变化。例如：</p><pre><code class="js">class Demo1 extends Component {    constructor(props) {        super(props);        this.state = {            value: props.value        }    }    handleChange(e) {        this.setState({            value: e.target.value        })    }    render() {        return (            &lt;input value={this.state.value} onChange={e =&gt; this.handleChange(e)}/&gt;        )    }}</code></pre><p>非受控组件：组件的状态不受react控制</p><pre><code class="js">class Demo1 extends Component {    render() {        return (            &lt;input /&gt;        )    }}</code></pre><h3 id="13-this指向问题你一般是怎么解决的？"><a href="#13-this指向问题你一般是怎么解决的？" class="headerlink" title="13.this指向问题你一般是怎么解决的？"></a>13.this指向问题你一般是怎么解决的？</h3><ul><li>箭头函数</li><li>bind this放在constructor里面</li></ul><h3 id="14-函数组件怎么做性能优化？"><a href="#14-函数组件怎么做性能优化？" class="headerlink" title="14.函数组件怎么做性能优化？"></a>14.函数组件怎么做性能优化？</h3><p>用React.memo包装函数组件，类似于类组件的shouldComponentUpdate</p><h3 id="15-那个生命周期里发送ajax"><a href="#15-那个生命周期里发送ajax" class="headerlink" title="15.那个生命周期里发送ajax?"></a>15.那个生命周期里发送ajax?</h3><blockquote><p>componentDidMount<br>这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。</p></blockquote><h3 id="16-react-的ssr的原理是什么？"><a href="#16-react-的ssr的原理是什么？" class="headerlink" title="16.react 的ssr的原理是什么？"></a>16.react 的ssr的原理是什么？</h3><blockquote><p>借助虚拟dom完成操作</p></blockquote><h3 id="17-react-jquery-vue是否有可能共存在一个项目中？"><a href="#17-react-jquery-vue是否有可能共存在一个项目中？" class="headerlink" title="17.react,jquery,vue是否有可能共存在一个项目中？"></a>17.react,jquery,vue是否有可能共存在一个项目中？</h3><p>可以，怎么共存？</p><pre><code class="html">&lt;body&gt;    &lt;div id=&quot;jquery&quot;&gt;&lt;/div&gt;    //这个div用于jquery操作    &lt;div id=&quot;react&quot;&gt;&lt;/div&gt;        //这个用于react     &lt;div id=&quot;vue&quot;&gt;&lt;/div&gt;        //这个用于vue &lt;/body&gt;&lt;script&gt;    ReactDom.render(&lt;App /&gt;,document.getElementById(&#39;react&#39;));    let vue = new Vue({        el:&quot;#vue&quot;,        data(){            return {            }        }    })&lt;/script&gt;</code></pre><h3 id="18-组件是什么？类是什么？类被编译成什么？"><a href="#18-组件是什么？类是什么？类被编译成什么？" class="headerlink" title="18.组件是什么？类是什么？类被编译成什么？"></a>18.组件是什么？类是什么？类被编译成什么？</h3><p>组件：指的是页面的一部分<br>类：本质就是一个构造函数<br>被编译为：构造函数</p><h3 id="19-如何避免ajax数据重新获取"><a href="#19-如何避免ajax数据重新获取" class="headerlink" title="19.如何避免ajax数据重新获取"></a>19.如何避免ajax数据重新获取</h3><p>数据采用redux和react-redux来管理</p><h3 id="20-react-router4的核心思想是什么？和3有什么区别"><a href="#20-react-router4的核心思想是什么？和3有什么区别" class="headerlink" title="20.react-router4的核心思想是什么？和3有什么区别"></a>20.react-router4的核心思想是什么？和3有什么区别</h3><p>核心思想是：路由也是组件 <Link></Link> <Route></Route><br>3是路由配置，4是路由即组件</p><h3 id="21-reselect是做什么使用的？"><a href="#21-reselect是做什么使用的？" class="headerlink" title="21.reselect是做什么使用的？"></a>21.reselect是做什么使用的？</h3><p>这个库类似于vue的computed</p><h3 id="22-react-router的基本原理，hashHistory-browserHistory"><a href="#22-react-router的基本原理，hashHistory-browserHistory" class="headerlink" title="22.react-router的基本原理，hashHistory,browserHistory"></a>22.react-router的基本原理，hashHistory,browserHistory</h3><ul><li>hashHistory 前端直接搞定</li><li>browserHistory 需要后台在服务器进行配置</li></ul><h3 id="23-什么情况下使用异步组件"><a href="#23-什么情况下使用异步组件" class="headerlink" title="23.什么情况下使用异步组件"></a>23.什么情况下使用异步组件</h3><p>reloadable库，路由懒加载或者叫按需加载</p><h3 id="24-xss攻击在react中如何防范？"><a href="#24-xss攻击在react中如何防范？" class="headerlink" title="24.xss攻击在react中如何防范？"></a>24.xss攻击在react中如何防范？</h3><p>react默认防范，我们慎用dangerouslySetInnerHTML</p><pre><code class="js">export default class TodoInput extends React.Component {    constructor(props){        super(props)        this.state = {            title:&#39;&lt;h1&gt;解析html&lt;/h2&gt;&#39;        }    }    render(){        return(            &lt;Fragment&gt;                &lt;div dangerouslySetInnerHTML = {{__html:this.state.title}}&gt;&lt;/div&gt;            &lt;/Fragment&gt;        )    }}</code></pre><h3 id="25-react中keys的作用是什么？"><a href="#25-react中keys的作用是什么？" class="headerlink" title="25.react中keys的作用是什么？"></a>25.react中keys的作用是什么？</h3><blockquote><p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p></blockquote><pre><code class="js">render () {  return (    &lt;ul&gt;      {this.state.list.map(({item, key}) =&gt; {        return &lt;li key={key}&gt;{item}&lt;/li&gt;      })}    &lt;/ul&gt;  )}</code></pre><p>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助<code>Key</code>值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。</p><h3 id="26-生命周期函数"><a href="#26-生命周期函数" class="headerlink" title="26.生命周期函数"></a>26.生命周期函数</h3><p>1.初始化阶段：</p><ul><li><code>getDefaultProps</code>:获取实例的默认属性 <code>已废弃</code></li><li><code>getInitialState</code>:获取每个实例的初始化状态  <code>已废弃</code></li><li><code>componentWillMount</code>：组件即将被装载、渲染到页面上  <code>已废弃</code></li><li><code>render</code>:组件在这里生成虚拟的 DOM 节点</li><li><code>componentDidMount</code>:组件真正在被装载之后</li></ul><p>2.运行中状态：</p><ul><li><p><code>componentWillReceiveProps</code>:组件将要接收到属性的时候调用    <code>已废弃</code></p></li><li><p><code>static getDerivedStateFromProps()</code></p><blockquote><p>是一个静态方法</p></blockquote><ul><li>从props中获取衍生的state   </li><li>它必须返回一个对象用于更新state,返回null则不更新任何内容</li><li>没有this</li><li>会在调用render之前调用，并且在初始挂载和后续更新中都会被调用。</li></ul></li><li><p><code>shouldComponentUpdate(nextProps, nextState)</code>:组件接受到新属性或者新状态的时候（可以返回 <code>false</code>，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</p><ul><li>当props和state发生改变时，shouldComponentUpdate会在渲染之前被调用。返回值默认为<code>true</code></li><li>首次渲染和调用<code>forceUpdate()</code>时不会调用该方法。</li><li><code>shouldComponentUpdat</code>e 只作为性能优化而存在。PureComponent 会对props和state进行浅层比较，不要用JSON.stringify()进行比较</li><li>返回 <code>false</code> 不会调用<code>render()</code> <code>componentDidUpdate()</code> 并不会阻止子组件在state更改时重新渲染</li></ul></li><li><p><code>componentWillUpdate</code>:组件即将更新不能修改属性和状态  <code>已废弃</code></p></li><li><p><code>render</code>:组件重新描绘 </p></li><li><p><code>componentDidUpdate(prevProps,prevState,snapshot)</code>:组件已经更新</p><blockquote><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate</a></p></blockquote><ul><li><p><code>componentDidUpdate</code>会在更新后立即被调用，首次渲染不会调用</p></li><li><p>当组件更新后，可以在此次对DOM进行操作。如果对前后props进行了比较，也可以进行网络请求</p><pre><code class="js">  componentDidUpdate(prevProps) {      // 典型用法（不要忘记比较 props）：      if (this.props.userID !== prevProps.userID) {          this.fetchData(this.props.userID);      }  }</code></pre></li><li><p>也可以在<code>componentDidUpdate</code>中调用<code>setState()</code>,但他必须要被包含在条件判断语句内，否则会导致死循环</p></li><li><p>第三个参数如果<code>getSnapshotBeforeUpdate</code>未返回则是 <code>undefined</code></p></li></ul></li></ul><p>3.销毁阶段：</p><ul><li><code>componentWillUnmount</code>:组件即将销毁<ul><li><code>componentWillUnmount</code> 会在组件销毁之前调用。在此方法中执行必要的清理操作。（例如：清除定时器，取消网络请求，解除绑定事件，…）</li><li>不应该使用setState,因为组件将永远不会被渲染。</li></ul></li></ul><p><img src="/img/react/lifecycle.jpg" srcset="/img/loading.gif" alt="react生命周期"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React-hooks下</title>
    <link href="/2020/05/11/react/hooks-next/"/>
    <url>/2020/05/11/react/hooks-next/</url>
    
    <content type="html"><![CDATA[<h3 id="1-useRef"><a href="#1-useRef" class="headerlink" title="1.useRef"></a>1.useRef</h3><blockquote><p>保存引用值</p></blockquote><ul><li>useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用。</li><li>useRef 返回的值传递给组件或者 DOM 的 ref 属性就可以通过 ref.current 值访问组件或真实的 DOM 节点，重点是组件也是可以访问到的，从而可以对 DOM 进行一些操作，比如监听事件等等。</li><li>useRef 的功能有点像类属性，在组件中记录一些值，并且这些值在稍后可以更改</li></ul><pre><code class="js">import React, { useState, useRef } from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import &quot;./styles.css&quot;;function App() {  let [name, setName] = useState(&quot;init&quot;);  let nameRef = useRef();  //点击按钮把文本框里面的值赋给name  const submitButton = () =&gt; {    console.log(nameRef.current);    setName(nameRef.current.value);  };  return (    &lt;div className=&quot;App&quot;&gt;      &lt;p&gt;{name}&lt;/p&gt;      &lt;div&gt;        &lt;input ref={nameRef} type=&quot;text&quot; /&gt;        &lt;button type=&quot;button&quot; onClick={submitButton}&gt;          Submit        &lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  );}const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement);</code></pre><pre><code class="js">import React, { useState, useEffect, useRef } from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;function App() {  const [count, setCount] = useState(0);  const timer = useRef();  const changeCount = () =&gt; {    setCount(count + 1);  };  useEffect(() =&gt; {    timer.current = setInterval(() =&gt; {      setCount(count =&gt; count + 1);    }, 1000);  }, []);  useEffect(() =&gt; {    if (count &gt;= 10) {      clearInterval(timer.current);    }  });  return (    &lt;div className=&quot;App&quot;&gt;      &lt;button onClick={changeCount}&gt;changeCount:{count}&lt;/button&gt;    &lt;/div&gt;  );}const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement);</code></pre><h3 id="2-useImperativeHandle"><a href="#2-useImperativeHandle" class="headerlink" title="2.useImperativeHandle"></a>2.useImperativeHandle</h3><blockquote><p>透传 Ref 用于让父组件获取子组件内的索引</p></blockquote><pre><code class="js">import React, { useRef, useEffect, useImperativeHandle, forwardRef } from &quot;react&quot;;function ChildInputComponent(props, ref) {  const inputRef = useRef(null);  useImperativeHandle(ref, () =&gt; inputRef.current);  return &lt;input type=&quot;text&quot; name=&quot;child input&quot; ref={inputRef} /&gt;;}const ChildInput = forwardRef(ChildInputComponent);function App() {  const inputRef = useRef(null);  useEffect(() =&gt; {    inputRef.current.focus();  }, []);  return (    &lt;div&gt;      &lt;ChildInput ref={inputRef} /&gt;    &lt;/div&gt;  );}//通过这种方式，App 组件可以获得子组件的 input 的 DOM 节点</code></pre><h3 id="3-useLayoutEffect"><a href="#3-useLayoutEffect" class="headerlink" title="3.useLayoutEffect"></a>3.useLayoutEffect</h3><blockquote><p>同步执行副作用</p></blockquote><ul><li>大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，</li><li>useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。</li><li>useLayoutEffect 会在 render，DOM 更新之后同步触发函数，会优于 useEffect 异步触发函数。</li><li>useLayoutEffect和原来componentDidMount&amp;componentDidUpdate一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。<br>而useEffect是会在整个页面渲染完才会调用的代码。</li><li>在实际使用时如果想避免页面抖动（在useEffect里修改DOM很有可能出现）的话，可以把需要操作DOM的代码放在useLayoutEffect里<br>不过useLayoutEffect在服务端渲染时会出现一个warning，要消除的话得用useEffect代替或者推迟渲染时机。</li></ul><pre><code class="js">import React, { useLayoutEffect, useState, useEffect } from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;function App() {  const [width, setWidth] = useState(0);  useLayoutEffect(() =&gt; {    const title = document.querySelector(&quot;#title&quot;);    const titleWidth = title.getBoundingClientRect().width;    console.log(&quot;2-useLayoutEffect&quot;);    if (width !== titleWidth) {      setWidth(titleWidth);    }  },[width]);  useEffect(() =&gt; {    console.log(&quot;3-useEffect&quot;);  });  console.log(&quot;1-render&quot;);  return (    &lt;div&gt;      &lt;h1 id=&quot;title&quot;&gt;hello&lt;/h1&gt;      &lt;h2&gt;{width}&lt;/h2&gt;    &lt;/div&gt;  );}const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement);</code></pre><h3 id="4-useReducer"><a href="#4-useReducer" class="headerlink" title="4.useReducer"></a>4.useReducer</h3><blockquote><p>在使用上几乎跟 Redux/React-Redux 一模一样，唯一缺少的就是无法使用 redux 提供的中间件，算是提供一个 mini 的 Redux 版本。</p></blockquote><pre><code class="js">import React, { useReducer } from &quot;react&quot;;const initialState = {  count: 0};function reducer(state, action) {  switch (action.type) {    case &quot;add&quot;:      return { count: state.count + action.payload };    case &quot;reduce&quot;:      return { count: state.count - action.payload };    default:      throw new Error();  }}function App() {  const [state, dispatch] = useReducer(reducer, initialState);  return (    &lt;&gt;      Count: {state.count}      &lt;button onClick={() =&gt; dispatch({ type: &quot;add&quot;, payload: 1 })}&gt;        +      &lt;/button&gt;      &lt;button onClick={() =&gt; dispatch({ type: &quot;reduce&quot;, payload: 1 })}&gt;        -      &lt;/button&gt;    &lt;/&gt;  );}</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React-hooks上</title>
    <link href="/2020/05/10/react/hooks-prev/"/>
    <url>/2020/05/10/react/hooks-prev/</url>
    
    <content type="html"><![CDATA[<h3 id="1-useState"><a href="#1-useState" class="headerlink" title="1.useState"></a>1.useState</h3><p>这个就太简单了，不多做介绍</p><h3 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2.useEffect"></a>2.useEffect</h3><p>函数组件能保存状态，但是对于异步请求，副作用的操作还是无能为力，所以 React 提供了 useEffect 来帮助开发者处理函数组件的副作用</p><pre><code class="js">import React, { useState, useEffect } from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;let timer = null;function App() {  const [count, setCount] = useState(0);  useEffect(() =&gt; {      document.title = &quot;componentDidMount&quot; + count;    },[count]);  useEffect(() =&gt; {    timer = setInterval(() =&gt; {      setCount(prevCount =&gt; prevCount + 1);    }, 1000);    return () =&gt; {      document.title = &quot;componentWillUnmount&quot;;      clearInterval(timer);    };  }, []);  return (    &lt;div&gt;      Count: {count}      &lt;button onClick={() =&gt; clearInterval(timer)}&gt;clear&lt;/button&gt;    &lt;/div&gt;  );}const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement);</code></pre><p>  1.第一个参数接收一个函数，可以用来做一些副作用比如异步请求，修改外部参数等行为<br>  2.第二个参数称之为dependencies，是一个数组，如果数组中的值变化才会触发 执行useEffect 第一个参数中的函数<br>  3.返回值(如果有)则在组件销毁或者调用函数前调用  用来代替componentWillUnmount<br>  4.第二个参数：</p><ul><li>不传递  代表不监听任何参数变化。每次渲染DOM之后，都会执行useEffect中的函数。</li><li>传递空数组[] 这种情况下只有在组件初始化或销毁的时候才会触发，用来代替 componentDidMount 和 componentWillUnmount</li><li>传递[count] 理解起来就是一旦 count 值发生改变，则修改 documen.title 值； 用来代替componentDidUpdate</li></ul><h3 id="3-模拟一个-componentDidUpdate"><a href="#3-模拟一个-componentDidUpdate" class="headerlink" title="3.模拟一个 componentDidUpdate"></a>3.模拟一个 componentDidUpdate</h3><pre><code class="js">function useUpdate(fn) {  // useRef 创建一个引用  const mounting = useRef(true);  useEffect(() =&gt; {    if (mounting.current) {      mounting.current = false;    } else {      fn();    }  });}</code></pre><h3 id="4-useContext"><a href="#4-useContext" class="headerlink" title="4.useContext"></a>4.useContext</h3><blockquote><p>跨组件传值（依赖createContext）<br>useContext用来处理多层级传递数据的方式，在以前组件树种，跨层级祖先组件想要给孙子组件传递数据的时候，除了一层层 props 往下透传之外，我们还可以使用 React Context API 来帮我们做这件事</p></blockquote><pre><code class="js">//1.从react中导入useContext和createContextimport React, { useContext,createContext } from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;const { Provider, Consumer } = createContext(null);//2.调用createContext 接受一个初始化参数const colorContext = createContext({  color: &quot;blue&quot;});function Bar() {  //3.把colorContext传递给useContext 返回值即是想要透传的数据了  //传递给 useContext 的是 context 而不是 consumer  const colors = useContext(colorContext);  return (    &lt;Consumer&gt;      {color =&gt; (        &lt;&gt;          &lt;div&gt;{color}&lt;/div&gt;          &lt;h2&gt;我是用useContext传过来的值 {colors.color}&lt;/h2&gt;        &lt;/&gt;      )}    &lt;/Consumer&gt;  );}function Foo() {  return &lt;Bar /&gt;;}function App() {  return (    &lt;Provider value={&quot;grey&quot;}&gt;      &lt;Foo /&gt;    &lt;/Provider&gt;  );}const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement);</code></pre><h3 id="5-useCallback"><a href="#5-useCallback" class="headerlink" title="5.useCallback"></a>5.useCallback</h3><blockquote><p>常用于记忆事件函数，生成记忆后的事件函数并传递给子组件使用<br>参考链接：<a href="https://juejin.im/post/5dd337985188252a1873730f?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5dd337985188252a1873730f?utm_source=gold_browser_extension</a></p></blockquote><p>1.作用是：获得一个记忆后的函数<br>2.第一个参数接收一个函数，且不会执行第一个参数函数，而是将它返回给你<br>3.第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。<br>4.这样只要子组件继承了 PureComponent 或者使用 React.memo 就可以有效避免不必要的 VDOM 渲染。</p><pre><code class="js">function App() {  const memoizedHandleClick = useCallback(() =&gt; {    console.log(&#39;Click happened&#39;)  }, []); // 空数组代表无论什么情况下该函数都不会发生改变  return &lt;SomeComponent onClick={memoizedHandleClick}&gt;Click Me&lt;/SomeComponent&gt;;}</code></pre><h3 id="6-useMemo"><a href="#6-useMemo" class="headerlink" title="6.useMemo"></a>6.useMemo</h3><blockquote><p>记忆计算<br>参考链接：<a href="https://juejin.im/post/5dd337985188252a1873730f?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5dd337985188252a1873730f?utm_source=gold_browser_extension</a></p></blockquote><p>useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。<br>useCallback(fn,inputs) &lt;==&gt; useMemo(()=&gt;fn,inputs);</p><pre><code class="js">function App(){    const memoizedHandleClick = useMemo(() =&gt; () =&gt; {        console.log(&#39;click happened&#39;);    },[])// 空数组代表无论什么情况下该函数都不会发生改变    return &lt;SomeComponent onClick={memoizedHandleClick}&gt;Click Me&lt;/SomeComponent&gt;;}</code></pre><p>useMemo 会执行第一个函数并且将函数执行结果返回给你<br>useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</p><pre><code class="js">import React, { useState, useMemo } from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;const Counter = props =&gt; {  return &lt;div&gt;{props.count}&lt;/div&gt;;};function App() {  const [count, setCount] = useState(0);  const changeCount = () =&gt; {    setCount(count + 1);  };  //useMemo 返回 经过函数计算得到一个确定的值  const dobuleCount = useMemo(() =&gt; count * 2, [count]);  //useMemo 返回 一个函数  const changeCount2 = useMemo(() =&gt; () =&gt; setCount(count + 1), [count]);  return (    &lt;div className=&quot;App&quot;&gt;      &lt;Counter count={count} /&gt;      &lt;div&gt;dobuleCount:{dobuleCount}&lt;/div&gt;      &lt;button onClick={changeCount}&gt;changeCount:{count}&lt;/button&gt;      &lt;button onClick={changeCount2}&gt;changeCount2:{count}&lt;/button&gt;    &lt;/div&gt;  );}const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement);</code></pre><pre><code class="js">import React, { useState, useMemo, memo, useCallback } from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;const Counter = memo(props =&gt; {  console.log(&quot;counter render&quot;);  return &lt;div onClick={props.onClick}&gt;{props.count}&lt;/div&gt;;});function App() {  const [count, setCount] = useState(0);  const changeCount = () =&gt; {    setCount(count + 1);  };  //useMemo 返回 经过函数计算得到一个确定的值  const dobuleCount = useMemo(() =&gt; count * 2, [count === 3]);  //useMemo 返回 一个函数  const changeCount2 = useMemo(() =&gt; () =&gt; setCount(count + 1), [count]);  //userMemo 返回一个 函数 同时传递给子组件，在子组件里面调用  // const onClick = useMemo(() =&gt; {  //   return () =&gt; {  //     console.log(&quot;click&quot;);  //   };  // }, []);  //等价于上面  // const onClick = useCallback(() =&gt; {  //   console.log(&quot;click&quot;);  // }, []);  const onClick = () =&gt; {    console.log(&quot;click&quot;);  };  return (    &lt;div className=&quot;App&quot;&gt;      &lt;Counter count={dobuleCount} onClick={onClick} /&gt;      &lt;div&gt;dobuleCount:{dobuleCount}&lt;/div&gt;      &lt;button onClick={changeCount}&gt;changeCount:{count}&lt;/button&gt;      &lt;button onClick={changeCount2}&gt;changeCount2:{count}&lt;/button&gt;    &lt;/div&gt;  );}const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement);</code></pre><blockquote><p>总结，当需要通过属性给子组件传递函数（方法）时，这个方法就由useCallback或者useMemo来创建</p></blockquote><p>这个例子，每次点击按钮count都发生改变,在Counter组件中通过memo来优化，只有count改变才渲染。<br>但是由于我们同时也传递了方法给该组件，就会导致每次count改变 所获取的函数事件句柄重新生成了。<br>这就导致每次count改变 Counter重新生成事件，要避免就在外面传递函数时，通过useCallback或者useMemo来优化。</p><pre><code class="js">const onClick = useCallback(() =&gt; {    console.log(&quot;click&quot;);}, []);const onClick = useMemo(() =&gt; {    return () =&gt; {    console.log(&quot;click&quot;);    };}, []);</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的迭代器和生成器</title>
    <link href="/2020/05/09/ts/iterators-generators/"/>
    <url>/2020/05/09/ts/iterators-generators/</url>
    
    <content type="html"><![CDATA[<h3 id="1-可迭代性"><a href="#1-可迭代性" class="headerlink" title="1.可迭代性"></a>1.可迭代性</h3><p>当一个对象实现了Symbol.iterator属性时，我们认为它是可迭代的。 一些内置的类型如 Array，Map，Set，String，Int32Array，Uint32Array等都已经实现了各自的Symbol.iterator。 对象上的 Symbol.iterator函数负责返回供迭代的值。</p><h3 id="2-for-of语句"><a href="#2-for-of语句" class="headerlink" title="2.for..of语句"></a>2.for..of语句</h3><p>for..of会遍历可迭代的对象，调用对象上的Symbol.iterator方法。 下面是在数组上使用 for..of的简单例子：</p><pre><code class="ts">let someArray = [1, &quot;aaa&quot;, false];for (let entry of someArray) {    console.log(entry); // 1, &quot;aaa&quot;, false}</code></pre><h3 id="3-for-of与for-in语句的区别"><a href="#3-for-of与for-in语句的区别" class="headerlink" title="3.for..of与for..in语句的区别"></a>3.for..of与for..in语句的区别</h3><p>for..of和for..in均可迭代一个列表；但是用于迭代的值却不同，for..in迭代的是对象的<code>键</code>的列表，而for..of则迭代对象的<code>键对应的值</code>。</p><pre><code class="ts">let list = [4, 5, 6];for (let i in list) {    console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;,}for (let i of list) {    console.log(i); // &quot;4&quot;, &quot;5&quot;, &quot;6&quot;}</code></pre><p>另一个区别是for..in可以操作任何对象；它提供了查看对象属性的一种方法。 但是 for..of关注于迭代对象的值。内置对象Map和Set已经实现了Symbol.iterator方法，让我们可以访问它们保存的值。</p><pre><code class="ts">let pets = new Set([&quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot;]);pets[&quot;species&quot;] = &quot;mammals&quot;;for (let pet in pets) {    console.log(pet); // &quot;species&quot;}for (let pet of pets) {    console.log(pet); // &quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>恋爱小技巧</title>
    <link href="/2020/05/08/life/reply/"/>
    <url>/2020/05/08/life/reply/</url>
    
    <content type="html"><![CDATA[<h3 id="如何完美的回答女生的问题"><a href="#如何完美的回答女生的问题" class="headerlink" title="如何完美的回答女生的问题"></a>如何完美的回答女生的问题</h3><p>持续更新~~</p><blockquote><p>问：在干嘛？</p><p>答：在等喜欢的人找我聊天</p></blockquote><blockquote><p>问：好无聊啊</p><p>答：谈恋爱吗？二缺一</p></blockquote><blockquote><p>问：我长得好难看啊</p><p>答：请尊重我的审美</p></blockquote><blockquote><p>问：睡了吗？</p><ul><li>直接回复女人你还没有睡。这样可以体现出你是个直爽和爽快的男人，问什么答什么这通常是很多女人所喜欢的一种性格。女人半夜问你睡没睡肯定是有事想要和你讨论，你一句没睡就为接下来的聊天埋下了伏笔，女人会问你为什么不睡，而你可以反问女人。之后两人就会对没睡的原因进行深入地探讨。女人这么晚不睡一定是有心事，再加上深夜女人的心一般都比较脆弱，你就可以借和女人聊天的机会慢慢打开女人的心房，在深夜，合适的聊天方法会起到事半功倍的效果。</li><li>把女人的“睡了吗”理解为成“在吗”，这其实是女人变相的向你打招呼的一种方式，女人总是比较含蓄的，她们不习惯开门见山地找你聊天，而是通过打招呼来吸引你的注意，所以这时你就要知道女人的目的，主动出击，挑起聊天话题。很多女人在深夜的时候都比较孤独和寂寞，这时候她们就需要找个男人来陪伴，而她们找到了你就说明你在她们心中的分量很重，这时你就可以自信地和她们畅聊。</li><li>可以以一种比较暧昧的语气回复了，比如“还没睡，要一起吗？”在深夜你可以突破白天正人君子的形象，变成一个不正经的坏男人，这样很和很多女人的胃口，如果女人问你失眠的原因你就可以说“在想你”，虽然很多女人会数落你的不正经，但其实她们的心里已经乐开了花，她们想到有人因为想她而睡不着，虚荣心得到了很大的满足，于是她们对你也会更感兴趣。这时候你再运用一些套路的话，就很容易抓住女人的心。女人因为有人迎合自己而感受到了自己的魅力，对你也会更有好感。</li></ul></blockquote><blockquote><p>问：你以后会不会喜欢上别的女生？</p><p>答：会，我喜欢明天的你比今天的你要多一点。</p></blockquote><h3 id="男生如何谈恋爱？"><a href="#男生如何谈恋爱？" class="headerlink" title="男生如何谈恋爱？"></a>男生如何谈恋爱？</h3><ul><li><p>要明白男女思维的差异性</p><p>男女之间，思想上有很大区别的。女生在感情上会感性多点，也会敏感多点，如果一个女生很爱你，则会更敏感，这既是好事也是坏事。但是男生就会理性多点，除了一些个别例子，男生遇到事情都讲理，思想有时候是一根筋 ，不会考虑太多…..正因为男女之间存在差异，因此我们需要学会怎么处理这种差异，学会包容对方的小不足，这样才能好好的走下去。</p></li><li><p>要真诚一点</p><p>要想真正的谈场恋爱，体验恋爱的美好，必须是要两情相悦的，两个人都要有颗真挚的心，不带任何复杂的关系进去，体验纯洁的爱情。因此要好好谈恋爱第一步是有颗真挚的心，真诚的对待对方，多体贴，关心对方，让对方感受到爱意。</p></li><li><p>要培养共同的爱好</p><p>共同的生活爱好和发展取向也很重要,道不同不相为谋,用在爱情实战中也是很有说服力的,没有共通点的爱情是枯燥无味的,恋爱的开始就要做到互相了解,别到了无法忍受对方的时候扔下一句“性格不合”不欢而散。</p><p>​恋爱中一定要有自己的规划和想法,本着对爱情负责的态度,多多积累必要的财富和经验,别到最后连基本的生活来源都保证不了,只是一味的抱怨女生们太现实。</p></li><li><p>多些关心</p><p>多一点关心,多打几个电话,多发几条短信,少玩点游戏多陪她们绝对没有坏处,女生们是需要爱护的物种;在忙碌的日子里,也要时不时制造一点小惊喜,时间长了爱情终将趋于平淡,一张电影票、一支鲜花制造的浪漫不亚于汽车洋房。</p><p>留心她们细微的心理变化,有时她不经意说出口的小希望,如果你却留心了并且做到了,就会把她感动的死心塌地。尽量不要尝试异地恋,距离产生的不是美,是隔阂,许多人去尝试,极个别成功了。</p></li><li><p>学会用吸引人的方法聊天</p><p>聊天只是一种表达魅力的载体，他是一种工具，而不是魅力，聊天会吸引到人，是因为一个人通过聊天表达自己了的魅力，而不是聊天这个工具在吸引人。所以聊天吸引人的前提是这个人本身就是有魅力的，有的男生知识面之贫瘠，思维方式之呆板，基础上的差异，是根本就是聊天技巧无法避免的。</p></li></ul><h3 id="确定关系之前最好慎重"><a href="#确定关系之前最好慎重" class="headerlink" title="确定关系之前最好慎重"></a>确定关系之前最好慎重</h3><p>1、你谈过多少次恋爱?现在还联系的有几个?</p><p>通过这个问题，可以了解他的感情史，看他是否是个滥情的人，如果还和前女友保持联系，你可以考虑要不要和他在一起。</p><blockquote><p>答:美好的生活，一定要有你</p></blockquote><p>2、你觉得我们身上有什么共同点吗?</p><p>通过这个问题，你可以看出他对你了不了解，看看他说的是表面的共同点(爱好)，还是更深层次的共同点(三观近)</p><p>3、你身上的缺点是什么，会去改正吗?</p><p>每个人身上都会有缺点，能够重视并且改正自己缺点的人，也才会重视感情中的分歧，并且处理好这些分歧。</p><p>4、对你来说，美好的生活应该是怎样的?</p><p>这里问的是他对生活的理解，也许可以看看他理想中的生活包含那些元素?会是什么样的?是否是你梦想中所追求的。</p><p>5、用五分钟，告诉我在此之前你的一生?</p><p>限定时间，让对方讲述自己的过往，能够让你更加了解对方，而不仅仅停留在过去偶尔聊天聊到的印象里。</p><p>6、用五分钟，描述一下你认识的我是怎样的?</p><p>问题可以让你知道，你在对方的心目中是怎样的存在这点，对于你自己来说，也是很重要的，对吧</p><p>7、你有哪件事是一直想做，但是没做成的吗?为什么没做成?</p><p>想做的事情，会是他的梦想;完不成的梦想，会是他的遗憾这个问题，可以让你看到一个不一样的他。</p><p>8、你一生之中最大的成就是什么?</p><p>听我说，要是一个人说，他最大的成就是追到你或者遇见你，那你心里得留个底恋爱不是成就，只能是水到渠成的事平时当情话听可以，但这种场合，你要的是答案，而不是情话。</p><p>9、你和亲人的关系怎样?</p><p>和亲人关系不好的话，可能会有什么原因，这个原因你要去了解，因为亲人是成长过程中的特殊因素之一，会影响他后来待人处事的态度</p><p>10、什么事情(如果有这样的事的话)是严肃得容不得开玩笑的?</p><p>通过这个问题，可以了解一下对方的尺度，看看哪些是不能触碰的话题。</p><p>11、说说你一生中最尴尬的时刻?</p><p>能把自己最尴尬的时刻分享给你的人，一定是把你当成自己人了</p><p>12、你觉得恋爱关系是一种什么关系?</p><p>爱到底是什么呢?这是一个值得深思的问题，既是问对方，也是问自己。</p><p>13、你觉得恋爱双方各自有什么权利和义务?</p><p>进一步了解对方对于恋爱的看法，并且可以借此划定双方的权利和义务，在未来的恋爱过程中，就可以遵循双方共同承认的规矩。</p><p>14、恋爱中发生争吵了，应该怎么沟通解决?</p><p>就连父母和孩子间都会发生争吵，哪有不会发生争吵的恋爱关系呢?重要的不是去避免争吵，而争吵过后的沟通和及解决之道好的态度，才会让恋爱走得更远。</p><p>15、恋爱关系的破裂，在你看来会出于什么原因?</p><p>提前预知你们的关系会因为什么而破裂，然后尽量避免去触碰那些原因好好对待的话，或许感情就不会消失了。</p><p>16、面对破裂的恋爱关系，你会如何处理?</p><p>守也要有点讲究，纠缠得太久，对双方都不是件好事提前打个预防针，不是看衰这段感情，反而是对双方感情的负责不浪费对方的年华，是一种美德。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>恋爱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的Symbol</title>
    <link href="/2020/05/08/ts/symbol/"/>
    <url>/2020/05/08/ts/symbol/</url>
    
    <content type="html"><![CDATA[<h3 id="1-ES6新增基本数据类型"><a href="#1-ES6新增基本数据类型" class="headerlink" title="1.ES6新增基本数据类型"></a>1.ES6新增基本数据类型</h3><blockquote><p>自ECMAScript 2015起，<code>symbol</code>成为了一种新的原生类型，表示独一无二的值。就像<code>number</code>和<code>string</code>一样。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。<code>symbol</code>类型的值是通过<code>Symbol</code>构造函数创建的。</p></blockquote><pre><code class="ts">let sym1 = Symbol();let sym2 = Symbol(&quot;key&quot;); // 可选的字符串key</code></pre><p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p>如何访问Symbol的描述，如上及如何访问到 “key”</p><p><a href="https://github.com/tc39/proposal-Symbol-description" target="_blank" rel="noopener">ES2019</a> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。</p><pre><code class="ts">const sym = Symbol(&#39;key&#39;);sym.description // &quot;key&quot;</code></pre><h3 id="2-Symbol是不可改变且唯一的"><a href="#2-Symbol是不可改变且唯一的" class="headerlink" title="2.Symbol是不可改变且唯一的"></a>2.Symbol是不可改变且唯一的</h3><pre><code class="ts">// 无参数的情况let sym2 = Symbol();let sym3 = Symbol();sym2 === sym3; // false, symbol是唯一的// 有参数的情况let s1 = Symbol(&#39;foo&#39;);let s2 = Symbol(&#39;foo&#39;);s1 === s2 // false, symbol是唯一的</code></pre><h3 id="3-Symbol-值不能与其他类型的值进行运算"><a href="#3-Symbol-值不能与其他类型的值进行运算" class="headerlink" title="3.Symbol 值不能与其他类型的值进行运算"></a>3.Symbol 值不能与其他类型的值进行运算</h3><pre><code class="ts">let sym = Symbol(&#39;My symbol&#39;);&quot;your symbol is &quot; + sym   // TypeError: can&#39;t convert symbol to string`your symbol is ${sym}`   // TypeError: can&#39;t convert symbol to string</code></pre><p>但是，Symbol 值可以显式转为字符串。</p><pre><code class="ts">let sym = Symbol(&#39;My symbol&#39;);String(sym) // &#39;Symbol(My symbol)&#39;sym.toString() // &#39;Symbol(My symbol)&#39;</code></pre><p>Symbol 值也可以转为布尔值，但是不能转为数值。</p><pre><code class="ts">let sym = Symbol();Boolean(sym) // true!sym  // falseif (sym) {  // ...}Number(sym) // TypeErrorsym + 2 // TypeError</code></pre><h3 id="4-Symbol可以被用做对象属性的键"><a href="#4-Symbol可以被用做对象属性的键" class="headerlink" title="4.Symbol可以被用做对象属性的键"></a>4.Symbol可以被用做对象属性的键</h3><pre><code class="ts">let sym1 = Symbol();let obj = {    [sym1]: &quot;value&quot;};console.log(obj[sym1]); // &quot;value&quot;</code></pre><h3 id="5-Symbol可以与计算出的属性名声明相结合来声明对象的属性和类成员"><a href="#5-Symbol可以与计算出的属性名声明相结合来声明对象的属性和类成员" class="headerlink" title="5.Symbol可以与计算出的属性名声明相结合来声明对象的属性和类成员"></a>5.Symbol可以与计算出的属性名声明相结合来声明对象的属性和类成员</h3><pre><code class="ts">const sym = Symbol();class Abc {    [sym](){       return &quot;ABC&quot;;    }}let c = new Abc();let className = c[sym](); // &quot;ABC&quot;</code></pre><h3 id="6-内置的-Symbol-值"><a href="#6-内置的-Symbol-值" class="headerlink" title="6.内置的 Symbol 值"></a>6.内置的 Symbol 值</h3><p>参考：<a href="https://es6.ruanyifeng.com/#docs/symbol#内置的-Symbol-值" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/symbol#%E5%86%85%E7%BD%AE%E7%9A%84-Symbol-%E5%80%BC</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的类型推论</title>
    <link href="/2020/05/07/ts/type-inference/"/>
    <url>/2020/05/07/ts/type-inference/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是类型推论"><a href="#1-什么是类型推论" class="headerlink" title="1.什么是类型推论"></a>1.什么是类型推论</h3><blockquote><p>TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型</p></blockquote><pre><code class="ts">let x = 3;</code></pre><p>变量<code>x</code>的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p><h3 id="2-最佳通用类型"><a href="#2-最佳通用类型" class="headerlink" title="2.最佳通用类型"></a>2.最佳通用类型</h3><blockquote><p>当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。</p></blockquote><pre><code class="ts">let x = [0, 1, null];</code></pre><p>为了推断<code>x</code>的类型，我们必须考虑所有元素的类型。<br>这里有两种选择： <code>number</code>和<code>null</code>。<br>计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p><p>由于最终的<code>通用类型</code>取自<code>候选类型</code>，有些时候<code>候选类型</code>共享相同的<code>通用类型</code>，但是却没有一个类型能做为所有候选类型的类型。例如：</p><pre><code class="ts">let zoo = [new Rhino(), new Elephant(), new Snake()];</code></pre><p>这里，我们想让zoo被推断为<code>Animal[]</code>类型，但是这个数组里没有对象是<code>Animal</code>类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：</p><pre><code class="ts">let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];</code></pre><p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Rhino | Elephant | Snake)[]</code>。</p><h3 id="3-上下文类型"><a href="#3-上下文类型" class="headerlink" title="3.上下文类型"></a>3.上下文类型</h3><blockquote><p>TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如：</p></blockquote><pre><code class="ts">window.onmousedown = function(mouseEvent) {    console.log(mouseEvent.button);  //&lt;- Error};</code></pre><p>这个例子会得到一个类型错误，TypeScript类型检查器使用<code>Window.onmousedown</code>函数的类型来推断右边函数表达式的类型。 因此，就能推断出 <code>mouseEvent</code>参数的类型了。 如果函数表达式不是在上下文类型的位置， <code>mouseEvent</code>参数的类型需要指定为<code>any</code>，这样也不会报错了。</p><p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。 重写上面的例子：</p><pre><code class="ts">window.onmousedown = function(mouseEvent: any) {    console.log(mouseEvent.button);  //&lt;- Now, no error is given};</code></pre><p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。 这样的话就不报错了，因为这里不会使用到上下文类型。</p><ul><li><p>上下文归类会在很多情况下使用到。 </p></li><li><p>通常包含<code>函数的参数</code>，<code>赋值表达式的右边</code>，<code>类型断言</code>，<code>对象成员</code>和<code>数组字面量</code>和<code>返回值语句</code>。 </p></li><li><p>上下文类型也会做为最佳通用类型的候选类型。比如：</p></li></ul><pre><code class="ts">function createZoo(): Animal[] {    return [new Rhino(), new Elephant(), new Snake()];}</code></pre><p>这个例子里，最佳通用类型有4个候选者：<code>Animal</code>，<code>Rhino</code>，<code>Elephant</code>和<code>Snake</code>。<br>当然， <code>Animal</code>会被做为最佳通用类型。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你一定要知道的护肤品牌</title>
    <link href="/2020/05/07/life/you-konw/"/>
    <url>/2020/05/07/life/you-konw/</url>
    
    <content type="html"><![CDATA[<h4 id="1-洗面奶-芙丽芳丝（freeplus）（￥150）"><a href="#1-洗面奶-芙丽芳丝（freeplus）（￥150）" class="headerlink" title="1.洗面奶 芙丽芳丝（freeplus）（￥150）"></a>1.洗面奶 芙丽芳丝（freeplus）（￥150）</h4><blockquote><p>氨基酸洗面奶，以温和无刺激著称。也刚好适合油痘肌使用。主打就是温和、无添加、低刺激，敏感肌用会很好，温和舒适 很舒服</p></blockquote><p>官网：<a href="https://www.freeplus.cn/freeplus/products/skincare05/" target="_blank" rel="noopener">https://www.freeplus.cn/freeplus/products/skincare05/</a></p><p><img src="/img/life/sk-ll/freeplus.jpg" srcset="/img/loading.gif" alt="freeplus"></p><h3 id="2-爽肤水-护肤精华露-SK-ll神仙水-（￥1540）"><a href="#2-爽肤水-护肤精华露-SK-ll神仙水-（￥1540）" class="headerlink" title="2.爽肤水/护肤精华露 SK-ll神仙水 （￥1540）"></a>2.爽肤水/护肤精华露 SK-ll神仙水 （￥1540）</h3><blockquote><p>SK-II 护肤精华露（神仙水®）改变你的肌肤，令肌肤变得晶莹剔透，嫩滑、紧致、焕发动人光彩。35 年来始终如一。备受瞩目、畅销全球的 SK-II 护肤精华露（神仙水®）蕴含超过90%的天然生物成分PITERA™，集维生素、矿物质和氨基酸等多种微量营养素于一身。</p></blockquote><p>官网：<a href="https://www.skii.com.cn/sc/product-detail.aspx?name=facial-treatment-essence&amp;from=bestsellers" target="_blank" rel="noopener">https://www.skii.com.cn/sc/product-detail.aspx?name=facial-treatment-essence&amp;from=bestsellers</a></p><p><img src="/img/life/sk-ll/sk-ll.jpg" srcset="/img/loading.gif" alt="sk-ll"></p><h3 id="3-眼霜-雅诗兰黛小棕瓶（￥510）"><a href="#3-眼霜-雅诗兰黛小棕瓶（￥510）" class="headerlink" title="3.眼霜 雅诗兰黛小棕瓶（￥510）"></a>3.眼霜 雅诗兰黛小棕瓶（￥510）</h3><blockquote><p>刷屏不怕黑眼圈 水·亮·弹·嫩</p><p>雅诗兰黛发现：电子屏里的蓝光伤害无处不在，打乱肌肤夜间自我修护。现代人过度刷屏，更长时间暴露在蓝光伤害下，让眼周加速老化，多重眼部问题提前出现。全新小棕瓶“熬夜”眼霜，升级浓缩修护科技<em>。唤启并放大眼周自我修护力。<br>•淡黑眼圈</em> · 透亮<br>•有效抗氧* · 匀净<br>•长效保湿* · 水嫩蓝光不再怕，黑眼圈、干纹、细纹一一挥别双眸水亮弹嫩，任性刷屏，刷新年轻！</p></blockquote><p>官网：<a href="https://www.esteelauder.com.cn/product/685/55125/product-catalog/advanced-night-repair" target="_blank" rel="noopener">https://www.esteelauder.com.cn/product/685/55125/product-catalog/advanced-night-repair</a></p><p><img src="/img/life/sk-ll/estee-lauder.png" srcset="/img/loading.gif" alt="Estee Lauder-1"></p><h3 id="4-祛痘-朵呼吸凝胶-（￥79）"><a href="#4-祛痘-朵呼吸凝胶-（￥79）" class="headerlink" title="4.祛痘 朵呼吸凝胶 （￥79）"></a>4.祛痘 朵呼吸凝胶 （￥79）</h3><p>官网：<a href="http://dhxnj.cn/" target="_blank" rel="noopener">http://dhxnj.cn/</a></p><p><img src="/img/life/sk-ll/duohuxi.jpg" srcset="/img/loading.gif" alt="duohuxi"></p><h3 id="5-精华-兰蔻小黑瓶-50ml（￥1080）"><a href="#5-精华-兰蔻小黑瓶-50ml（￥1080）" class="headerlink" title="5.精华 兰蔻小黑瓶 50ml（￥1080）"></a>5.精华 兰蔻小黑瓶 50ml（￥1080）</h3><p>官网：<a href="https://www.lancome.com.cn/item/LAN00352-017" target="_blank" rel="noopener">https://www.lancome.com.cn/item/LAN00352-017</a></p><p><img src="/img/life/sk-ll/lancome.jpg" srcset="/img/loading.gif" alt="lancome"></p><h3 id="6-面霜-海蓝之谜60ml（￥2550）"><a href="#6-面霜-海蓝之谜60ml（￥2550）" class="headerlink" title="6.面霜 海蓝之谜60ml（￥2550）"></a>6.面霜 海蓝之谜60ml（￥2550）</h3><blockquote><p>丰盈质地，经典奢华。柔嫩润泽，修护滋养，由内而外焕现健康光采。品牌灵魂成分，修护秘方－神奇活性精萃 Miracle Broth™, 融入每一次奢华体验, 可为肌肤注入源自海洋的焕新能量。适合各种肤质。</p></blockquote><p>官网：<a href="https://www.lamer.com.cn/product/24367/12343/creme-de-la-mer/creme-de-la-mer#/sku/26766" target="_blank" rel="noopener">https://www.lamer.com.cn/product/24367/12343/creme-de-la-mer/creme-de-la-mer#/sku/26766</a></p><p><img src="/img/life/sk-ll/lamer.png" srcset="/img/loading.gif" alt="lamer"></p><h3 id="7-防嗮-安热沙60ml-（￥238）"><a href="#7-防嗮-安热沙60ml-（￥238）" class="headerlink" title="7.防嗮 安热沙60ml （￥238）"></a>7.防嗮 安热沙60ml （￥238）</h3><p>官网：<a href="http://www.anessa.cn/products/suncare/perfect_uv_ab/" target="_blank" rel="noopener">http://www.anessa.cn/products/suncare/perfect_uv_ab/</a></p><p><img src="/img/life/sk-ll/anessa.png" srcset="/img/loading.gif" alt="anessa"></p><h3 id="8-隔离-兰芝隔离-（￥245）"><a href="#8-隔离-兰芝隔离-（￥245）" class="headerlink" title="8.隔离 兰芝隔离 （￥245）"></a>8.隔离 兰芝隔离 （￥245）</h3><blockquote><ol><li>修正肤色</li></ol><p>雪纱系列特有的雪纱遮瑕配方，快速修正泛黄、泛红肤色，同时提升肤色，让妆容持久透亮。呈现自然裸透肤色</p><ol start="2"><li>搭配粉底液 打造无瑕肌肤</li></ol><p>轻质粉末质地，即使多次涂抹，也不会结块，呈现洁净妆容。</p><ol start="3"><li>如雪纱般轻柔的肌肤</li></ol><p>使用柔软质感的柔软奶油质地（Soft Creamy Texture），呈现如同覆盖了雪纱般的柔软肌理</p></blockquote><p>官网：<a href="http://www.laneige.com.cn/product/skincare/category/cc_base/index.html" target="_blank" rel="noopener">http://www.laneige.com.cn/product/skincare/category/cc_base/index.html</a></p><p><img src="/img/life/sk-ll/laneige.png" srcset="/img/loading.gif" alt="laneige"></p><h3 id="9-散粉-纪梵希四宫格（￥550）"><a href="#9-散粉-纪梵希四宫格（￥550）" class="headerlink" title="9.散粉 纪梵希四宫格（￥550）"></a>9.散粉 纪梵希四宫格（￥550）</h3><blockquote><p>纪梵希明星四色散粉，轻盈如羽，通透如光！<br>超声波震动雾化技术创造出细腻轻盈的粉妆。<br>自然定妆，均匀肤色，同时提升肌肤的自然光泽。<br>4色调合，为不同肤色量身定制色彩搭配，增加肌肤自然光采。<br>包装更奢华制作了仿皮质纹理效果的顶盖配合烫银4G logo，打造纪梵希高定彩妆形象。质地轻盈柔滑的质地，妆效清透</p></blockquote><ul><li>仿若无物，保持肌肤舒适感</li><li>为不同肤色定制，自然提亮</li><li>精致妆效，长效定妆</li></ul><p>官网：<a href="https://www.givenchybeauty.cn/p/纪梵希明星四宫格散粉-F20100045.html?dwvar_F20100045_color=MULTICOLOR-1" target="_blank" rel="noopener">https://www.givenchybeauty.cn/p/%E7%BA%AA%E6%A2%B5%E5%B8%8C%E6%98%8E%E6%98%9F%E5%9B%9B%E5%AE%AB%E6%A0%BC%E6%95%A3%E7%B2%89-F20100045.html?dwvar_F20100045_color=MULTICOLOR-1</a></p><p><img src="/img/life/sk-ll/givenchy.png" srcset="/img/loading.gif" alt="givenchy"></p><h3 id="10-口红-迪奥999-（￥320-）"><a href="#10-口红-迪奥999-（￥320-）" class="headerlink" title="10.口红 迪奥999 （￥320 ）"></a>10.口红 迪奥999 （￥320 ）</h3><blockquote><p>高订色彩，缎光妆效，Dior迪奥烈艳蓝金唇膏持色舒适配方，为女性带来美妙的享受。</p><p>经典红色系、热烈珊瑚红、热情欢乐的粉色系、浪漫迷人的紫红，以及一系列前卫色彩，呈献唇妆惊喜。</p><p>这款唇膏暗藏玄机的迪奥全新金属外壳具有非凡吸引力：为了彰显一抹个性奢华魅力，唇膏盖内皆以Dior迪奥的经典迷人色彩——#传奇红唇（#999）的色彩装点。</p></blockquote><p>官网：</p><p><a href="https://www.dior.cn/zh_cn/products/beauty-Y0038009-全新dior迪奥烈艳蓝金挚红唇膏?objectID=Y0038009&query=口红999&queryID=d24efcd2fe2cac1b651f48eefb1c3776" target="_blank" rel="noopener">https://www.dior.cn/zh_cn/products/beauty-Y0038009-%E5%85%A8%E6%96%B0dior%E8%BF%AA%E5%A5%A5%E7%83%88%E8%89%B3%E8%93%9D%E9%87%91%E6%8C%9A%E7%BA%A2%E5%94%87%E8%86%8F?objectID=Y0038009&amp;query=%E5%8F%A3%E7%BA%A2999&amp;queryID=d24efcd2fe2cac1b651f48eefb1c3776</a></p><p><img src="/img/life/sk-ll/dior999.png" srcset="/img/loading.gif" alt="dior999"></p><h3 id="11-眉笔-爱丽小屋-（￥19）"><a href="#11-眉笔-爱丽小屋-（￥19）" class="headerlink" title="11.眉笔 爱丽小屋 （￥19）"></a>11.眉笔 爱丽小屋 （￥19）</h3><h3 id="12-眼线笔-kissme-（￥89）"><a href="#12-眼线笔-kissme-（￥89）" class="headerlink" title="12.眼线笔 kissme （￥89）"></a>12.眼线笔 kissme （￥89）</h3><h3 id="13-香水-香奈儿N5-50ml-（￥1060）"><a href="#13-香水-香奈儿N5-50ml-（￥1060）" class="headerlink" title="13.香水 香奈儿N5 50ml （￥1060）"></a>13.香水 香奈儿N5 50ml （￥1060）</h3><blockquote><p>N°5五号香水，彰显十足女性魅力。极简线条的经典瓶身，一捧感性优雅的抽象花束，一款经典永恒的香水。<br>嗅觉氛围<br>开瓶的柑橘香调，轻快地引出由五月玫瑰与格拉斯茉莉所组成的芬芳花束，香草的柔软触感，延续香水的感性魅力。<br>创作灵感<br>1921年，嘉柏丽尔·香奈儿与调香师恩尼斯·鲍合作，创造出“一款闻起来像女人的香水”。香奈儿女士从创作的香水配方中选择了第5号香水样本，并保留这个数字作为香水的名称。她为这瓶全新香水挑选了一个简洁的瓶身，饰以白色标签与钻石刻面瓶盖。<br>1986年，贾克·波巨传承恩尼斯·鲍经典创作N°5的嗅觉氛围，重新演绎，推出层次更丰富的五号香水。<br>香氛艺术<br>喷式香水能随心地使用于皮肤或衣服内侧。</p></blockquote><p>官网：<a href="https://www.chanel.cn/zh_CN/fragrance-beauty/fragrance/p/women/n_5/n_5-eau-de-parfum-spray-p125420.html#skuid-0125430" target="_blank" rel="noopener">https://www.chanel.cn/zh_CN/fragrance-beauty/fragrance/p/women/n_5/n_5-eau-de-parfum-spray-p125420.html#skuid-0125430</a></p><p><img src="/img/life/sk-ll/chanel.jpg" srcset="/img/loading.gif" alt="chanel"></p><h3 id="14-卸妆水-贝德玛卸妆水-（￥120）"><a href="#14-卸妆水-贝德玛卸妆水-（￥120）" class="headerlink" title="14.卸妆水 贝德玛卸妆水 （￥120）"></a>14.卸妆水 贝德玛卸妆水 （￥120）</h3><blockquote><p>贝德玛卸妆水由法国崭新科技 MICELLE 配方组成 , 内含水溶及油溶份子可全面洗净肌肤毛孔内外污垢，再加上青瓜植物精华，用後绝不绷紧。成份简单，不含香料，敏感肌肤亦可使用．专利 MICELLE 洁肤配方「 BIODERMA 洁肤水」的 Micelle 溶妆粒子，特有水溶及油溶份子，可溶解面上及毛孔内的的污垢。 Feel 得到的毛孔乾净 天然青瓜植物精华赶走洁面後的绷绷紧。水般的清爽质感 如水般的清爽质感，没有一般洁肤油或 GEL 那种笠黏黏感觉。通过水洁肤程序讲 BYE BYE 只需倒适量在洁肤棉上後，往面部轻轻一抹，污垢立即变走，无须再过水。</p></blockquote><p>官网：<a href="https://www.bioderma.net.cn/series/sensibio/h2o.html" target="_blank" rel="noopener">https://www.bioderma.net.cn/series/sensibio/h2o.html</a></p><p><img src="/img/life/sk-ll/bioderma.png" srcset="/img/loading.gif" alt="bioderma"></p><h3 id="15-使用方式"><a href="#15-使用方式" class="headerlink" title="15.使用方式"></a>15.使用方式</h3><h4 id="1-洗面奶"><a href="#1-洗面奶" class="headerlink" title="1.洗面奶"></a>1.洗面奶</h4><p>1.洗脸前将脸部打湿，将本品加水在掌心打出丰富泡沫，然后把泡沫清洁脸部<br>2.以清水或温水彻底冲净<br>3.耗量：早晚用约40天</p><h4 id="2-清莹露"><a href="#2-清莹露" class="headerlink" title="2.清莹露"></a>2.清莹露</h4><p>用化妆棉浸透化妝水，然后擦拭T区、从中间向外擦拭U区，最后擦拭头部。（眼周肌肤一带而过），每次用量为一元硬币大小。</p><h4 id="3-神仙水"><a href="#3-神仙水" class="headerlink" title="3.神仙水"></a>3.神仙水</h4><p>步骤1：在手掌上滴上3-5滴精华露。然后将两只手压在一起，让双手手掌变湿润；<br>步骤2：轻拍您的脸部。重复步骤1和步骤2两到三遍；<br>步骤3：继续轻拍精华液，直到精华液全部吸收为止。<br>小贴士：记住哦，颈部也要和脸部一样多加关注呢，最重要的就是轻拍的动作，对面部施加轻柔的压力能够更好促进吸收，所以要轻拍、轻拍、再轻拍！坚持早晚使用神仙水才会有更好的效果哦！ </p><h4 id="4-面霜"><a href="#4-面霜" class="headerlink" title="4.面霜"></a>4.面霜</h4><p>取約黄豆粒大小乳霜于掌心，五点式均匀涂抹于面部，轻轻地全面向外涂开</p><h4 id="5-眼霜"><a href="#5-眼霜" class="headerlink" title="5.眼霜"></a>5.眼霜</h4><ul><li>以无名指取适量眼霜，按上出下入的方法，从眼角到眼尾涂抹开；</li><li>手指将眼角纹撑开，并用无名指在在皱纹处轻轻打圈；</li><li>将眼霜放在手掌根部，用掌根对错，焐热。再以掌根部轻轻按压，舒缓眼部并帮助吸收。</li></ul>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>护肤</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的枚举</title>
    <link href="/2020/05/06/ts/enum/"/>
    <url>/2020/05/06/ts/enum/</url>
    
    <content type="html"><![CDATA[<h3 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1.枚举"></a>1.枚举</h3><blockquote><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。</p></blockquote><h3 id="2-数字枚举"><a href="#2-数字枚举" class="headerlink" title="2.数字枚举"></a>2.数字枚举</h3><pre><code class="ts">enum Direction {    Up = 1,    Down,    Left,    Right}</code></pre><p>定义了一个数字枚举， <code>Up</code>使用初始化为 <code>1</code>。 其余的成员会从 <code>1</code>开始自动增长。 换句话说， <code>Direction.Up</code>的值为 <code>1</code>， <code>Down</code>为 <code>2</code>， <code>Left</code>为 <code>3</code>， <code>Right</code>为 <code>4</code>。</p><p>不使用初始化器<code>Up</code>的值为 <code>0</code>， <code>Down</code>的值为<code>1</code></p><h3 id="3-字符串枚举"><a href="#3-字符串枚举" class="headerlink" title="3.字符串枚举"></a>3.字符串枚举</h3><blockquote><p>字符串枚举的概念很简单，但是有细微的 <a href="https://www.tslang.cn/docs/handbook/enums.html#enums-at-runtime" target="_blank" rel="noopener">运行时的差别</a>。 在一个字符串枚举里，每个成员都必须用<code>字符串字面量</code>，或另外一个字符串枚举成员进行初始化。</p></blockquote><pre><code class="ts">enum Direction {    Up = &quot;UP&quot;,    Down = &quot;DOWN&quot;,    Left = &quot;LEFT&quot;,    Right = &quot;RIGHT&quot;,}</code></pre><p>字符串枚举没有自增长的行为</p><h3 id="4-异构枚举"><a href="#4-异构枚举" class="headerlink" title="4.异构枚举"></a>4.异构枚举</h3><pre><code class="ts">enum BooleanLikeHeterogeneousEnum {    No = 0,    Yes = &quot;YES&quot;,}</code></pre><p>从技术的角度来说，枚举可以混合字符串和数字成员，但并不推荐这么做。</p><h3 id="5-计算的和常量成员"><a href="#5-计算的和常量成员" class="headerlink" title="5.计算的和常量成员"></a>5.计算的和常量成员</h3><blockquote><p>每个枚举成员都带有一个值，它可以是 <code>常量</code>或 <code>计算</code>出来的。 当满足如下条件时，枚举成员被当作是常量：</p></blockquote><ul><li><p>它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 <code>0</code></p><pre><code class="ts">// Direction.Up is constant: 0enum Direction { Up }</code></pre></li><li><p>它不带有初始化器且它之前的枚举成员是一个 <em>数字</em>常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加1。</p><pre><code class="ts">enum Direction {    Up = 1,    Down,    Left,    Right}</code></pre></li><li><p>枚举成员使用 <code>常量枚举表达式</code>初始化。 常量枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：</p><ul><li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li><li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li><li>带括号的常量枚举表达式</li><li>一元运算符 <code>+</code>, <code>-</code>, <code>~</code>其中之一应用在了常量枚举表达式</li><li>常量枚举表达式做为二元运算符 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>的操作对象。 若常数枚举表达式求值后为 <code>NaN</code>或 <code>Infinity</code>，则会在编译阶段报错。</li></ul><pre><code class="ts">enum FileAccess {    // constant members    None,    Read    = 1 &lt;&lt; 1,    Write   = 1 &lt;&lt; 2,    ReadWrite  = Read | Write,    // computed member    G = &quot;123&quot;.length}</code></pre></li></ul><h3 id="6-反向映射"><a href="#6-反向映射" class="headerlink" title="6.反向映射"></a>6.反向映射</h3><blockquote><p>除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了 <em>反向映射</em>，从枚举值到枚举名字。 例如，在下面的例子中：</p></blockquote><pre><code class="TS">  enum Enum {      A  }  let a = Enum.A;  let nameOfA = Enum[a]; // &quot;A&quot;</code></pre><p>  要注意的是<em>不会</em>为字符串枚举成员生成反向映射。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的装饰器</title>
    <link href="/2020/05/05/ts/decorator/"/>
    <url>/2020/05/05/ts/decorator/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是装饰器"><a href="#1-什么是装饰器" class="headerlink" title="1.什么是装饰器"></a>1.什么是装饰器</h3><p>装饰器是一种特殊类型的声明，它能够被附加到类，方法，属性或参数上，可以修改类的行为。<br>通俗的讲装饰器就是一个方法，可以注入到类，方法，属性参数上来拓展类，属性，方法，参数的功能。<br>常见的装饰器：</p><ul><li>类装饰器     </li><li>属性装饰器   </li><li>方法装饰器   </li><li>参数装饰器</li></ul><p>装饰器的写法：</p><ul><li>普通装饰器（无法传参）       </li><li>装饰器工厂（可传参）</li></ul><h3 id="2-类装饰器"><a href="#2-类装饰器" class="headerlink" title="2.类装饰器"></a>2.类装饰器</h3><blockquote><p>类装饰器—-普通装饰器(无法传参)</p></blockquote><pre><code class="ts">function logClass(params: any) {    console.log(params) //当前类    //TODO ① 拓展-属性    params.prototype.apiUrl = &#39;https://www.bilibili.com/video/av38379328/?p=19&#39;;    // TODO ② 拓展-方法    params.prototype.get = function(){        console.log(&#39;我是拓展的方法&#39; + this.apiUrl);    }}@logClassclass HttpClient {    constructor() {    }    getData() {    }}let http: any = new HttpClient();//TODO ① 访问拓展的属性console.log(http.apiUrl); //https://www.bilibili.com/video/av38379328/?p=19//TODO ② 访问拓展的方法http.get(); // 我是拓展的方法https://www.bilibili.com/video/av38379328/?p=19</code></pre><blockquote><p>类装饰器—-装饰器工厂(可传参)—返回一个函数</p></blockquote><pre><code class="ts">function logClass(params: string) {    return function (target: any) {        console.log(params) // 传入的参数 https://www.bilibili.com/video/av38379328/?p=19        console.log(target) // 当前类        // 拓展 apiUrl 属性，其值为传入的 params;        target.prototype.apiUrl = params;    }}@logClass(&#39;https://www.bilibili.com/video/av38379328/?p=19&#39;)class HttpClient {    constructor() {    }    getData() {    }}let http: any = new HttpClient();console.log(&#39;使用装饰器工厂拓展的属性&#39;, http.apiUrl); //使用装饰器工厂拓展的属性 https://www.bilibili.com/video/av38379328/?p=19</code></pre><blockquote><p>类装饰器-重载构造函数的例子—返回一个继承于当前类的子类</p></blockquote><pre><code class="ts">// 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。// 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。function logClass(target: any) {    console.log(target) // target 当前类    return class extends target {        // TODO ① 重载apiUrl的值        apiUrl = &#39;我是修改后的数据  https://www.bilibili.com/video/av38379328/?p=19&#39;;        // TODO ② HttpClient类里面的方法被重载了        getData() {            this.apiUrl += &#39;---&#39;;            console.log(this.apiUrl)        }    }}@logClassclass HttpClient {    public apiUrl: string | undefined;    constructor() {        // TODO ① 初始化apiUrl的值        this.apiUrl = &quot;我是constructor里面的apiUrl&quot;;    }    // TODO ② HttpClient类里面的方法    getData() {        console.log(this.apiUrl);    }}let http: any = new HttpClient();http.getData(); // 我是修改后的数据  https://www.bilibili.com/video/av38379328/?p=19---</code></pre><h3 id="3-属性装饰器"><a href="#3-属性装饰器" class="headerlink" title="3.属性装饰器"></a>3.属性装饰器</h3><p>属性装饰器表达式会在运行时当作函数被调用，传入2个参数<br>1.对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。<br>2.成员的名称。</p><pre><code class="ts">// 1.实例成员function logProperty(params: string) {    return function (target: any, attrName: string) {        console.log(params); // http://www.baidu.com        console.log(target); // TODO ① HttpClient 这个类的原型对象（即:HttpClient.prototype）  HttpClient { getData: [Function] }        console.log(attrName) //apiUrl        target[attrName] = params;    }}class HttpClient {    @logProperty(&#39;http://www.baidu.com&#39;)    public apiUrl: string | undefined; //TODO ① 这里声明为实例属性    constructor() {    }    getData() {        console.log(this.apiUrl);    }}let http: any = new HttpClient();http.getData(); // http://www.baidu.com</code></pre><pre><code class="ts">//2.静态成员function logProperty(params: string) {    return function (target: any, attrName: string) {        console.log(params); // http://www.baidu.com/2        console.log(target);// TODO ② HttpClient 这个类  [Function: HttpClient]        console.log(attrName) //apiUrl2        target[attrName] = params; //由于是静态属性 这里就直接把params 挂到类上    }}class HttpClient {    @logProperty(&#39;http://www.baidu.com/2&#39;)    static apiUrl2: string | undefined; //TODO ② 这里声明为静态成员    constructor() {    }    getData() {        console.log(HttpClient.apiUrl2); // 静态属性通过 HttpClient.属性名 来访问    }}let http: any = new HttpClient();http.getData(); // http://www.baidu.com/2</code></pre><h3 id="4-方法装饰器"><a href="#4-方法装饰器" class="headerlink" title="4.方法装饰器"></a>4.方法装饰器</h3><p>它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。<br>方法装饰器表达式会在运行时当作函数被调用，传入3个参数<br>1.对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。<br>2.成员的名称。<br>3.成员的属性描述符。</p><pre><code class="ts">//这里只演示：实例成员function logFunc(params: string) {    return function (target: any, funcName: string, desc: any) {        console.log(params); // http://www.jd.com        console.log(target); // HttpClient.prototype        console.log(funcName); // getData        console.log(desc);        /*            {                 value: [Function],                writable: true,                enumerable: true,                configurable: true             }        */        // 修改装饰的方法（操作desc.value） 把装饰器方法里面传入的参数全部修改为string类型。        // 1.保存当前方法        let oldFunc = desc.value;        // 2.重写 desc.value        desc.value = function (...args: any[]) {            console.log(args); // [123, &#39;456&#39;]            // 3.转换为String            args = args.map(value =&gt; {                return String(value);            })            console.log(args); // [ &#39;123&#39;, &#39;456&#39; ]            // 4.选择替换该方法还是给方法增加功能            oldFunc.apply(this, args); // 加上这个就会执行HttpClient 类里面的getData 方法。            // 不加 就是把【HttpClient 类里面的getData 方法】给替换了。        }    }}class HttpClient {    apiUrl: string | undefined;    constructor() {    }    @logFunc(&#39;http://www.jd.com&#39;)    getData(...args: any[]) {        console.log(args); // 经过装饰器的修改，这里全部被转为了String类型 [ &#39;123&#39;, &#39;456&#39; ]        console.log(&#39;我是getData&#39;);    }}let http: any = new HttpClient();http.getData(123, &#39;456&#39;);</code></pre><h3 id="5-方法参数装饰器（不常用）"><a href="#5-方法参数装饰器（不常用）" class="headerlink" title="5.方法参数装饰器（不常用）"></a>5.方法参数装饰器（不常用）</h3><p>参数装饰器表达式会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元数据，传入3个参数<br>1.对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。<br>2.方法的名称。<br>3.参数在函数参数列表中的索引。</p><pre><code class="ts">function logParams(params: string) {    return function (target: any, funcName: string, paramsIndex: number) {        console.log(params) // name         id        console.log(target) // HttpClient.prototype        console.log(funcName) // getData        console.log(paramsIndex) // 1       0    }}class HttpClient {    url: any | undefined;    constructor() {    }    getData(        @logParams(&#39;id&#39;) id: number, //后执行        @logParams(&#39;name&#39;) name: string // 先执行    ) {    }}</code></pre><h3 id="6-执行顺序"><a href="#6-执行顺序" class="headerlink" title="6.执行顺序"></a>6.执行顺序</h3><blockquote><p>属性装饰器—&gt;方法装饰器—&gt;方法参数装饰器—&gt;类装饰器<br>如果有多个同样的装饰器都是 从后到前执行</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的泛型</title>
    <link href="/2020/05/04/ts/generics/"/>
    <url>/2020/05/04/ts/generics/</url>
    
    <content type="html"><![CDATA[<h3 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h3><p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。<br>组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。<br>通俗理解：泛型就是解决 类，接口，函数的复用性，以及对不特定的数据类型的支持。</p><h3 id="2-泛型函数"><a href="#2-泛型函数" class="headerlink" title="2.泛型函数"></a>2.泛型函数</h3><pre><code class="ts">function getData&lt;T&gt;(str: T): T {    return str;}let str = getData&lt;string&gt;(&#39;aaa&#39;);console.log(str);let str2 = getData&lt;number&gt;(123);console.log(str2);let str3 = getData&lt;number | string&gt;(&quot;123&quot;);console.log(str3);</code></pre><h3 id="3-泛型类"><a href="#3-泛型类" class="headerlink" title="3.泛型类"></a>3.泛型类</h3><pre><code class="ts">class MinClass&lt;T&gt; {    list: Array&lt;T&gt; = [];    add(num: T):void {        this.list.push(num);    }    min(): T {        let minVal = this.list[0];        for (let i = 0; i &lt; this.list.length; i++) {            if (minVal &gt; this.list[i]) {                minVal = this.list[i];            }        }        return minVal;    }}let num = new MinClass&lt;number&gt;();num.add(3);num.add(1);num.add(2);console.log(num.min()) //1let str = new MinClass&lt;string&gt;();str.add(&#39;y&#39;);str.add(&#39;x&#39;);str.add(&#39;w&#39;);console.log(str.min()) //w</code></pre><h3 id="4-泛型接口"><a href="#4-泛型接口" class="headerlink" title="4.泛型接口"></a>4.泛型接口</h3><pre><code class="ts">// 泛型接口 写法1interface IConfigFn {    &lt;T&gt;(value: T): T;}let fs: IConfigFn = function &lt;T&gt;(value: T): T {    return value;}let newFs = fs&lt;number&gt;(123);console.log(newFs); // 123// 泛型接口 写法2interface IConfigFn2&lt;T&gt; {    (value: T): T;}function getData&lt;T&gt;(vlaue: T): T {    return vlaue;}let getMyData: IConfigFn2&lt;boolean&gt; = getData;console.log(getMyData(false)); //false</code></pre><pre><code class="ts">interface IConfigFn {    &lt;T&gt;(value: T): T;}let fs: IConfigFn = function &lt;T&gt;(value: T): T {    return value;}console.log(fs&lt;number&gt;(123));interface IConfigFn2&lt;T&gt; {    (value: T): T;}function getData&lt;T&gt;(value: T): T {    return value;}let fs2: IConfigFn2&lt;number[]&gt; = getData;let fs3: IConfigFn2&lt;Array&lt;string&gt;&gt; = getData;console.log(fs2([1, 2, 3]));console.log(fs3([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]));</code></pre><h3 id="5-把类作为参数类型的泛型类"><a href="#5-把类作为参数类型的泛型类" class="headerlink" title="5.把类作为参数类型的泛型类"></a>5.把类作为参数类型的泛型类</h3><pre><code class="ts">// 把类作为参数来约束数据传入的类型class User {    username: string | undefined;    password: string | undefined;}class ActicleCate {    title: string | undefined;    desc: string | undefined;    constructor(params: {        title: string,        desc: string    }) {        this.title = params.title;        this.desc = params.desc;    }}class MySql&lt;T&gt;{    add(value: T): boolean {        console.log(value);        return true;    }}let db = new MySql&lt;User&gt;();db.add({    username: &#39;aaa&#39;,    password: &#39;123456&#39;});let aDb = new MySql&lt;ActicleCate&gt;();let arcticle = new ActicleCate({    title: &#39;今天好天气&#39;,    desc: &#39;25度，确实可以&#39;});aDb.add(arcticle);</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的模块和命名空间</title>
    <link href="/2020/05/03/ts/namespace/"/>
    <url>/2020/05/03/ts/namespace/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模块的概念"><a href="#1-模块的概念" class="headerlink" title="1.模块的概念"></a>1.模块的概念</h3><p>我们可以把一些公共的功能单独抽离成一个文件作为模块。<br>模块里面的变量，函数，类等默认是私有的，如果我们要在外部访问模块里面的（变量，函数，类），我们需要通过export 暴露出模块里面的（变量，函数，类）。暴露后我们通过 import 引入模块中的（变量，函数，类），这样就可以使用了。</p><pre><code class="ts">// db.tslet dbUrl = &#39;xxxxx&#39;;export function getData:any[]{    console.log(&#39;获取数据&#39;);    return [        {            title:&#39;123&#39;,            name:&#39;哈哈哈哈&#39;,        }    ]}//另一种暴露方式export {    dbUrl,    getData}// export default 默认导出，每个模块都可以有一个default导出，并且每个模块只能有一个default导出。export default getData;//引入的时候 import getData from &#39;./db/; 没有{}了。</code></pre><pre><code class="ts">// index.ts import { getData } from &#39;./db&#39;;getData();// 别名import { getData as get} from &#39;./db&#39;;get();</code></pre><h3 id="2-命名空间和模块的区别"><a href="#2-命名空间和模块的区别" class="headerlink" title="2.命名空间和模块的区别"></a>2.命名空间和模块的区别</h3><ul><li>命名空间：内部模块，主要用于组织代码，避免命名冲突。</li><li>模块：ts的外部模块的简称，侧重代码的复用，一个模块里可以有多个命名空间。</li></ul><pre><code class="ts">// 暴露命名空间Aexport namespace A{    export function getData:any[]{        console.log(&#39;获取数据&#39;);        return [            {                title:&#39;123&#39;,                name:&#39;哈哈哈哈&#39;,            }        ]    }}// 暴露命名空间Bexport namespace B{    export function getData:any[]{        console.log(&#39;获取数据&#39;);        return [            {                title:&#39;123&#39;,                name:&#39;哈哈哈哈&#39;,            }        ]    }}// 内部使用：A.getData();B.getData();// 外部使用 需要给namespace 也暴露出去</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的接口</title>
    <link href="/2020/05/02/ts/interface/"/>
    <url>/2020/05/02/ts/interface/</url>
    
    <content type="html"><![CDATA[<p>接口的作用：定义标准<br>在面向对象的编程中，接口是一种规范的定义，它定义了行为和动作的规范，在程序设计里面，接口起到了一种限制和规范的作用。接口定义了某一批类所需要遵循的规范，接口不关心这些类的内部状态数据，也不关心这些类里方法的实现细节，它只规定这批类里必须提供某些方法，提供这些方法的类就可以满足实际需要。</p><h3 id="1-属性接口"><a href="#1-属性接口" class="headerlink" title="1.属性接口"></a>1.属性接口</h3><blockquote><p>对json的约束</p></blockquote><pre><code class="ts">interface IObj {    name: string;    age?: number;}function getList(obj: IObj): void {    console.log(obj.name);    console.log(obj.age);}let obj = {    name: &#39;tom&#39;,    age: 22,//可选属性，可传，可不传}getList(obj);</code></pre><pre><code class="ts">interface IObj {    name: string;    age: number;}function getList(obj: IObj): void {    console.log(obj.name);    console.log(obj.age);}//定义在外面 只要包含name，age就可以let obj = {    name: &#39;tom&#39;,    age: 20,    firstName: &#39;t&#39;, //额外的属性}getList(obj);//定义在里面 只能有name，agegetList({    name: &#39;tom&#39;,    age: 20,    firstName: &#39;t&#39;, //错误});//正确getList({    name: &#39;tom&#39;,    age: 20,});</code></pre><h3 id="2-函数接口"><a href="#2-函数接口" class="headerlink" title="2.函数接口"></a>2.函数接口</h3><blockquote><p>对函数传入的参数和返回值进行约束</p></blockquote><pre><code class="ts">interface encrypt {    (key: string, value: string): string;}let md5: encrypt = function (key: string, value: string): string {    return key + &#39;--md5-&#39; + value;};let sha1: encrypt = function (key: string, value: string): string {    return key + &#39;--sha1-&#39; + value;};console.log(md5(&#39;name&#39;, &#39;数学&#39;));console.log(sha1(&#39;name&#39;, &#39;历史&#39;));</code></pre><h3 id="3-可索引接口"><a href="#3-可索引接口" class="headerlink" title="3.可索引接口"></a>3.可索引接口</h3><blockquote><p>对数组、对象的约束（不常用）</p></blockquote><pre><code class="ts">//对 数组的约束interface userArray {    [index: number]: string;}let arr: userArray = [&#39;a&#39;, &#39;123&#39;];// 对 对象的约束interface userObj {    [index: string]: string | number;}let obj: userObj = {    name: &#39;张三&#39;,}// 对 数组对象的约束interface userArrayObj {    [index: number]: userObj}let list: userArrayObj = [{    name: &#39;张三&#39;,    age: 20}];</code></pre><h3 id="4-类-类型接口"><a href="#4-类-类型接口" class="headerlink" title="4.类 类型接口"></a>4.类 类型接口</h3><blockquote><p>对类的约束 和抽象类有点相似</p></blockquote><pre><code class="ts">// 类 类型接口  implements 实现接口interface IAnimal {    name: string;    age: number;    eat(str: string): void;    run(value: number): string;}class Dogs implements IAnimal {    name: string;    age: number;    constructor(name: string, age: number) {        this.name = name;        this.age = age;    }    eat(str: string): void {        console.log(str);    }    run(value: number): string {        return &#39;我跑了&#39; + value;    }}</code></pre><h3 id="5-接口扩展（接口可以继承接口）"><a href="#5-接口扩展（接口可以继承接口）" class="headerlink" title="5.接口扩展（接口可以继承接口）"></a>5.接口扩展（接口可以继承接口）</h3><pre><code class="ts">interface IAnimal {    name: string;    age: number;    eat(str: string): void;    run(value: number): string;}interface IPerson extends IAnimal {    cate: string;    print(str: string): void;}class Person implements IPerson {    name: string;    age: number;    cate: string;    constructor(name: string, age: number, cate: string) {        this.name = name;        this.age = age;        this.cate = cate;    }    print(str: string): void {        console.log(str);    }    eat(str: string): void {        console.log(str + &#39;吃饭&#39;)    }    run(value: number): string {        return &#39;我跑了&#39; + value;    }}let s = new Person(&#39;小小&#39;, 20, &#39;人&#39;);console.log(s.run(60));s.eat(&#39;小小&#39;);</code></pre><pre><code class="ts">interface IAnimal {    name: string;    age: number;    eat(str: string): void;    run(value: number): string;}interface IPerson extends IAnimal {    cate: string;    print(str: string): void;}class Person implements IPerson {    name: string;    age: number;    cate: string;    constructor(name: string, age: number, cate: string) {        this.name = name;        this.age = age;        this.cate = cate;    }    print(str: string): void {        console.log(str);    }    eat(str: string): void {        console.log(str + &#39;吃饭&#39;)    }    run(value: number): string {        return &#39;我跑了&#39; + value;    }}// 同时继承类 和 实现接口class Programmer extends Person implements IPerson {    constructor(name: string, age: number, cate: string) {        super(name, age, cate);    }    print(str: string): void {        console.log(str);    }    eat(str: string): void {        console.log(str + &#39;吃饭&#39;)    }    run(value: number): string {        return &#39;我跑了&#39; + value;    }}let s = new Person(&#39;小小&#39;, 20, &#39;人&#39;);console.log(s.run(60));s.eat(&#39;小小&#39;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS中的类</title>
    <link href="/2020/05/01/ts/class/"/>
    <url>/2020/05/01/ts/class/</url>
    
    <content type="html"><![CDATA[<h3 id="1-class的创建"><a href="#1-class的创建" class="headerlink" title="1.class的创建"></a>1.class的创建</h3><pre><code class="ts">class Person {    name: string;    age: number;    constructor(name: string, age: number) { //构造方法 实例化类的时候触发的方法        this.name = name;        this.age = age;    }    run(): void {        console.log(this.name + &#39;在跑步&#39;);    }    getName(): string {        return this.name;    }    setName(name: string): void {        this.name = name;    }}let p = new Person(&#39;张三&#39;, 30);console.log(p.name); //张三p.run();// 张三在跑步console.log(p.getName());//张三p.setName(&#39;李四&#39;);console.log(p.getName());//李四</code></pre><h3 id="2-TS-类的继承-extends-super"><a href="#2-TS-类的继承-extends-super" class="headerlink" title="2.TS 类的继承 extends + super"></a>2.TS 类的继承 extends + super</h3><pre><code class="ts">class Person {    name: string;    age: number;    constructor(name: string, age: number) {        this.name = name;        this.age = age;    }    run(): void {        console.log(this.name + &#39;在跑步&#39;);    }    getName(): string {        return this.name;    }    setName(name: string): void {        this.name = name;    }}//子类class Student extends Person {    sex: string;    constructor(name: string, age: number, sex: string) {        super(name, age); //初始化父类的构造函数        this.sex = sex;    }    run(): void {        console.log(this.name + &#39;在跑步&#39;);    }    work(): void {        console.log(this.name + &#39;在工作&#39;);    }    print(): string {        return this.name + &#39;-&#39; + this.age + &#39;-&#39; + this.sex;    }}let s = new Student(&#39;李白&#39;, 400, &#39;男&#39;);console.log(s.sex); //男s.run(); //李白在跑步console.log(s.print()); //李白-400-男</code></pre><h3 id="3-类的修饰符-public-默认-private-protected"><a href="#3-类的修饰符-public-默认-private-protected" class="headerlink" title="3.类的修饰符 public(默认)  private   protected"></a>3.类的修饰符 public(默认)  private   protected</h3><table><thead><tr><th>是否可以访问</th><th>描述</th><th>父类</th><th>子类</th><th>类外部</th></tr></thead><tbody><tr><td>public</td><td>公有</td><td>ok</td><td>ok</td><td>ok</td></tr><tr><td>private</td><td>私有</td><td>ok</td><td>no</td><td>no</td></tr><tr><td>protected</td><td>保护类型</td><td>ok</td><td>ok</td><td>no</td></tr></tbody></table><h3 id="4-类的静态属性和静态方法"><a href="#4-类的静态属性和静态方法" class="headerlink" title="4.类的静态属性和静态方法"></a>4.类的静态属性和静态方法</h3><pre><code class="ts">class Person {    name: string;    age: number;    static sex:string = &#39;男&#39;;    constructor(name: string, age: number) {        this.name = name;        this.age = age;    }    run(): void {        console.log(this.name + &#39;在跑步&#39;);    }    static print():void{ //静态方法中无法访问this(即不能访问实例属性和实例方法)        console.log(Person.sex);    }}let p = new Person(&#39;zs&#39;,56);console.log(Person.sex); // 男Person.print(); // 男</code></pre><h3 id="5-多态"><a href="#5-多态" class="headerlink" title="5.多态"></a>5.多态</h3><p>父类定义一个方法不去实现，让继承他的子类去实现，每个子类有不同的表现<br>多态属于继承</p><pre><code class="ts">class Animal {    name: string;    constructor(name: string) {        this.name = name;    }    eat(): void {        console.log(this.name);    }}class Dog extends Animal {    constructor(name: string) {        super(name);    }    eat():void{        console.log(`${this.name} 要吃肉`);    }}class Fish extends Animal {    constructor(name:string){        super(name);    }    eat():void {        console.log(`${this.name} 要吃微生物`);    }}</code></pre><h3 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6.抽象类"></a>6.抽象类</h3><ul><li>是提供其他类继承的基类，不能直接被实例化。</li><li>用abstract关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现，并且必须在派生类中实现。</li><li>抽象方法只能放在抽象类中</li><li>抽象类和抽象方法用来定义标准</li></ul><pre><code class="ts">abstract class Animal {    name:string;    constructor(name:string){        this.name = name;     }    abstract eat(): any; //抽象类中的抽象方法不包含具体实现}/* let a = new Animal(); //错误 不能直接被实例化 */class Dog extends Animal {    constructor(name:string){        super(name);    }    // 抽象类的子类必须实现抽象类的抽象方法    eat(): string {        return this.name + &#39;喜欢吃肉&#39;;    }}let d = new Dog(&#39;小狗&#39;);console.log(d.eat()); //小狗喜欢吃肉</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 使用方法</title>
    <link href="/2020/04/30/git/git/"/>
    <url>/2020/04/30/git/git/</url>
    
    <content type="html"><![CDATA[<h2 id="Git-使用方法"><a href="#Git-使用方法" class="headerlink" title="Git 使用方法"></a>Git 使用方法</h2><h3 id="常用git操作"><a href="#常用git操作" class="headerlink" title="常用git操作"></a>常用git操作</h3><blockquote><pre><code>+ 新建分支并切换到新分支      git checkout -b [branch-name]+ 删除本地分支                git branch -d [branch-name]+ 删除远程分支                git push origin --delete [branch-name]+ 重置暂存区与工作区，与上一次commit保持一致     git reset --hard+ 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset [commit]</code></pre></blockquote><h3 id="1、git工作空间"><a href="#1、git工作空间" class="headerlink" title="1、git工作空间"></a>1、git工作空间</h3><p><img src="/img/git.png" srcset="/img/loading.gif" alt="git"></p><ul><li><p>Workspace: 工作区</p></li><li><p>Index/Stage：暂存区</p></li><li><p>Repository: 仓库区（或本地仓库）</p></li><li><p>Remote：远程仓库</p></li></ul><h3 id="2、新建代码仓库"><a href="#2、新建代码仓库" class="headerlink" title="2、新建代码仓库"></a>2、新建代码仓库</h3><pre><code># 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]</code></pre><h3 id="3、配置git"><a href="#3、配置git" class="headerlink" title="3、配置git"></a>3、配置git</h3><pre><code class="js"># 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h3 id="4、增加-删除文件"><a href="#4、增加-删除文件" class="headerlink" title="4、增加/删除文件"></a>4、增加/删除文件</h3><pre><code class="js"># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .</code></pre><h3 id="5、代码提交"><a href="#5、代码提交" class="headerlink" title="5、代码提交"></a>5、代码提交</h3><pre><code class="js"># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...</code></pre><h3 id="6、分支"><a href="#6、分支" class="headerlink" title="6、分支"></a>6、分支</h3><pre><code class="js"># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h3 id="7、标签"><a href="#7、标签" class="headerlink" title="7、标签"></a>7、标签</h3><pre><code class="js"># 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags</code></pre><h3 id="8、查看信息"><a href="#8、查看信息" class="headerlink" title="8、查看信息"></a>8、查看信息</h3><pre><code class="js"># 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog</code></pre><h3 id="9、远程同步"><a href="#9、远程同步" class="headerlink" title="9、远程同步"></a>9、远程同步</h3><pre><code class="js"># 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all# 更新远程分支列表$ git remote update origin -p</code></pre><h3 id="10、撤销"><a href="#10、撤销" class="headerlink" title="10、撤销"></a>10、撤销</h3><pre><code class="js"># 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop</code></pre><h3 id="11、远程同步Git参考手册"><a href="#11、远程同步Git参考手册" class="headerlink" title="11、远程同步Git参考手册"></a>11、远程同步Git参考手册</h3><p><a href="http://gitref.justjavac.com/index.html" target="_blank" rel="noopener">http://gitref.justjavac.com/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 处理如何优雅的处理复杂判断</title>
    <link href="/2020/04/29/js/if-else/"/>
    <url>/2020/04/29/js/if-else/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本if-else-逻辑判断"><a href="#1-基本if-else-逻辑判断" class="headerlink" title="1.基本if else 逻辑判断"></a>1.基本if else 逻辑判断</h3><pre><code class="js">let sex = 1;let sexText = &#39;&#39;;if(sex === 1){  sexText = &#39;男&#39;;}else if(sex === 2){  sexText = &#39;女&#39;;}else {  sexText = &#39;其他&#39;;}</code></pre><h3 id="2-switch-case"><a href="#2-switch-case" class="headerlink" title="2.switch/case"></a>2.switch/case</h3><pre><code class="js">const getStatusText = (status) =&gt; { let str = &#39;&#39;;  switch (status) {    case 1:      str=&quot;待开通&quot;;      break;    case 2:      str=&quot;开通准备中&quot;;      break;    case 3:      str=&quot;开通准备完成&quot;;      break;    default:      str=&quot;已过期&quot;;      break; }  return str;}</code></pre><h3 id="3-三元表达式"><a href="#3-三元表达式" class="headerlink" title="3.三元表达式"></a>3.三元表达式</h3><pre><code class="js">let sex = 1;let sexText = sex === 1 ? &#39;男&#39; : sex === 2 ? &#39;女&#39;: &#39;其他&#39;;</code></pre><h3 id="4-短路-amp-amp-与"><a href="#4-短路-amp-amp-与" class="headerlink" title="4.短路 &amp;&amp; 与 ||"></a>4.短路 &amp;&amp; 与 ||</h3><p>&amp;&amp; 中第一个表达式为假就不会去处理第二个表达式，|| 则相反</p><pre><code class="js">// if为真if (bool) { value = getValueTrue();}// &amp;&amp;改版bool &amp;&amp; (value = getValueTrue());// if为假if (!bool) { value = getValueFalse();}// || 改版bool || (value = getValueFalse());</code></pre><h3 id="5-对象-或-数组"><a href="#5-对象-或-数组" class="headerlink" title="5.对象 或 数组"></a>5.对象 或 数组</h3><pre><code class="js">const getStatusText = (status) =&gt; {  let statusObj = {     1: &#39;待开通&#39;,     2: &#39;开通准备中&#39;,     3: &#39;开通准备完成&#39; };  return statusObj[status] ? statusObj[status] : &#39;&#39;;}const getStatus = (status) =&gt; {  let statusArr = [&#39;待开通&#39;,&#39;开通准备中&#39;,&#39;开通准备完成&#39;]  return statusArr[status-1] ? statusArr[status-1] : &#39;&#39;;}</code></pre><h3 id="6-includes"><a href="#6-includes" class="headerlink" title="6.includes"></a>6.includes</h3><pre><code class="js">if (operate === &#39;submitAudit&#39; || operate === &#39;cancelUpdate&#39; || operate === &#39;uplineApplet&#39;) {  this.handleOperate(operate, row);  return;}//使用includesconst actionArr = [&#39;submitAudit&#39;,&#39;cancelUpdate&#39;,&#39;uplineApplet&#39;];if(actionArr.includes(operate)){  this.handleOperate(operate, row);  return;}</code></pre><h3 id="7-Map"><a href="#7-Map" class="headerlink" title="7.Map"></a>7.Map</h3><p>假如：</p><p>‘待开通’ 具有 设置版本setVersion 的操作</p><p>‘开通准备中’ 无操作</p><p>‘开通准备完成’ 具有发布releaseApplet和取消本次开通cancelDredge的操作</p><pre><code class="js">const getStatus = (status) =&gt; {  const maps = new Map([   [1,[&#39;待开通&#39;,[&#39;setVersion&#39;]]],     [2,[&#39;开通准备中&#39;,]],     [3,[&#39;开通准备完成&#39;,[&#39;releaseApplet&#39;,&#39;cancelDredge&#39;]]], ])  const action = maps.get(status);  let obj = {    statusText:&#39;&#39;,    statusFn:[], }  obj.statusText = action[0];//  [&quot;待开通&quot;]  obj.statusFn = action[1] || [];// [&#39;setVersion&#39;]  return obj;}getStatus(2) // { statusText: &quot;开通准备中&quot;,statusFn: [] }</code></pre><h3 id="其他复杂的Map用法可以参看这边文章"><a href="#其他复杂的Map用法可以参看这边文章" class="headerlink" title="其他复杂的Map用法可以参看这边文章"></a>其他复杂的Map用法可以参看这边文章</h3><p><a href="https://segmentfault.com/a/1190000017105791" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017105791</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Taro 采坑指南</title>
    <link href="/2020/03/12/taro/taro/"/>
    <url>/2020/03/12/taro/taro/</url>
    
    <content type="html"><![CDATA[<h3 id="在Taro中如何正确给自定义组件传递样式类"><a href="#在Taro中如何正确给自定义组件传递样式类" class="headerlink" title="在Taro中如何正确给自定义组件传递样式类"></a>在Taro中如何正确给自定义组件传递样式类</h3><p>需要利用 externalClasses 定义段定义若干个外部样式类。这个特性从小程序基础库版本 1.9.90 开始支持。</p><pre><code class="js">/* CustomComp.js */export default class CustomComp extends Component {  static externalClasses = [&#39;my-class&#39;]  render () {    return &lt;View className=&quot;my-class&quot;&gt;这段文本的颜色由组件外的 class 决定&lt;/View&gt;  }}</code></pre><pre><code class="js">/* MyPage.js */export default class MyPage extends Component {  render () {    return &lt;CustomComp my-class=&quot;red-text&quot; /&gt;  }}</code></pre><pre><code class="scss">/* MyPage.scss */.red-text {  color: red;}</code></pre><p>注意：externalClasses 需要使用 短横线命名法 (kebab-case)，而不是 React 惯用的 驼峰命名法 (camelCase)。否则无效。</p><h3 id="父组件的样式类完全影响子组件"><a href="#父组件的样式类完全影响子组件" class="headerlink" title="父组件的样式类完全影响子组件"></a>父组件的样式类完全影响子组件</h3><p>使用外部样式类可以让组件使用指定的组件外样式类，如果希望组件外样式类能够完全影响组件内部，可以将组件构造器中的 options.addGlobalClass 字段置为 true。这个特性从小程序基础库版本 2.2.3 开始支持。</p><pre><code class="js">/* CustomComp.js */export default class CustomComp extends Component {  static options = {    addGlobalClass: true  }  render () {    return &lt;View className=&quot;red-text&quot;&gt;这段文本的颜色由组件外的 class 决定&lt;/View&gt;  }}</code></pre><pre><code class="css">/* 组件外的样式定义 */.red-text {  color: red;}</code></pre><h3 id="在Taro中给子组件传递属性时，不能使用-…-拓展操作符"><a href="#在Taro中给子组件传递属性时，不能使用-…-拓展操作符" class="headerlink" title="在Taro中给子组件传递属性时，不能使用 … 拓展操作符"></a>在Taro中给子组件传递属性时，不能使用 … 拓展操作符</h3><pre><code class="js">const props = {firstName: &#39;Plus&#39;, lastName: &#39;Second&#39;}return &lt;Greeting {...props} /&gt; //错误return &lt;Greeting firstName=&quot;Plus&quot; lastName=&quot;Second&quot; /&gt; //正确</code></pre><h3 id="在Taro中如何阻止事件冒泡"><a href="#在Taro中如何阻止事件冒泡" class="headerlink" title="在Taro中如何阻止事件冒泡"></a>在Taro中如何阻止事件冒泡</h3><p>在 Taro 中你不能使用 <code>catchEvent</code> 的方式阻止事件冒泡。你必须明确的使用 <code>e.stopPropagation</code>。例如，阻止事件冒泡你可以这样写：</p><pre><code class="js">class Toggle extends Component {  constructor (props) {    super(props)    this.state = {isToggleOn: true}  }  onClick = (e) =&gt; {    e.stopPropagation()    this.setState(prevState =&gt; ({      isToggleOn: !prevState.isToggleOn    }))  }  render () {    return (      &lt;button onClick={this.onClick}&gt;        {this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;}      &lt;/button&gt;    )  }}</code></pre><h3 id="Taro中事件处理的传参方式"><a href="#Taro中事件处理的传参方式" class="headerlink" title="Taro中事件处理的传参方式"></a>Taro中事件处理的传参方式</h3><p>1.使用 <code>bind</code> 方式向监听函数传参，在类组件中定义的监听函数，事件对象 <code>e</code> 要排在所传递参数的后面。</p><pre><code class="js">class Popper extends Component {  constructor () {    super(...arguments)    this.state = { name:&#39;Hello world!&#39; }  }  // 你可以通过 bind 传入多个参数  preventPop (name, test, e) {    //事件对象 e 要放在最后    e.stopPropagation()  }  render () {    return &lt;Button onClick={this.preventPop.bind(this, this.state.name, &#39;test&#39;)}&gt;&lt;/Button&gt;  }}</code></pre><p>2.使用<code>匿名函数</code><br>直接写匿名函数不会打乱原有监听函数的参数顺序。<br>注意：在各小程序端，使用匿名函数，尤其是在 <code>循环中</code> 使用匿名函数，比使用 <code>bind</code> 进行事件传参占用更大的内存，速度也会更慢。</p><pre><code class="js">class Popper extends Component {  constructor () {    super(...arguments)    this.state = { name: &#39;Hello world!&#39; }  }  render () {    const name = &#39;test&#39;    return (      &lt;Button onClick={(e) =&gt; {        e.stopPropagation()        this.setState({          name        })      }}&gt;        {this.state.name}      &lt;/Button&gt;    )  }}</code></pre><p>3.<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">柯里化</a></p><pre><code class="js">class Title extends Component{  handleClick = (index) =&gt; (e) =&gt; {    e.stopPropagation()    this.setState({      currentIndex: index    })  }  render() {    const { currentIndex } = this.props;    return (      {/* 调用 `this.handleClick(currentIndex)` 会返回一个函数，这个函数可以访问到 `currentIndex` 同时也能满足 `onClick` 的签名 */}      &lt;View onClick={this.handleClick(currentIndex)}&gt;      &lt;/View&gt;    )  } }</code></pre><p>4.函数式组件传递方式<br>在函数式组件中，事件传参可以传入<code>事件的引用</code>也可以传入<code>匿名函数</code>，以下是函数式组件配合 <code>useCallback</code> 的一个例子：</p><pre><code class="js">const App = () =&gt; {  const [c1, setC1] = useState(0);  const [c2, setC2] = useState(0);  const [c3, setC3] = useState(0);  const increment = c =&gt; c + 1  // 只有 useCallback 对应的 c1 或 c2 的值改变时，才会返回新的函数  const increment1 = useCallback(() =&gt; setC1(increment), [c1]);  const increment2 = useCallback(() =&gt; setC2(increment), [c2]);  return (&lt;View&gt;    &lt;Text&gt; Counter 1 is {c1} &lt;/Text&gt;    &lt;Text&gt; Counter 2 is {c2} &lt;/Text&gt;    &lt;Text&gt; Counter 3 is {c3} &lt;/Text&gt;    &lt;View&gt;      &lt;Button onClick={increment1}&gt;Increment Counter 1&lt;/Button&gt;      &lt;Button onClick={increment2}&gt;Increment Counter 2&lt;/Button&gt;      &lt;Button onClick={() =&gt; setC3(increment)}&gt;Increment Counter 3&lt;/Button&gt;    &lt;/View&gt;  &lt;/View&gt;)}</code></pre><p>5.任何组件的事件传递都要以 <code>on</code> 开头<br>在 v1.3.0-beta.0 之后，自定义组件间的事件传递可以不用 <code>on</code> 开头，但内置组件的事件依然是以 <code>on</code> 开头的，为了一致性我们仍然推荐你以 <code>on</code> 开头命名你的事件。</p><pre><code class="js">const element = &lt;View onClick={this.onTag} /&gt;const element2 = &lt;Input onFocus={this.onFocus} /&gt;const element3 = &lt;CustomElement onAnimationEnd={this.props.onAnimationEnd} /&gt;</code></pre><h3 id="Taro中巧用逻辑运算符-amp-amp-和-三元运算符-以及-枚举-来实现条件渲染"><a href="#Taro中巧用逻辑运算符-amp-amp-和-三元运算符-以及-枚举-来实现条件渲染" class="headerlink" title="Taro中巧用逻辑运算符 &amp;&amp; 和 三元运算符 以及 枚举 来实现条件渲染"></a>Taro中巧用逻辑运算符 &amp;&amp; 和 三元运算符 以及 枚举 来实现条件渲染</h3><pre><code class="js">class LoginStatus extends Component {  render () {    const isLoggedIn = this.props.isLoggedIn    return (      &lt;View&gt;        {isLoggedIn &amp;&amp; &lt;Text&gt;已登录&lt;/Text&gt;}        {!isLoggedIn &amp;&amp; &lt;Text&gt;未登录&lt;/Text&gt;}        {isLoggedIn            ? &lt;Text&gt;已登录&lt;/Text&gt;            : &lt;Text&gt;未登录&lt;/Text&gt;        }      &lt;/View&gt;    )  }}</code></pre><pre><code class="js">function Loading (props) {  const { loadingText, LOADING_STATUS, loadingStatus, onRetry } = props  return (    &lt;View className=&#39;loading-status&#39;&gt;      {        {          &#39;loading&#39;: loadingText,          &#39;fail&#39;: &lt;View onClick={onRetry}&gt; 加载失败, 点击重试 &lt;/View&gt;,          &#39;no-more&#39;: &#39;没有更多了&#39;        }[loadingStatus] /** loadingStatus 是 `loading`、`fail`、`no-more`  其中一种状态 **/      }    &lt;/View&gt;  )}</code></pre><h3 id="Taro中循环渲染-原生小程序组件-需要指定taroKeys"><a href="#Taro中循环渲染-原生小程序组件-需要指定taroKeys" class="headerlink" title="Taro中循环渲染 原生小程序组件 需要指定taroKeys"></a>Taro中循环渲染 原生小程序组件 需要指定taroKeys</h3><p><code>taroKey</code> 适用于循环渲染原生小程序组件，赋予每个元素唯一确定标识，转换为小程序的 <code>wx:key</code>。</p><pre><code class="js">const numbers = [...Array(100).keys()] // [0, 1, 2, ..., 98, 99]const listItems = numbers.map((number) =&gt; {  return (    // native component    &lt;g-list      taroKey={String(number)}      className=&#39;g-list&#39;    &gt;    我是第 {number + 1} 个数字    &lt;/g-list&gt;  )})</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
      <tag>Taro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6/ES7 常用集锦</title>
    <link href="/2020/03/11/js/es6/"/>
    <url>/2020/03/11/js/es6/</url>
    
    <content type="html"><![CDATA[<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>A.使用Set处理数组去重和删除元素，Set是es6新增的一种数据结构，它和数组非常相似，但是成员的值都是唯一的，没有重复的值。提供4个语义化的API：<br>1.<code>add(value)</code>;添加某个值，返回Set结构本身。<br>2.<code>delete(value)</code>;删除某个值，返回一个布尔值，表示删除是否成功。<br>3.<code>has(value)</code>;返回一个布尔值，表示改值是否为Set的成员。<br>4.<code>clear()</code>;清除所有成员，没有返回值。</p><pre><code class="javascript">let arr= [1,2,3,4,4,5,5,5];let set = new Set(arr);console.log(...set); //1 2 3 4 5</code></pre><p>注意：这个方法对元素为对象的数组不奏效。Set判断元素是否重复的方法类似于<code>===</code>。</p><p>B.删除数组中指定的元素：</p><pre><code class="javascript">const arr = [1,2,3];//例如删除数组中值为2的元素const index = arr.indexOf(2);if(index != -1){    arr.splice(index,1);}console.log(arr); //[1,3]//使用setconst arr = [1,2,3];const set = new Set(arr);set.delete(2);arr = [...set];console.log(arr); //[1,3]</code></pre><p>C.使用<code>map()</code>方法和对象解构语法提取字段</p><pre><code class="javascript">let studentInfo = [    { name: &#39;Alice&#39;, age: 18, no: 2 },    { name: &#39;Bob&#39;, age: 16, no: 5 },    { name: &#39;Candy&#39;, age: 17, no: 3 },    { name: &#39;Den&#39;, age: 18, no: 4 },    { name: &#39;Eve&#39;, age: 16, no: 1 },]const nameList = studentInfo.map(({name}) =&gt; name);console.log(nameList); //[&quot;Alice&quot;, &quot;Bob&quot;, &quot;Candy&quot;, &quot;Den&quot;, &quot;Eve&quot;]</code></pre><p>D.使用<code>filter()</code>方法和对象解构语法过滤字段</p><pre><code class="javascript">let studentInfo = [    { name: &#39;Alice&#39;, age: 18, no: 2 },    { name: &#39;Bob&#39;, age: 16, no: 5 },    { name: &#39;Candy&#39;, age: 17, no: 3 },    { name: &#39;Den&#39;, age: 18, no: 4 },    { name: &#39;Eve&#39;, age: 16, no: 1 },]const newStudentInfo = studentInfo.filter(({age}) =&gt; age&gt;17);console.log(newStudentInfo); //[ { name: &#39;Alice&#39;, age: 18, no: 2 }, { name: &#39;Den&#39;, age: 18, no: 4 }]</code></pre><p>E.数组遍历使用<code>for in</code>,<code>forEach</code>,<code>for of</code></p><pre><code class="javascript">let studentInfo = [    { name: &#39;Alice&#39;, age: 18, no: 2 },    { name: &#39;Bob&#39;, age: 16, no: 5 },    { name: &#39;Candy&#39;, age: 17, no: 3 },    { name: &#39;Den&#39;, age: 18, no: 4 },    { name: &#39;Eve&#39;, age: 16, no: 1 },]for(let i in studentInfo) {    console.log(i);//下标    console.log(studentInfo[i]);}studentInfo.forEach((value,index,arr) =&gt; {    console.log(value);    console.log(index);    console.log(arr);})for(let i of studentInfo) {    console.log(i);//每一项的值 { name: &#39;Alice&#39;, age: 18, no: 2 }}</code></pre><p>F.最短的代码创建一个长度为6，每个值为8的数组</p><pre><code class="javascript">Array(6).fill(8); //[8, 8, 8, 8, 8, 8]</code></pre><p>更多详细参考：<a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">阮一峰大神</a></p><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><pre><code class="javascript">//数组解构let [a, b, c] = [4, 5, 6]; //a=4,b=5,c=6//解构不成功其值为undefinedlet [a] = []; //a = undefinedlet [a, b] = [1];//b = undefined//对象解构let { a, b, c} = { b: &quot;aaa&quot;, a: &quot;bbb&quot; };//a = &quot;bbb&quot;//b = &quot;aaa&quot;//c = undefinedlet { a : b } = { a: &quot;aaa&quot;, c: &quot;bbb&quot; };//b = &quot;aaa&quot;//a  error: foo is not defined//a是匹配的模式，b才是变量。真正被赋值的是变量baz，而不是模式foo。//字符串解构const [a, b, c, d, e] = &#39;hello&#39;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot;//函数参数解构function add([a, b]){    return a + b;}add([1, 2]); // 3常见的用途// 1.交换变量的值let x = 1;let y = 2;[x, y] = [y, x];// 2.函数返回值// 返回一个数组function num() {return [1, 2, 3];}let [a, b, c] = num();// 返回一个对象function example() {    return {        a: 1,        b: 2    };}let { a, b } = example();// 3.解析json数据let json = {    id: 1,    status: 404,    data: [123, 456]};let { id, status, data: number } = json;console.log(id, status, number);// 1, 404, [123, 456]</code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>1.模板字符串<br>2.JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。<br>    1.<code>includes(target,[index])</code>：返回布尔值，表示是否找到了参数字符串。<br>    2.<code>startsWith(target,[index])</code>：返回布尔值，表示参数字符串是否在原字符串的头部。<br>    3.<code>endsWith(target,[index])</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。<br>    <code>target</code> 目标字符串，<code>index</code>可选参数 开始搜索的位置</p><pre><code class="javascript">let s = &#39;Hello world!&#39;;s.startsWith(&#39;Hello&#39;) // trues.endsWith(&#39;!&#39;) // trues.includes(&#39;o&#39;) // trues.startsWith(&#39;world&#39;, 6) // trues.endsWith(&#39;Hello&#39;, 5) // trues.includes(&#39;Hello&#39;, 6) // false</code></pre><p>3.<code>str.repeat(n)</code>方法 返回一个新字符串，表示将原字符串重复n次。 n可以是大于-1的数</p><pre><code class="javascript">let s = &quot;abc&quot;;s.repeat(3); //abcabcabc 参数为NaN 等同于 0s.repeat(-1) //RangeError 参数是负数或者Infinity，会报错。s.repeat(1.9) //abcabc 参数如果是小数，会被取整。s.repeat(-0.5) // &quot;&quot; 参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</code></pre><h3 id="ES5的类"><a href="#ES5的类" class="headerlink" title="ES5的类"></a>ES5的类</h3><p>1.构造函数 实例属性和方法</p><pre><code class="javascript">function Person() {    this.name = &quot;tom&quot;;    this.age = 20;    this.speak = function(){        console.log(this.name + &#39;:&#39; + this.age);    }}let p = new Person();console.log(p.name); //tomp.speak(); // tom:20</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>ES7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 常用集锦</title>
    <link href="/2020/03/11/js/js/"/>
    <url>/2020/03/11/js/js/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串基本操作"><a href="#字符串基本操作" class="headerlink" title="字符串基本操作"></a>字符串基本操作</h3><p>参考链接：<a href="https://www.jb51.net/article/97915.htm" target="_blank" rel="noopener">字符串操作</a></p><h3 id="数组基本操作"><a href="#数组基本操作" class="headerlink" title="数组基本操作"></a>数组基本操作</h3><p>参考链接：<a href="http://www.cnblogs.com/blogs-8888/p/6518683.html" target="_blank" rel="noopener">数组操作</a></p><h3 id="字符串去空格"><a href="#字符串去空格" class="headerlink" title="字符串去空格"></a>字符串去空格</h3><pre><code class="javascript">let trimSpace = function(str,is_global){    let result;    result = str.replace(/(^\s+)|(\s+$)/g,&quot;&quot;);    if(is_global &amp;&amp; is_global.toLowerCase()==&quot;g&quot;){        result = result.replace(/\s/g,&quot;&quot;);    }    return result;}</code></pre><h3 id="获取url参数值"><a href="#获取url参数值" class="headerlink" title="获取url参数值"></a>获取url参数值</h3><pre><code class="javascript">function getQueryVal(url){    let url = url || &#39;&#39;;    let arr = (url.split(&quot;?&quot;)[1] || url || &#39;&#39;).split(&quot;&amp;&quot;);    let o={};    if(arr[0]==&#39;&#39;){return o}    arr.forEach(function(x){        let ar=x.split(&quot;=&quot;);        o[ar[0]]=ar[1]    });    return o}eg: console.log(getQueryVal(&quot;http://192.168.28.50.9090/#/twitterInfo?isNeed=0&amp;userType=c&quot;));//{isNeed: &quot;0&quot;, userType: &quot;c&quot;}</code></pre><h3 id="vue里面使用hash模式获取url参数值"><a href="#vue里面使用hash模式获取url参数值" class="headerlink" title="vue里面使用hash模式获取url参数值"></a>vue里面使用hash模式获取url参数值</h3><pre><code class="javascript">/** *  name [参数名称] */let getHashString = function(name) {    let url = window.location.hash.substr(1);    let theRequest = {};    if(url.indexOf(&quot;?&quot;)&gt;-1){        let  strs = url.split(&quot;?&quot;)[1].split(&quot;&amp;&quot;);        for(let i = 0; i &lt; strs.length; i ++) {            theRequest[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]);        }        for(let j in theRequest){            if(name==j){                return theRequest[j];            }        }      }else {        return null;    }};eg:  console.log(getHashString(&quot;userType&quot;));// c</code></pre><h3 id="history模式获取url参数值"><a href="#history模式获取url参数值" class="headerlink" title="history模式获取url参数值"></a>history模式获取url参数值</h3><pre><code class="javascript">/** * name [参数名称] */let getQueryString = function(name) {    let reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);    let r = window.location.search.substr(1).match(reg);    if(r!=null)return  unescape(r[2]); return null;};eg: 当前的url是http://localhost:4000/home/index.html?caseid=123&amp;idx=1console.log(getQueryString(&quot;caseid&quot;));// 123</code></pre><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><pre><code class="javascript">function debounce(func,delay){    let timer = null;    return function(...args){        if(timer){            clearTimeout(timer);        }        timer = setTimeout(()=&gt;{            func.apply(this,args);        },delay)            }}// 测试function show(){    console.log(&#39;hello...&#39;);}let func = debounce(show,3000);// 调用func(); func(); func(); func(); func(); // 连续调用时，没有超过三秒是不会有任何输出的//hello...</code></pre><h3 id="Async-Await是Generator和Promise的组合，完全解决了基于回调的异步"><a href="#Async-Await是Generator和Promise的组合，完全解决了基于回调的异步" class="headerlink" title="Async/Await是Generator和Promise的组合，完全解决了基于回调的异步"></a>Async/Await是Generator和Promise的组合，完全解决了基于回调的异步</h3><pre><code class="javascript">let getKeyPromise = function () {    return new Promsie(function (resolve, reject) {        $.ajax({            type: &#39;get&#39;,            url: &#39;http://localhost:3000/apiKey&#39;,            success: function (data) {            let key = data;            resolve(key);                     },            error: function (err) {                reject(err);            }        });    });};let getTokenPromise = function (key) {    return new Promsie(function (resolve, reject) {        $.ajax({            type: &#39;get&#39;,            url: &#39;http://localhost:3000/getToken&#39;,            data: {                key: key            },            success: function (data) {                resolve(data);                     },            error: function (err) {                reject(err);            }        });    });};let getDataPromise = function (data) {    let token = data.token;    let userId = data.userId;    return new Promsie(function (resolve, reject) {        $.ajax({            type: &#39;get&#39;,            url: &#39;http://localhost:3000/getData&#39;,            data: {                token: token,                userId: userId            },            success: function (data) {                resolve(data);                     },            error: function (err) {                reject(err);            }        });    });};async function main () {    let key = await getKeyPromise();    let loginData = await getTokenPromise(key);    let busiData = await getDataPromise(loginData);    console.log(&#39;数据：&#39;, busiData);}main();console.log(&#39;123&#39;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 常用集锦</title>
    <link href="/2020/03/11/vue/vue/"/>
    <url>/2020/03/11/vue/vue/</url>
    
    <content type="html"><![CDATA[<h3 id="1-v-text-v-html-中如何使用过滤器"><a href="#1-v-text-v-html-中如何使用过滤器" class="headerlink" title="1.v-text/v-html 中如何使用过滤器"></a>1.v-text/v-html 中如何使用过滤器</h3><p>Vue2.x 不再支持在 <code>v-html</code> 中使用过滤器Vue2.x 的过滤器现在只能应用在“Mustache”语法 (双大括号) 的文本插值 和 <code>v-bind</code> 中。<br>如果要使用采用如下方式：</p><p><code>v-html=&quot;$options.filters.过滤器名称(需要过滤的内容,[过滤器需要的参数])&quot;</code></p><h3 id="2-在Vue组件中动态生成的DOM类名样式不作用-deep"><a href="#2-在Vue组件中动态生成的DOM类名样式不作用-deep" class="headerlink" title="2.在Vue组件中动态生成的DOM类名样式不作用-/deep/"></a>2.在Vue组件中动态生成的DOM类名样式不作用-/deep/</h3><pre><code class="html">&lt;template&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;div v-text=&quot;text&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name:&quot;app&quot;,        data(){            return {                text:&lt;span class=&quot;red&quot;&gt;红色&lt;/span&gt;            }         }    }&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;    /deep/ .red{        color:red;    }&lt;/style&gt;</code></pre><p>注意：/deep/ 只是在最外层使用，不要嵌套使用。<br>参考文档：<a href="https://vue-loader.vuejs.org/guide/scoped-css.html" target="_blank" rel="noopener">deep</a></p><h3 id="3-使用a标签打电话"><a href="#3-使用a标签打电话" class="headerlink" title="3.使用a标签打电话"></a>3.使用a标签打电话</h3><pre><code class="html">&lt;a :href=&quot;&#39;tel:&#39;+ phone&quot;&gt;打电话&lt;/a&gt;</code></pre><h3 id="4-注册自定义指令"><a href="#4-注册自定义指令" class="headerlink" title="4.注册自定义指令"></a>4.注册自定义指令</h3><ul><li><p>全局注册</p><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;      &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt;      &lt;input v-focus&gt;  &lt;/div&gt;  &lt;script&gt;  // 注册一个全局自定义指令 v-focus  Vue.directive(&#39;focus&#39;, {  // 当绑定元素插入到 DOM 中。  inserted: function (el) {      // 聚焦元素      el.focus()  }  })  // 创建根实例  new Vue({  el: &#39;#app&#39;  })  &lt;/script&gt;</code></pre></li><li><p>局部注册</p><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;  &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt;  &lt;input v-focus&gt;  &lt;/div&gt;  &lt;script&gt;  // 创建根实例  new Vue({  el: &#39;#app&#39;,  directives: {      // 注册一个局部的自定义指令 v-focus      focus: {      // 指令的定义      inserted: function (el) {          // 聚焦元素          el.focus()      }      }  }  })  &lt;/script&gt;</code></pre></li></ul><h3 id="5-Prop-验证"><a href="#5-Prop-验证" class="headerlink" title="5.Prop 验证"></a>5.Prop 验证</h3><p>我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。</p><p>为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的<code>对象</code>，而不是一个<code>字符串数组</code>。例如：</p><pre><code class="js">Vue.component(&#39;my-component&#39;, {  props: {    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)    propA: Number,    // 多个可能的类型    propB: [String, Number],    // 必填的字符串    propC: {      type: String,      required: true    },    // 带有默认值的数字    propD: {      type: Number,      default: 100    },    // 带有默认值的对象    propE: {      type: Object,      // 对象或数组默认值必须从一个工厂函数获取      default: function () {        return { message: &#39;hello&#39; }      }    },    // 自定义验证函数    propF: {      validator: function (value) {        // 这个值必须匹配下列字符串中的一个        return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].indexOf(value) !== -1      }    }  }})</code></pre><h3 id="6-子组件传数据到父组件"><a href="#6-子组件传数据到父组件" class="headerlink" title="6.子组件传数据到父组件"></a>6.子组件传数据到父组件</h3><p><img src="/img/vue/%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92.png" srcset="/img/loading.gif" alt="子组件传数据到父组件"></p><h3 id="7-生命周期"><a href="#7-生命周期" class="headerlink" title="7.生命周期"></a>7.生命周期</h3><p><img src="/img/vue/lifecycle.png" srcset="/img/loading.gif" alt="vue2.x生命周期"></p><h3 id="8-生成二维码"><a href="#8-生成二维码" class="headerlink" title="8.生成二维码"></a>8.生成二维码</h3><p><a href="https://github.com/theomessin/vue-qriously#readme" target="_blank" rel="noopener">vue-qriously</a><br><a href="https://segmentfault.com/a/1190000014875645" target="_blank" rel="noopener">生成二维码并下载</a></p><ul><li><p>如何安装并导入</p><pre><code class="js">  // ES6  import Vue from &#39;vue&#39;  import VueQriously from &#39;vue-qriously&#39;  Vue.use(VueQriously)  // ES5  var Vue = require(&#39;vue&#39;)  Vue.use(require(&#39;vue-qriously&#39;).default)</code></pre></li><li><p>如何使用</p><pre><code class="html">  &lt;qriously value=&quot;Hello World!&quot; :size=&quot;200&quot; /&gt;</code></pre><p>参数：</p></li><li><p>background: string 二维码背景  默认：’white’</p></li><li><p>backgroundAlpha:number 二维码背景透明度 默认： 1.0</p></li><li><p>foreground:string 二维码前景色 默认：’black’</p></li><li><p>foregroundAlpha:number 二维码前景色透明度 默认：1.0</p></li><li><p>level:string 二维码误差校验等级(L,M,Q,H) 默认：’L’</p></li><li><p>mime:string 二维码图片的mine type</p></li><li><p>padding:number 二维码padding值(像素) 默认null(auto)</p></li><li><p>size:number 二维码大小(像素) 默认：100</p></li><li><p>value:string 二维码内容</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 常用集锦</title>
    <link href="/2020/03/11/css/css/"/>
    <url>/2020/03/11/css/css/</url>
    
    <content type="html"><![CDATA[<h3 id="多行文本垂直居中"><a href="#多行文本垂直居中" class="headerlink" title="多行文本垂直居中"></a>多行文本垂直居中</h3><p>父元素 设置：display:table,height:500px;<br>子元素 设置：dispaly:table-cell;vertical-align:middle;</p><pre><code class="html">&lt;div class=&quot;parent&quot;&gt;&lt;span class=&quot;child&quot;&gt;    &lt;img src=&quot;&quot;/&gt;    &lt;span&gt;垂直居中&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;</code></pre><pre><code class="css">.parent {    display:table,height:500px}.child {    dispaly:table-cell;vertical-align:middle}</code></pre><h3 id="webkit表单输入框placeholder的颜色值改变"><a href="#webkit表单输入框placeholder的颜色值改变" class="headerlink" title="webkit表单输入框placeholder的颜色值改变"></a>webkit表单输入框placeholder的颜色值改变</h3><pre><code class="css">如果想要默认的颜色显示红色，代码如下：input::-webkit-input-placeholder{color:red;}如果想要用户点击变为蓝色，代码如下：input:focus::-webkit-input-placeholder{color:blue;}</code></pre><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>word-break:break-all;只对英文起作用，以字母作为换行依据<br>word-wrap:break-word;只对英文起作用，以单词作为换行依据<br>white-space:pre-wrap;只对中文起作用，强制换行<br>white-space:nowrap;都起作用，强制不换行</p><p>white-space:nowrap;<br>overflow:hidden;<br>text-overflow:ellipsis;<br>width:500px;<br>不换行超出部分显示…</p><p>常用自定义类名：</p><pre><code class="css">/*自动换行*/.cut-text {    word-break:break-all;    word-wrap:break-word;}/*强制不换行*/.no-cut-text {    white-space:nowrap;}/*英文换行*/.en-cut-text  {    word-break:break-all;}/*超出显示...*/.text-dots {    width:500px;    text-overflow:ellipsis;    overflow:hidden;    white-space:nowrap;}/*超出两行文本显示...*/ /*必须指定width*/.text2LineRestrist {    overflow: hidden;    text-overflow:ellipsis;    display:-webkit-box;    -webkit-box-orient:vertical;    -webkit-line-clamp:2;}/*超出三行文本显示...*/ /*必须指定width*/.text3LineRestrist {    overflow: hidden;    text-overflow:ellipsis;    display:-webkit-box;    -webkit-box-orient:vertical;    -webkit-line-clamp:3;}</code></pre><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><pre><code class="css">.clearfix {zoom:1;}.clearfix::after,.clearfix::before{    content:&quot;&quot;;    display:block;    clear: both;    visibility: hidden;    height:0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
